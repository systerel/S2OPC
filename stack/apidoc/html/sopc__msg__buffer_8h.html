<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>INGOPCS OPCUA stack: src/core_tools/sopc_msg_buffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">INGOPCS OPCUA stack
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_04f71deb54aacd62bc525a857d4427d7.html">core_tools</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sopc_msg_buffer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Binary UA (and TCP UA) message representation with one or several chunks. It is used for TCP UA messages layer and UA secure messages layer (write/read operations are layer dependent).  
<a href="#details">More...</a></p>

<p><a href="sopc__msg__buffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UA Message buffer (with one or several chunks). Note: <a class="el" href="structSOPC__MsgBuffer.html" title="UA Message buffer (with one or several chunks). Note: SOPC_MsgBuffer type must be used to store only ...">SOPC_MsgBuffer</a> type must be used to store only one chunk at same time and SOPC_MsgBuffers type to store several chunks at same time.  <a href="structSOPC__MsgBuffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a07bb1eb7b745c44ae343626aada6467d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a07bb1eb7b745c44ae343626aada6467d">SOPC_MsgBuffer</a></td></tr>
<tr class="memdesc:a07bb1eb7b745c44ae343626aada6467d"><td class="mdescLeft">&#160;</td><td class="mdescRight">UA Message buffer (with one or several chunks). Note: <a class="el" href="structSOPC__MsgBuffer.html" title="UA Message buffer (with one or several chunks). Note: SOPC_MsgBuffer type must be used to store only ...">SOPC_MsgBuffer</a> type must be used to store only one chunk at same time and SOPC_MsgBuffers type to store several chunks at same time.  <a href="#a07bb1eb7b745c44ae343626aada6467d">More...</a><br/></td></tr>
<tr class="separator:a07bb1eb7b745c44ae343626aada6467d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4254971740ef7f40ba501362dfc2a1b4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a></td></tr>
<tr class="memdesc:a4254971740ef7f40ba501362dfc2a1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">UA Message buffer with several buffers (to store several chunks)  <a href="#a4254971740ef7f40ba501362dfc2a1b4">More...</a><br/></td></tr>
<tr class="separator:a4254971740ef7f40ba501362dfc2a1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6195df8ec79297a8b7fd5aa248386271"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a6195df8ec79297a8b7fd5aa248386271">SOPC_SecureMessageType</a> { <a class="el" href="sopc__msg__buffer_8h.html#a6195df8ec79297a8b7fd5aa248386271adfd196cda6cbfb17e360463b7de36e66">SOPC_SecureMessage</a>, 
<a class="el" href="sopc__msg__buffer_8h.html#a6195df8ec79297a8b7fd5aa248386271a4264f617931afe26e4279ea729fc16c8">SOPC_OpenSecureChannel</a>, 
<a class="el" href="sopc__msg__buffer_8h.html#a6195df8ec79297a8b7fd5aa248386271a085ebdd354e7acb61c5b358bdb1532e1">SOPC_CloseSecureChannel</a>
 }</td></tr>
<tr class="memdesc:a6195df8ec79297a8b7fd5aa248386271"><td class="mdescLeft">&#160;</td><td class="mdescRight">UA Secure Message types.  <a href="sopc__msg__buffer_8h.html#a6195df8ec79297a8b7fd5aa248386271">More...</a><br/></td></tr>
<tr class="separator:a6195df8ec79297a8b7fd5aa248386271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52655ecfe5c525b5916e06c8551778c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a52655ecfe5c525b5916e06c8551778c8">TCP_UA_MsgType</a> { <br/>
&#160;&#160;<a class="el" href="sopc__msg__buffer_8h.html#a52655ecfe5c525b5916e06c8551778c8a415f073424a265ade3e3ac7f12c15518">TCP_UA_Message_Unknown</a>, 
<a class="el" href="sopc__msg__buffer_8h.html#a52655ecfe5c525b5916e06c8551778c8a9951dfed78ad2500347e396b41b3be7f">TCP_UA_Message_Invalid</a>, 
<a class="el" href="sopc__msg__buffer_8h.html#a52655ecfe5c525b5916e06c8551778c8a8b16c25990568a3f422e269108e2e327">TCP_UA_Message_Hello</a>, 
<a class="el" href="sopc__msg__buffer_8h.html#a52655ecfe5c525b5916e06c8551778c8ab42f25a9aa02f3e0daf9e490ac66e77f">TCP_UA_Message_Acknowledge</a>, 
<br/>
&#160;&#160;<a class="el" href="sopc__msg__buffer_8h.html#a52655ecfe5c525b5916e06c8551778c8a3a529ca74922364cdb0e54ef5f50ab97">TCP_UA_Message_Error</a>, 
<a class="el" href="sopc__msg__buffer_8h.html#a52655ecfe5c525b5916e06c8551778c8a226599f25fc104a07e82682bb23edf74">TCP_UA_Message_SecureMessage</a>
<br/>
 }</td></tr>
<tr class="memdesc:a52655ecfe5c525b5916e06c8551778c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP UA Message types.  <a href="sopc__msg__buffer_8h.html#a52655ecfe5c525b5916e06c8551778c8">More...</a><br/></td></tr>
<tr class="separator:a52655ecfe5c525b5916e06c8551778c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51724ce4413e66370783a3d9b9248024"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a51724ce4413e66370783a3d9b9248024">SOPC_MsgFinalChunk</a> { <br/>
&#160;&#160;<a class="el" href="sopc__msg__buffer_8h.html#a51724ce4413e66370783a3d9b9248024a6b0afea30039b449b5c3cfb452fa9b98">SOPC_Msg_Chunk_Unknown</a>, 
<a class="el" href="sopc__msg__buffer_8h.html#a51724ce4413e66370783a3d9b9248024a5e5574c73788cbf8276b9dde87c8e0d9">SOPC_Msg_Chunk_Invalid</a>, 
<a class="el" href="sopc__msg__buffer_8h.html#a51724ce4413e66370783a3d9b9248024a10b1f401743303af636bad0252f42adf">SOPC_Msg_Chunk_Intermediate</a>, 
<a class="el" href="sopc__msg__buffer_8h.html#a51724ce4413e66370783a3d9b9248024a680a0ee402d10de473c11aecb3195eb6">SOPC_Msg_Chunk_Final</a>, 
<br/>
&#160;&#160;<a class="el" href="sopc__msg__buffer_8h.html#a51724ce4413e66370783a3d9b9248024ad9cdfc4a0a9f82fbe89b8bfbde8e62f2">SOPC_Msg_Chunk_Abort</a>
<br/>
 }</td></tr>
<tr class="memdesc:a51724ce4413e66370783a3d9b9248024"><td class="mdescLeft">&#160;</td><td class="mdescRight">UA Message Chunk IsFinal type.  <a href="sopc__msg__buffer_8h.html#a51724ce4413e66370783a3d9b9248024">More...</a><br/></td></tr>
<tr class="separator:a51724ce4413e66370783a3d9b9248024"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5073e7d76c8fc7439d8e5e83bbf8e82f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a5073e7d76c8fc7439d8e5e83bbf8e82f">MsgBuffer_Create</a> (<a class="el" href="structSOPC__Buffer.html">SOPC_Buffer</a> *buffer, uint32_t maxChunks, void *flushData, <a class="el" href="structSOPC__NamespaceTable.html">SOPC_NamespaceTable</a> *nsTable, <a class="el" href="structSOPC__EncodeableType.html">SOPC_EncodeableType</a> **encTypesTable)</td></tr>
<tr class="memdesc:a5073e7d76c8fc7439d8e5e83bbf8e82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation of an UA Message buffer containing only 1 buffer.  <a href="#a5073e7d76c8fc7439d8e5e83bbf8e82f">More...</a><br/></td></tr>
<tr class="separator:a5073e7d76c8fc7439d8e5e83bbf8e82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16506a102439bead60b2c4394a1758da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a16506a102439bead60b2c4394a1758da">MsgBuffer_Delete</a> (<a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> **mBuffer)</td></tr>
<tr class="memdesc:a16506a102439bead60b2c4394a1758da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocation of an UA Message buffer and its contained buffer.  <a href="#a16506a102439bead60b2c4394a1758da">More...</a><br/></td></tr>
<tr class="separator:a16506a102439bead60b2c4394a1758da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fb22a71bddd3f90199c426202c4464"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a03fb22a71bddd3f90199c426202c4464">MsgBuffer_Reset</a> (<a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *mBuffer)</td></tr>
<tr class="memdesc:a03fb22a71bddd3f90199c426202c4464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the UA Message buffer state (buffer content, type, number of chunks, etc.) in order it could be use to receive / send a new UA message. Note: properties maxChunks, flushData, namespaces and encodeable types are not modified.  <a href="#a03fb22a71bddd3f90199c426202c4464">More...</a><br/></td></tr>
<tr class="separator:a03fb22a71bddd3f90199c426202c4464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac501d522ef0b2b2f27f39b71e654641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#aac501d522ef0b2b2f27f39b71e654641">MsgBuffer_ResetNextChunk</a> (<a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *mBuffer, uint32_t bodyPosition)</td></tr>
<tr class="memdesc:aac501d522ef0b2b2f27f39b71e654641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the UA Message buffer state for next chunk reception/sending at the given position (precedent not kept since only 1 buffer available)  <a href="#aac501d522ef0b2b2f27f39b71e654641">More...</a><br/></td></tr>
<tr class="separator:aac501d522ef0b2b2f27f39b71e654641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ecb443e11e5a6f67212db35b79c023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a37ecb443e11e5a6f67212db35b79c023">MsgBuffer_SetSecureMsgType</a> (<a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *mBuffer, <a class="el" href="sopc__msg__buffer_8h.html#a6195df8ec79297a8b7fd5aa248386271">SOPC_SecureMessageType</a> sType)</td></tr>
<tr class="memdesc:a37ecb443e11e5a6f67212db35b79c023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Secure Message Type of the UA Message (and coherent TCP UA type)  <a href="#a37ecb443e11e5a6f67212db35b79c023">More...</a><br/></td></tr>
<tr class="separator:a37ecb443e11e5a6f67212db35b79c023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51791c4540bbe61d725b1cc555b083c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#aa51791c4540bbe61d725b1cc555b083c">MsgBuffer_CopyBuffer</a> (<a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *destMsgBuffer, <a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *srcMsgBuffer)</td></tr>
<tr class="memdesc:aa51791c4540bbe61d725b1cc555b083c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy source UA Message buffer content into destination one. Note: properties maxChunks, flushData, namespaces and encodeable types are not concerned by the copy.  <a href="#aa51791c4540bbe61d725b1cc555b083c">More...</a><br/></td></tr>
<tr class="separator:aa51791c4540bbe61d725b1cc555b083c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb299718224b6ff20fcba57acc23ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a6eb299718224b6ff20fcba57acc23ad3">MsgBuffers_Create</a> (uint32_t maxChunks, uint32_t bufferSize, void *flushData, <a class="el" href="structSOPC__NamespaceTable.html">SOPC_NamespaceTable</a> *nsTable, <a class="el" href="structSOPC__EncodeableType.html">SOPC_EncodeableType</a> **encTypesTable)</td></tr>
<tr class="memdesc:a6eb299718224b6ff20fcba57acc23ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation of an UA Message buffer with several buffers (to store several chunks) and allocate the buffers Note: nbChunks set to 0 after creation, MsgBuffers_NextChunk must be called before storing data for first chunk.  <a href="#a6eb299718224b6ff20fcba57acc23ad3">More...</a><br/></td></tr>
<tr class="separator:a6eb299718224b6ff20fcba57acc23ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc97a693377c52260fd9c5147904c05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a2cc97a693377c52260fd9c5147904c05">MsgBuffers_Reset</a> (<a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *mBuffer)</td></tr>
<tr class="memdesc:a2cc97a693377c52260fd9c5147904c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the UA Message buffers state (buffers content, type, number of chunks, etc.) in order it could be use to receive new UA message.  <a href="#a2cc97a693377c52260fd9c5147904c05">More...</a><br/></td></tr>
<tr class="separator:a2cc97a693377c52260fd9c5147904c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fe9800addf1573e84040ebbc1836fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a97fe9800addf1573e84040ebbc1836fd">MsgBuffers_Delete</a> (<a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> **mBuffer)</td></tr>
<tr class="memdesc:a97fe9800addf1573e84040ebbc1836fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocation of an UA Message buffers and its contained buffers.  <a href="#a97fe9800addf1573e84040ebbc1836fd">More...</a><br/></td></tr>
<tr class="separator:a97fe9800addf1573e84040ebbc1836fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0249a2d13e8b17086c742f26e5c98a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSOPC__Buffer.html">SOPC_Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#af0249a2d13e8b17086c742f26e5c98a9">MsgBuffers_GetCurrentChunk</a> (<a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *mBuffer)</td></tr>
<tr class="memdesc:af0249a2d13e8b17086c742f26e5c98a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current chunk (last received chunk) buffer of UA Message buffers.  <a href="#af0249a2d13e8b17086c742f26e5c98a9">More...</a><br/></td></tr>
<tr class="separator:af0249a2d13e8b17086c742f26e5c98a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb91e812a77da7ab7f1c245a0a16958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSOPC__Buffer.html">SOPC_Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#afdb91e812a77da7ab7f1c245a0a16958">MsgBuffers_NextChunk</a> (<a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *mBuffer, uint32_t *bufferIdx)</td></tr>
<tr class="memdesc:afdb91e812a77da7ab7f1c245a0a16958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the next (empty) chunk buffer of UA Message buffers as current one and returns it.  <a href="#afdb91e812a77da7ab7f1c245a0a16958">More...</a><br/></td></tr>
<tr class="separator:afdb91e812a77da7ab7f1c245a0a16958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1f0be7a847efc5a290898dddd55324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSOPC__Buffer.html">SOPC_Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#afd1f0be7a847efc5a290898dddd55324">MsgBuffers_NextChunkWithHeadersCopy</a> (<a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *mBuffers, uint32_t bodyPosition)</td></tr>
<tr class="memdesc:afd1f0be7a847efc5a290898dddd55324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy content of current chunk until message body position (headers content) into next chunk, then set the next chunk buffer of UA Message buffers as current one and returns it.  <a href="#afd1f0be7a847efc5a290898dddd55324">More...</a><br/></td></tr>
<tr class="separator:afd1f0be7a847efc5a290898dddd55324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994f01da65b64a13d550ceb6294ce3c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a994f01da65b64a13d550ceb6294ce3c1">MsgBuffers_SetCurrentChunkFirst</a> (<a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *mBuffer)</td></tr>
<tr class="memdesc:a994f01da65b64a13d550ceb6294ce3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current chunk buffer as first chunk and reset the next buffers.  <a href="#a994f01da65b64a13d550ceb6294ce3c1">More...</a><br/></td></tr>
<tr class="separator:a994f01da65b64a13d550ceb6294ce3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e6f23a320712f6fb1a36266b63c064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#ac5e6f23a320712f6fb1a36266b63c064">MsgBuffers_CopyBufferIdx</a> (<a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *destMsgBuffer, <a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *srcMsgBuffers, uint32_t bufferIdx)</td></tr>
<tr class="memdesc:ac5e6f23a320712f6fb1a36266b63c064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy source UA Message buffers content for given indexed buffer into destination UA Message buffer Note: internal properties of the message buffers are also copied (including nbChunks)  <a href="#ac5e6f23a320712f6fb1a36266b63c064">More...</a><br/></td></tr>
<tr class="separator:ac5e6f23a320712f6fb1a36266b63c064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8f64e89c40bbe9ca982da6af3d5881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a3f8f64e89c40bbe9ca982da6af3d5881">MsgBuffers_CopyBuffer</a> (<a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *destMsgBuffer, uint32_t bufferIdx, <a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *srcMsgBuffer, uint32_t limitedLength)</td></tr>
<tr class="memdesc:a3f8f64e89c40bbe9ca982da6af3d5881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy source UA Message buffer content into destination UA Message buffers in buffer corresponding to index.  <a href="#a3f8f64e89c40bbe9ca982da6af3d5881">More...</a><br/></td></tr>
<tr class="separator:a3f8f64e89c40bbe9ca982da6af3d5881"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3be5f6b2dd79834ceccd23adba35d4ef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a3be5f6b2dd79834ceccd23adba35d4ef">SOPC_HEL</a> [3]</td></tr>
<tr class="separator:a3be5f6b2dd79834ceccd23adba35d4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4840cc58274b581aaced4b523a809a51"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a4840cc58274b581aaced4b523a809a51">SOPC_ACK</a> [3]</td></tr>
<tr class="separator:a4840cc58274b581aaced4b523a809a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4eee8bba48ef67f93c70e2cde6d5f3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#aaa4eee8bba48ef67f93c70e2cde6d5f3">SOPC_ERR</a> [3]</td></tr>
<tr class="separator:aaa4eee8bba48ef67f93c70e2cde6d5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9793eb9261bd764d36a134cf795c55c0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a9793eb9261bd764d36a134cf795c55c0">SOPC_MSG</a> [3]</td></tr>
<tr class="separator:a9793eb9261bd764d36a134cf795c55c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfaef815f98e74789ea1cfa9df94958"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a3bfaef815f98e74789ea1cfa9df94958">SOPC_OPN</a> [3]</td></tr>
<tr class="separator:a3bfaef815f98e74789ea1cfa9df94958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c4254e32ba218c68e1db9801c2dd0e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__msg__buffer_8h.html#a95c4254e32ba218c68e1db9801c2dd0e">SOPC_CLO</a> [3]</td></tr>
<tr class="separator:a95c4254e32ba218c68e1db9801c2dd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Binary UA (and TCP UA) message representation with one or several chunks. It is used for TCP UA messages layer and UA secure messages layer (write/read operations are layer dependent). </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a07bb1eb7b745c44ae343626aada6467d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a>  <a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UA Message buffer (with one or several chunks). Note: <a class="el" href="structSOPC__MsgBuffer.html" title="UA Message buffer (with one or several chunks). Note: SOPC_MsgBuffer type must be used to store only ...">SOPC_MsgBuffer</a> type must be used to store only one chunk at same time and SOPC_MsgBuffers type to store several chunks at same time. </p>

</div>
</div>
<a class="anchor" id="a4254971740ef7f40ba501362dfc2a1b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> <a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UA Message buffer with several buffers (to store several chunks) </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a51724ce4413e66370783a3d9b9248024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sopc__msg__buffer_8h.html#a51724ce4413e66370783a3d9b9248024">SOPC_MsgFinalChunk</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UA Message Chunk IsFinal type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a51724ce4413e66370783a3d9b9248024a6b0afea30039b449b5c3cfb452fa9b98"></a>SOPC_Msg_Chunk_Unknown</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a51724ce4413e66370783a3d9b9248024a5e5574c73788cbf8276b9dde87c8e0d9"></a>SOPC_Msg_Chunk_Invalid</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a51724ce4413e66370783a3d9b9248024a10b1f401743303af636bad0252f42adf"></a>SOPC_Msg_Chunk_Intermediate</em>&#160;</td><td class="fielddoc">
<p>C type </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a51724ce4413e66370783a3d9b9248024a680a0ee402d10de473c11aecb3195eb6"></a>SOPC_Msg_Chunk_Final</em>&#160;</td><td class="fielddoc">
<p>F type </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a51724ce4413e66370783a3d9b9248024ad9cdfc4a0a9f82fbe89b8bfbde8e62f2"></a>SOPC_Msg_Chunk_Abort</em>&#160;</td><td class="fielddoc">
<p>A type </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a6195df8ec79297a8b7fd5aa248386271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sopc__msg__buffer_8h.html#a6195df8ec79297a8b7fd5aa248386271">SOPC_SecureMessageType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UA Secure Message types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a6195df8ec79297a8b7fd5aa248386271adfd196cda6cbfb17e360463b7de36e66"></a>SOPC_SecureMessage</em>&#160;</td><td class="fielddoc">
<p>MSG type </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6195df8ec79297a8b7fd5aa248386271a4264f617931afe26e4279ea729fc16c8"></a>SOPC_OpenSecureChannel</em>&#160;</td><td class="fielddoc">
<p>OPN type </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6195df8ec79297a8b7fd5aa248386271a085ebdd354e7acb61c5b358bdb1532e1"></a>SOPC_CloseSecureChannel</em>&#160;</td><td class="fielddoc">
<p>CLO type </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a52655ecfe5c525b5916e06c8551778c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sopc__msg__buffer_8h.html#a52655ecfe5c525b5916e06c8551778c8">TCP_UA_MsgType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCP UA Message types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a52655ecfe5c525b5916e06c8551778c8a415f073424a265ade3e3ac7f12c15518"></a>TCP_UA_Message_Unknown</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a52655ecfe5c525b5916e06c8551778c8a9951dfed78ad2500347e396b41b3be7f"></a>TCP_UA_Message_Invalid</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a52655ecfe5c525b5916e06c8551778c8a8b16c25990568a3f422e269108e2e327"></a>TCP_UA_Message_Hello</em>&#160;</td><td class="fielddoc">
<p>HEL type </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a52655ecfe5c525b5916e06c8551778c8ab42f25a9aa02f3e0daf9e490ac66e77f"></a>TCP_UA_Message_Acknowledge</em>&#160;</td><td class="fielddoc">
<p>ACK type </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a52655ecfe5c525b5916e06c8551778c8a3a529ca74922364cdb0e54ef5f50ab97"></a>TCP_UA_Message_Error</em>&#160;</td><td class="fielddoc">
<p>ERR type </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a52655ecfe5c525b5916e06c8551778c8a226599f25fc104a07e82682bb23edf74"></a>TCP_UA_Message_SecureMessage</em>&#160;</td><td class="fielddoc">
<p>MSG, OPN or CLO types </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa51791c4540bbe61d725b1cc555b083c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a> MsgBuffer_CopyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>destMsgBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>srcMsgBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy source UA Message buffer content into destination one. Note: properties maxChunks, flushData, namespaces and encodeable types are not concerned by the copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destMsgBuffer</td><td>Pointer to destination UA Message buffer </td></tr>
    <tr><td class="paramname">srcMsgBuffer</td><td>Pointer to source UA Message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GOOD if operation succeeded, BAD otherwise (NULL pointers, incompatible types) </dd></dl>

</div>
</div>
<a class="anchor" id="a5073e7d76c8fc7439d8e5e83bbf8e82f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a>* MsgBuffer_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__Buffer.html">SOPC_Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxChunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>flushData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__NamespaceTable.html">SOPC_NamespaceTable</a> *&#160;</td>
          <td class="paramname"><em>nsTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__EncodeableType.html">SOPC_EncodeableType</a> **&#160;</td>
          <td class="paramname"><em>encTypesTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation of an UA Message buffer containing only 1 buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer to attach in the UA Message buffer to store data </td></tr>
    <tr><td class="paramname">maxChunks</td><td>Maximum number of chunks for an UA Message (determined by connection configuration) </td></tr>
    <tr><td class="paramname">flushData</td><td>Data to store that could be used to flush a message chunk (optional) </td></tr>
    <tr><td class="paramname">nsTable</td><td>Namespace table to be used for encoding / decoding UA messages (optional) </td></tr>
    <tr><td class="paramname">encTypesTable</td><td>EncodeableType table to be used for encoding / decoding UA messages (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if buffer creation failed (NULL buffer), allocated UA Message Buffer otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a16506a102439bead60b2c4394a1758da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MsgBuffer_Delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> **&#160;</td>
          <td class="paramname"><em>mBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocation of an UA Message buffer and its contained buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mBuffer</td><td>Address of the UA Message buffer pointer to deallocate. Set to NULL after deallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03fb22a71bddd3f90199c426202c4464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MsgBuffer_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>mBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the UA Message buffer state (buffer content, type, number of chunks, etc.) in order it could be use to receive / send a new UA message. Note: properties maxChunks, flushData, namespaces and encodeable types are not modified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mBuffer</td><td>Pointer to UA Message buffer to reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac501d522ef0b2b2f27f39b71e654641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a> MsgBuffer_ResetNextChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>mBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bodyPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the UA Message buffer state for next chunk reception/sending at the given position (precedent not kept since only 1 buffer available) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mBuffer</td><td>Pointer to UA Message buffer to reset for next chunk </td></tr>
    <tr><td class="paramname">bodyPosition</td><td>Position to which the buffer must be reset. Data before position is kept, data after is erased (0 or SN position to keep the same UA Secure Message header values for sending next chunk) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GOOD if operation succeeded, BAD otherwise (NULL pointer) </dd></dl>

</div>
</div>
<a class="anchor" id="a37ecb443e11e5a6f67212db35b79c023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a> MsgBuffer_SetSecureMsgType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>mBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__msg__buffer_8h.html#a6195df8ec79297a8b7fd5aa248386271">SOPC_SecureMessageType</a>&#160;</td>
          <td class="paramname"><em>sType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Secure Message Type of the UA Message (and coherent TCP UA type) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mBuffer</td><td>Pointer to UA Message buffer </td></tr>
    <tr><td class="paramname">sType</td><td>Secure message type value to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GOOD if operation succeeded, BAD otherwise (NULL pointer, TCP UA type not compatible) </dd></dl>

</div>
</div>
<a class="anchor" id="a3f8f64e89c40bbe9ca982da6af3d5881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a> MsgBuffers_CopyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *&#160;</td>
          <td class="paramname"><em>destMsgBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>srcMsgBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>limitedLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy source UA Message buffer content into destination UA Message buffers in buffer corresponding to index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destMsgBuffer</td><td>Pointer to destination UA Message buffers </td></tr>
    <tr><td class="paramname">bufferIdx</td><td>Index of the buffer to be copied into (&lt; srcMsgBuffer-&gt;nbChunks) </td></tr>
    <tr><td class="paramname">srcMsgBuffer</td><td>Pointer to source UA Message buffer </td></tr>
    <tr><td class="paramname">limitedLength</td><td>Length to be copied from the source buffer (&lt;= srcMsgBuffer-&gt;buffers-&gt;length &amp;&amp; &lt;= destMsgBuffer-&gt;buffers[bufferIdx].max_size) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GOOD if operation succeeded, BAD otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ac5e6f23a320712f6fb1a36266b63c064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a> MsgBuffers_CopyBufferIdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__MsgBuffer.html">SOPC_MsgBuffer</a> *&#160;</td>
          <td class="paramname"><em>destMsgBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *&#160;</td>
          <td class="paramname"><em>srcMsgBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy source UA Message buffers content for given indexed buffer into destination UA Message buffer Note: internal properties of the message buffers are also copied (including nbChunks) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destMsgBuffer</td><td>Pointer to destination UA Message buffer </td></tr>
    <tr><td class="paramname">srcMsgBuffers</td><td>Pointer to source UA Message buffer </td></tr>
    <tr><td class="paramname">bufferIdx</td><td>Index of the buffer to be copied into (&lt; srcMsgBuffers-&gt;nbChunks) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GOOD if operation succeeded, BAD otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a6eb299718224b6ff20fcba57acc23ad3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a>* MsgBuffers_Create </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxChunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>flushData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__NamespaceTable.html">SOPC_NamespaceTable</a> *&#160;</td>
          <td class="paramname"><em>nsTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__EncodeableType.html">SOPC_EncodeableType</a> **&#160;</td>
          <td class="paramname"><em>encTypesTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation of an UA Message buffer with several buffers (to store several chunks) and allocate the buffers Note: nbChunks set to 0 after creation, MsgBuffers_NextChunk must be called before storing data for first chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxChunks</td><td>Maximum number of chunks for an UA Message (determined by connection configuration). </td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size of the buffers to allocate </td></tr>
    <tr><td class="paramname">flushData</td><td>Data to store that could be used to flush a message chunk (optional) </td></tr>
    <tr><td class="paramname">nsTable</td><td>Namespace table to be used for encoding / decoding UA messages (optional) </td></tr>
    <tr><td class="paramname">encTypesTable</td><td>EncodeableType table to be used for encoding / decoding UA messages (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if buffer creation failed (maxChunks == 0, bufferSize == 0, NULL namespaces, NULL encodeable types), allocated UA Message Buffer otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a97fe9800addf1573e84040ebbc1836fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MsgBuffers_Delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> **&#160;</td>
          <td class="paramname"><em>mBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocation of an UA Message buffers and its contained buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mBuffer</td><td>Address of the UA Message buffers pointer to deallocate. Set to NULL after deallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0249a2d13e8b17086c742f26e5c98a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSOPC__Buffer.html">SOPC_Buffer</a>* MsgBuffers_GetCurrentChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *&#160;</td>
          <td class="paramname"><em>mBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current chunk (last received chunk) buffer of UA Message buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mBuffer</td><td>Pointer to the UA Message buffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the current chunk buffer, NULL if argument was NULL or incoherent </dd></dl>

</div>
</div>
<a class="anchor" id="afdb91e812a77da7ab7f1c245a0a16958"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSOPC__Buffer.html">SOPC_Buffer</a>* MsgBuffers_NextChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *&#160;</td>
          <td class="paramname"><em>mBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bufferIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the next (empty) chunk buffer of UA Message buffers as current one and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mBuffer</td><td>Pointer to the UA Message buffers </td></tr>
    <tr><td class="paramname">bufferIdx</td><td>Index of the new current chunk buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the next chunk buffer which became current, NULL if argument was NULL or incoherent </dd></dl>

</div>
</div>
<a class="anchor" id="afd1f0be7a847efc5a290898dddd55324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSOPC__Buffer.html">SOPC_Buffer</a>* MsgBuffers_NextChunkWithHeadersCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *&#160;</td>
          <td class="paramname"><em>mBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bodyPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy content of current chunk until message body position (headers content) into next chunk, then set the next chunk buffer of UA Message buffers as current one and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mBuffers</td><td>Pointer to the UA Message buffers </td></tr>
    <tr><td class="paramname">bodyPosition</td><td>Position of the message body first byte, all headers to copy are included before this position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the next chunk buffer which became current, NULL if argument was NULL or incoherent </dd></dl>

</div>
</div>
<a class="anchor" id="a2cc97a693377c52260fd9c5147904c05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MsgBuffers_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *&#160;</td>
          <td class="paramname"><em>mBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the UA Message buffers state (buffers content, type, number of chunks, etc.) in order it could be use to receive new UA message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mBuffer</td><td>Pointer to UA Message buffers to reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a994f01da65b64a13d550ceb6294ce3c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__base__types_8h.html#ad7c3bb55a15be00fad929191453f54ec">SOPC_StatusCode</a> MsgBuffers_SetCurrentChunkFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__msg__buffer_8h.html#a4254971740ef7f40ba501362dfc2a1b4">SOPC_MsgBuffers</a> *&#160;</td>
          <td class="paramname"><em>mBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current chunk buffer as first chunk and reset the next buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mBuffer</td><td>Pointer to the UA Message buffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GOOD if operation succeeded, BAD otherwise (NULL pointers, nb chunks &lt; 2) </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a4840cc58274b581aaced4b523a809a51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a> SOPC_ACK[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP UA Ack Message type constant </p>

</div>
</div>
<a class="anchor" id="a95c4254e32ba218c68e1db9801c2dd0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a> SOPC_CLO[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UA CloseSecureChannel Message type constant </p>

</div>
</div>
<a class="anchor" id="aaa4eee8bba48ef67f93c70e2cde6d5f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a> SOPC_ERR[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP UA Error Message type constant </p>

</div>
</div>
<a class="anchor" id="a3be5f6b2dd79834ceccd23adba35d4ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a> SOPC_HEL[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP UA Hello Message type constant </p>

</div>
</div>
<a class="anchor" id="a9793eb9261bd764d36a134cf795c55c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a> SOPC_MSG[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UA Secure Message type constant </p>

</div>
</div>
<a class="anchor" id="a3bfaef815f98e74789ea1cfa9df94958"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="sopc__builtintypes_8h.html#a2f1c71d608908427eeb075b88e27c371">SOPC_Byte</a> SOPC_OPN[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UA OpenSecureChannel Message type constant </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 2 2017 18:36:32 for INGOPCS OPCUA stack by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
