<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>S2OPC OPCUA Toolkit: src/Common/helpers/sopc_async_queue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">S2OPC OPCUA Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_ba210d1fa67db7bee1bb22e0a3c11d9f.html">Common</a></li><li class="navelem"><a class="el" href="dir_4c1a1e4ba300949b33e30739e8e49101.html">helpers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sopc_async_queue.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An asynchronous and thread-safe queue implementation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="sopc__enums_8h_source.html">sopc_enums.h</a>&quot;</code><br />
</div>
<p><a href="sopc__async__queue_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aac0f36b8a7e3833011d87c72b578968b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a></td></tr>
<tr class="separator:aac0f36b8a7e3833011d87c72b578968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa9a66b95a6beb373854187576a8ca231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__async__queue_8h.html#aa9a66b95a6beb373854187576a8ca231">SOPC_AsyncQueue_Init</a> (<a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> **queue, const char *queueName)</td></tr>
<tr class="memdesc:aa9a66b95a6beb373854187576a8ca231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the queue, the queue must be freed at the end of it's use with SOPC_AsyncQueue_Free.  <a href="sopc__async__queue_8h.html#aa9a66b95a6beb373854187576a8ca231">More...</a><br /></td></tr>
<tr class="separator:aa9a66b95a6beb373854187576a8ca231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89949f52daa19f22227f97bc24980b33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__async__queue_8h.html#a89949f52daa19f22227f97bc24980b33">SOPC_AsyncQueue_BlockingEnqueue</a> (<a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> *queue, void *element)</td></tr>
<tr class="memdesc:a89949f52daa19f22227f97bc24980b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new element (and allocate new queue element) to the head of the given linked queue. Can be used as FIFO queue with SOPC_AsyncQueue_BlokingDequeue or SOPC_AsyncQueue_NonBlockingDequeue.  <a href="sopc__async__queue_8h.html#a89949f52daa19f22227f97bc24980b33">More...</a><br /></td></tr>
<tr class="separator:a89949f52daa19f22227f97bc24980b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19a12b0e546089c8db5039a9c795bfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__async__queue_8h.html#aa19a12b0e546089c8db5039a9c795bfa">SOPC_AsyncQueue_BlockingEnqueueFirstOut</a> (<a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> *queue, void *element)</td></tr>
<tr class="memdesc:aa19a12b0e546089c8db5039a9c795bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new element (and allocate new queue element) to the tail of the given linked queue. Can be used as LIFO queue with SOPC_AsyncQueue_BlokingDequeue or SOPC_AsyncQueue_NonBlockingDequeue.  <a href="sopc__async__queue_8h.html#aa19a12b0e546089c8db5039a9c795bfa">More...</a><br /></td></tr>
<tr class="separator:aa19a12b0e546089c8db5039a9c795bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409c154a5e7f543e2eaccac93775bf30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__async__queue_8h.html#a409c154a5e7f543e2eaccac93775bf30">SOPC_AsyncQueue_BlockingDequeue</a> (<a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> *queue, void **element)</td></tr>
<tr class="memdesc:a409c154a5e7f543e2eaccac93775bf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get and remove the head element of the queue. If the queue is empty the function will block until an element is added in the queue.  <a href="sopc__async__queue_8h.html#a409c154a5e7f543e2eaccac93775bf30">More...</a><br /></td></tr>
<tr class="separator:a409c154a5e7f543e2eaccac93775bf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fdafb18a37898487a191449567b218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__async__queue_8h.html#a93fdafb18a37898487a191449567b218">SOPC_AsyncQueue_NonBlockingDequeue</a> (<a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> *queue, void **element)</td></tr>
<tr class="memdesc:a93fdafb18a37898487a191449567b218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get and remove the head element of the queue. If the queue is empty the function will block until an element is added in the queue. Element must be freed after used.  <a href="sopc__async__queue_8h.html#a93fdafb18a37898487a191449567b218">More...</a><br /></td></tr>
<tr class="separator:a93fdafb18a37898487a191449567b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9c43a249eabc6d79585b593f6134f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__async__queue_8h.html#a8d9c43a249eabc6d79585b593f6134f5">SOPC_AsyncQueue_Free</a> (<a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> **queue)</td></tr>
<tr class="memdesc:a8d9c43a249eabc6d79585b593f6134f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">: clear the queue by freeing every present element and free the asynchronous queue  <a href="sopc__async__queue_8h.html#a8d9c43a249eabc6d79585b593f6134f5">More...</a><br /></td></tr>
<tr class="separator:a8d9c43a249eabc6d79585b593f6134f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An asynchronous and thread-safe queue implementation. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aac0f36b8a7e3833011d87c72b578968b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0f36b8a7e3833011d87c72b578968b">&#9670;&nbsp;</a></span>SOPC_AsyncQueue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> <a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa9a66b95a6beb373854187576a8ca231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a66b95a6beb373854187576a8ca231">&#9670;&nbsp;</a></span>SOPC_AsyncQueue_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_AsyncQueue_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> **&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>queueName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the queue, the queue must be freed at the end of it's use with SOPC_AsyncQueue_Free. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer on the address of the queue </td></tr>
    <tr><td class="paramname">queueName</td><td>Pointer on a string, useful to debug</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK if the queue is successfully initialized. SOPC_STATUS_OK or SOPC_STATUS_INVALID_PARAMETERS otherwise </dd></dl>

</div>
</div>
<a id="a89949f52daa19f22227f97bc24980b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89949f52daa19f22227f97bc24980b33">&#9670;&nbsp;</a></span>SOPC_AsyncQueue_BlockingEnqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_AsyncQueue_BlockingEnqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new element (and allocate new queue element) to the head of the given linked queue. Can be used as FIFO queue with SOPC_AsyncQueue_BlokingDequeue or SOPC_AsyncQueue_NonBlockingDequeue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer on the linked queue in which new element must be added </td></tr>
    <tr><td class="paramname">element</td><td>Pointer to the element to append, must be dynamically created by user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_ReturnStatus value, if the element is successfully added SOPC_STATUS_OK, otherwise if queue or element is NULL SOPC_STATUS_INVALID_PARAMETERS, and SOPC_STATUS_NOK in others failed cases </dd></dl>

</div>
</div>
<a id="aa19a12b0e546089c8db5039a9c795bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19a12b0e546089c8db5039a9c795bfa">&#9670;&nbsp;</a></span>SOPC_AsyncQueue_BlockingEnqueueFirstOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_AsyncQueue_BlockingEnqueueFirstOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new element (and allocate new queue element) to the tail of the given linked queue. Can be used as LIFO queue with SOPC_AsyncQueue_BlokingDequeue or SOPC_AsyncQueue_NonBlockingDequeue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer on the linked queue in which new element must be added </td></tr>
    <tr><td class="paramname">element</td><td>Pointer to the element to append, must be dynamically created by user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_ReturnStatus value, if the element is successfully added SOPC_STATUS_OK, otherwise if queue or element is NULL SOPC_STATUS_INVALID_PARAMETERS, and SOPC_STATUS_NOK in others failed cases </dd></dl>

</div>
</div>
<a id="a409c154a5e7f543e2eaccac93775bf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409c154a5e7f543e2eaccac93775bf30">&#9670;&nbsp;</a></span>SOPC_AsyncQueue_BlockingDequeue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_AsyncQueue_BlockingDequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get and remove the head element of the queue. If the queue is empty the function will block until an element is added in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer on the linked queue in which the element will be removed </td></tr>
    <tr><td class="paramname">element</td><td>Pointer to the address of the element to remove. element can be freed by caller after use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_ReturnStatus value, if the element is successfully removed SOPC_STATUS_OK, if queue or element is NULL SOPC_STATUS_INVALID_PARAMETERS </dd></dl>

</div>
</div>
<a id="a93fdafb18a37898487a191449567b218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fdafb18a37898487a191449567b218">&#9670;&nbsp;</a></span>SOPC_AsyncQueue_NonBlockingDequeue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_AsyncQueue_NonBlockingDequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get and remove the head element of the queue. If the queue is empty the function will block until an element is added in the queue. Element must be freed after used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer on the linked queue in which the element will be removed </td></tr>
    <tr><td class="paramname">element</td><td>Pointer to the addres of the element to remove, element can be freed by caller after use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_ReturnStatus value, if the element is successfully removed SOPC_STATUS_OK, if queue or element is NULL SOPC_STATUS_INVALID_PARAMETERS, if no element in the queue SOPC_STATUS_WOULD_BLOCK </dd></dl>

</div>
</div>
<a id="a8d9c43a249eabc6d79585b593f6134f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9c43a249eabc6d79585b593f6134f5">&#9670;&nbsp;</a></span>SOPC_AsyncQueue_Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SOPC_AsyncQueue_Free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__async__queue_8h.html#aac0f36b8a7e3833011d87c72b578968b">SOPC_AsyncQueue</a> **&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: clear the queue by freeing every present element and free the asynchronous queue </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 17 2023 17:32:13 for S2OPC OPCUA Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
