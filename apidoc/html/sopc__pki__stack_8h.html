<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>S2OPC OPCUA Toolkit: src/Common/crypto/sopc_pki_stack.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">S2OPC OPCUA Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_ba210d1fa67db7bee1bb22e0a3c11d9f.html">Common</a></li><li class="navelem"><a class="el" href="dir_c25c91c352277bc0358fb0cbf526f48d.html">crypto</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sopc_pki_stack.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Defines the minimal PKI implementation provided by the stack.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="sopc__pki__stack__lib__itf_8h_source.html">sopc_pki_stack_lib_itf.h</a>&quot;</code><br />
</div>
<p><a href="sopc__pki__stack_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aff92dc83864bfc1b6bc1dad1a70ccf7c" id="r_aff92dc83864bfc1b6bc1dad1a70ccf7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#aff92dc83864bfc1b6bc1dad1a70ccf7c">SOPC_PKIProvider_CreateFromStore</a> (const char *directoryStorePath, <a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> **ppPKI)</td></tr>
<tr class="memdesc:aff92dc83864bfc1b6bc1dad1a70ccf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the PKIProvider from a directory where certificates are stored.  <br /></td></tr>
<tr class="separator:aff92dc83864bfc1b6bc1dad1a70ccf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7bb409d694607e31968ab7de568355" id="r_a7d7bb409d694607e31968ab7de568355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a7d7bb409d694607e31968ab7de568355">SOPC_PKIProvider_CreateFromList</a> (<a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *pTrustedCerts, <a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> *pTrustedCrl, <a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *pIssuerCerts, <a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> *pIssuerCrl, <a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> **ppPKI)</td></tr>
<tr class="memdesc:a7d7bb409d694607e31968ab7de568355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the PKIProvider from list representation.  <br /></td></tr>
<tr class="separator:a7d7bb409d694607e31968ab7de568355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac259852e29b1ea90e52ef4e77023344b" id="r_ac259852e29b1ea90e52ef4e77023344b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#ac259852e29b1ea90e52ef4e77023344b">SOPC_PKIProvider_CreateLeafProfile</a> (const char *securityPolicyUri, <a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> **ppProfile)</td></tr>
<tr class="memdesc:ac259852e29b1ea90e52ef4e77023344b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a leaf certificate profile from security policy to check certificate properties.  <br /></td></tr>
<tr class="separator:ac259852e29b1ea90e52ef4e77023344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a3db39c3de36fcf42c542c7faa3bea" id="r_a55a3db39c3de36fcf42c542c7faa3bea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a55a3db39c3de36fcf42c542c7faa3bea">SOPC_PKIProvider_LeafProfileSetURI</a> (<a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> *pProfile, const char *applicationUri)</td></tr>
<tr class="memdesc:a55a3db39c3de36fcf42c542c7faa3bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the application URI to the leaf profile.  <br /></td></tr>
<tr class="separator:a55a3db39c3de36fcf42c542c7faa3bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adca9c4b0247e9c7654d941948fa6ea" id="r_a6adca9c4b0247e9c7654d941948fa6ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a6adca9c4b0247e9c7654d941948fa6ea">SOPC_PKIProvider_LeafProfileSetURL</a> (<a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> *pProfile, const char *url)</td></tr>
<tr class="memdesc:a6adca9c4b0247e9c7654d941948fa6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the endpoint URL used for connection to the leaf profile.  <br /></td></tr>
<tr class="separator:a6adca9c4b0247e9c7654d941948fa6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f61dbfe07903140976be5362f291c91" id="r_a3f61dbfe07903140976be5362f291c91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a3f61dbfe07903140976be5362f291c91">SOPC_PKIProvider_LeafProfileSetUsageFromType</a> (<a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> *pProfile, <a class="el" href="sopc__pki__decl_8h.html#ae5ccc504dddfd034f68bb8dfb0c545ef">SOPC_PKI_Type</a> PKIType)</td></tr>
<tr class="memdesc:a3f61dbfe07903140976be5362f291c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the keyUsage and extendedKeyUsage to the leaf profile from the PKI type.  <br /></td></tr>
<tr class="separator:a3f61dbfe07903140976be5362f291c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c578c607529cb2912e9676053217c4" id="r_a53c578c607529cb2912e9676053217c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a53c578c607529cb2912e9676053217c4">SOPC_PKIProvider_CheckLeafCertificate</a> (const <a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *pToValidate, const <a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> *pProfile, uint32_t *error, <a class="el" href="structSOPC__PKI__Cert__Failure__Context.html">SOPC_PKI_Cert_Failure_Context</a> *context)</td></tr>
<tr class="memdesc:a53c578c607529cb2912e9676053217c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check leaf certificate properties.  <br /></td></tr>
<tr class="separator:a53c578c607529cb2912e9676053217c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffb5b2413f0bb3e86ff2cf3b872da6b" id="r_afffb5b2413f0bb3e86ff2cf3b872da6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#afffb5b2413f0bb3e86ff2cf3b872da6b">SOPC_PKIProvider_DeleteLeafProfile</a> (<a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> **ppProfile)</td></tr>
<tr class="memdesc:afffb5b2413f0bb3e86ff2cf3b872da6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a leaf profile.  <br /></td></tr>
<tr class="separator:afffb5b2413f0bb3e86ff2cf3b872da6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1423be6f4324900063ae5a43d585f5b" id="r_ac1423be6f4324900063ae5a43d585f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#ac1423be6f4324900063ae5a43d585f5b">SOPC_PKIProvider_CreateProfile</a> (const char *securityPolicyUri, <a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> **ppProfile)</td></tr>
<tr class="memdesc:ac1423be6f4324900063ae5a43d585f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PKI profile for a validation process. Backward interoperability is enabled. Leaf profile and chain profile are created according the security policy. KeyUsage, extendedKeyUsage, URI and HostName of subjectAltName are not configured here then these properties have to be defined manually or though specific functions eg <a class="el" href="sopc__pki__stack_8h.html#ac1932cfab3b0c67ea349e3db790d0d47" title="Set the properties to the PKI profile from the PKI type.">SOPC_PKIProvider_ProfileSetUsageFromType</a> , <a class="el" href="sopc__pki__stack_8h.html#a3a8c70f1b3af6859b3f98e3671c217ec" title="Set the application URI to the PKI profile.">SOPC_PKIProvider_ProfileSetURI</a> and <a class="el" href="sopc__pki__stack_8h.html#a7ffbcb0cdc43b5340efcf755fc1fdbe4" title="Set the endpoint URL used for connection to the PKI profile.">SOPC_PKIProvider_ProfileSetURL</a>.  <br /></td></tr>
<tr class="separator:ac1423be6f4324900063ae5a43d585f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad14091abf498a225078a906e782b4a" id="r_adad14091abf498a225078a906e782b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#adad14091abf498a225078a906e782b4a">SOPC_PKIProvider_CreateMinimalUserProfile</a> (<a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> **ppProfile)</td></tr>
<tr class="memdesc:adad14091abf498a225078a906e782b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a minimal PKI profile for user validation process.  <br /></td></tr>
<tr class="separator:adad14091abf498a225078a906e782b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1932cfab3b0c67ea349e3db790d0d47" id="r_ac1932cfab3b0c67ea349e3db790d0d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#ac1932cfab3b0c67ea349e3db790d0d47">SOPC_PKIProvider_ProfileSetUsageFromType</a> (<a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> *pProfile, <a class="el" href="sopc__pki__decl_8h.html#ae5ccc504dddfd034f68bb8dfb0c545ef">SOPC_PKI_Type</a> PKIType)</td></tr>
<tr class="memdesc:ac1932cfab3b0c67ea349e3db790d0d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the properties to the PKI profile from the PKI type.  <br /></td></tr>
<tr class="separator:ac1932cfab3b0c67ea349e3db790d0d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8c70f1b3af6859b3f98e3671c217ec" id="r_a3a8c70f1b3af6859b3f98e3671c217ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a3a8c70f1b3af6859b3f98e3671c217ec">SOPC_PKIProvider_ProfileSetURI</a> (<a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> *pProfile, const char *applicationUri)</td></tr>
<tr class="memdesc:a3a8c70f1b3af6859b3f98e3671c217ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the application URI to the PKI profile.  <br /></td></tr>
<tr class="separator:a3a8c70f1b3af6859b3f98e3671c217ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffbcb0cdc43b5340efcf755fc1fdbe4" id="r_a7ffbcb0cdc43b5340efcf755fc1fdbe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a7ffbcb0cdc43b5340efcf755fc1fdbe4">SOPC_PKIProvider_ProfileSetURL</a> (<a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> *pProfile, const char *url)</td></tr>
<tr class="memdesc:a7ffbcb0cdc43b5340efcf755fc1fdbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the endpoint URL used for connection to the PKI profile.  <br /></td></tr>
<tr class="separator:a7ffbcb0cdc43b5340efcf755fc1fdbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f76d4feea813702e84ffa5a550da3e" id="r_a78f76d4feea813702e84ffa5a550da3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a78f76d4feea813702e84ffa5a550da3e">SOPC_PKIProvider_DeleteProfile</a> (<a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> **ppProfile)</td></tr>
<tr class="memdesc:a78f76d4feea813702e84ffa5a550da3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a PKI profile.  <br /></td></tr>
<tr class="separator:a78f76d4feea813702e84ffa5a550da3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa312daf1781ba7c9bdd39774e808c20" id="r_aaa312daf1781ba7c9bdd39774e808c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#aaa312daf1781ba7c9bdd39774e808c20">SOPC_PKIProvider_SetStorePath</a> (const char *directoryStorePath, <a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *pPKI)</td></tr>
<tr class="memdesc:aaa312daf1781ba7c9bdd39774e808c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redefines the directory store where the certificates will be stored with <a class="el" href="sopc__pki__stack_8h.html#a92fc93e179f91885bb26b6ef154426df" title="Write the certificate files in the updatedTrustList folder of the PKI storage. The updatedTrustList f...">SOPC_PKIProvider_WriteToStore</a>.  <br /></td></tr>
<tr class="separator:aaa312daf1781ba7c9bdd39774e808c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401854a0b46dc631db6f6810264a0f61" id="r_a401854a0b46dc631db6f6810264a0f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a401854a0b46dc631db6f6810264a0f61">SOPC_PKIProvider_ValidateCertificate</a> (<a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *pPKI, const <a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *pToValidate, const <a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> *pProfile, uint32_t *error, <a class="el" href="structSOPC__PKI__Cert__Failure__Context.html">SOPC_PKI_Cert_Failure_Context</a> *context)</td></tr>
<tr class="memdesc:a401854a0b46dc631db6f6810264a0f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validation function for a certificate with the PKI chain.  <br /></td></tr>
<tr class="separator:a401854a0b46dc631db6f6810264a0f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fc93e179f91885bb26b6ef154426df" id="r_a92fc93e179f91885bb26b6ef154426df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a92fc93e179f91885bb26b6ef154426df">SOPC_PKIProvider_WriteToStore</a> (<a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *pPKI, const bool bEraseExistingFiles)</td></tr>
<tr class="memdesc:a92fc93e179f91885bb26b6ef154426df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the certificate files in the updatedTrustList folder of the PKI storage. The updatedTrustList folder is created if it is missing. The format of the written files is DER. The updatedTrustList folder is organized as follows:  <br /></td></tr>
<tr class="separator:a92fc93e179f91885bb26b6ef154426df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd7fc75f1053ae8b7f678c2656fc6b5" id="r_a0cd7fc75f1053ae8b7f678c2656fc6b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a0cd7fc75f1053ae8b7f678c2656fc6b5">SOPC_PKIProvider_WriteOrAppendToList</a> (<a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *pPKI, <a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> **ppTrustedCerts, <a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> **ppTrustedCrl, <a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> **ppIssuerCerts, <a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> **ppIssuerCrl)</td></tr>
<tr class="memdesc:a0cd7fc75f1053ae8b7f678c2656fc6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts certificates from the PKI object.  <br /></td></tr>
<tr class="separator:a0cd7fc75f1053ae8b7f678c2656fc6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c96f4450afe48f620d8cf23f6025c44" id="r_a1c96f4450afe48f620d8cf23f6025c44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a1c96f4450afe48f620d8cf23f6025c44">SOPC_PKIProvider_WriteRejectedCertToStore</a> (<a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *pPKI)</td></tr>
<tr class="memdesc:a1c96f4450afe48f620d8cf23f6025c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the rejected certificates files in the rejected folder of the PKI storage. The format of the written files is DER.  <br /></td></tr>
<tr class="separator:a1c96f4450afe48f620d8cf23f6025c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1232b1dff72a0e014cb9cdc49477a9e6" id="r_a1232b1dff72a0e014cb9cdc49477a9e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a1232b1dff72a0e014cb9cdc49477a9e6">SOPC_PKIProvider_CopyRejectedList</a> (<a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *pPKI, <a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> **ppCert)</td></tr>
<tr class="memdesc:a1232b1dff72a0e014cb9cdc49477a9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the list of certificate that have been rejected.  <br /></td></tr>
<tr class="separator:a1232b1dff72a0e014cb9cdc49477a9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2049e9104d3dd9eaa4847374dcea4c4f" id="r_a2049e9104d3dd9eaa4847374dcea4c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a2049e9104d3dd9eaa4847374dcea4c4f">SOPC_PKIProvider_UpdateFromList</a> (<a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *pPKI, const char *securityPolicyUri, <a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *pTrustedCerts, <a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> *pTrustedCrl, <a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *pIssuerCerts, <a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> *pIssuerCrl, const bool bIncludeExistingList)</td></tr>
<tr class="memdesc:a2049e9104d3dd9eaa4847374dcea4c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the PKI with new lists of certificates and CRL.  <br /></td></tr>
<tr class="separator:a2049e9104d3dd9eaa4847374dcea4c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac150b11f004b3f677a25a7c7be4c0995" id="r_ac150b11f004b3f677a25a7c7be4c0995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#ac150b11f004b3f677a25a7c7be4c0995">SOPC_PKIProvider_RemoveCertificate</a> (<a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *pPKI, const char *pThumbprint, const bool bIsTrusted, bool *pIsRemoved, bool *pIsIssuer)</td></tr>
<tr class="memdesc:ac150b11f004b3f677a25a7c7be4c0995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the certificates matching with the given thumbprint. If the Certificate is a CA Certificate then all the CRLs for that CA are removed.  <br /></td></tr>
<tr class="separator:ac150b11f004b3f677a25a7c7be4c0995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d64367293c474d45d5ec46a8cb5c328" id="r_a4d64367293c474d45d5ec46a8cb5c328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a4d64367293c474d45d5ec46a8cb5c328">SOPC_PKIPermissive_Create</a> (<a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> **ppPKI)</td></tr>
<tr class="memdesc:a4d64367293c474d45d5ec46a8cb5c328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a PKI Provider without security.  <br /></td></tr>
<tr class="separator:a4d64367293c474d45d5ec46a8cb5c328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81980a08e99fe2ea4068fd1112290332" id="r_a81980a08e99fe2ea4068fd1112290332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a81980a08e99fe2ea4068fd1112290332">SOPC_PKIProvider_SetUpdateCb</a> (<a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *pPKI, <a class="el" href="sopc__pki__decl_8h.html#afc0e55b8483986bd5133212e75b5ee1e">SOPC_PKIProviderUpdateCb</a> *pUpdateCb, uintptr_t updateParam)</td></tr>
<tr class="memdesc:a81980a08e99fe2ea4068fd1112290332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the callback to be called when a PKI certificates update is done with <a class="el" href="sopc__pki__stack_8h.html#a2049e9104d3dd9eaa4847374dcea4c4f" title="Update the PKI with new lists of certificates and CRL.">SOPC_PKIProvider_UpdateFromList</a> or <a class="el" href="sopc__pki__stack_8h.html#ac150b11f004b3f677a25a7c7be4c0995" title="Remove all the certificates matching with the given thumbprint. If the Certificate is a CA Certificat...">SOPC_PKIProvider_RemoveCertificate</a>.  <br /></td></tr>
<tr class="separator:a81980a08e99fe2ea4068fd1112290332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d532205ec7e1de3183d1f9baf3d8029" id="r_a4d532205ec7e1de3183d1f9baf3d8029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__pki__stack_8h.html#a4d532205ec7e1de3183d1f9baf3d8029">SOPC_PKIProvider_Free</a> (<a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> **ppPKI)</td></tr>
<tr class="memdesc:a4d532205ec7e1de3183d1f9baf3d8029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees allocated PKIs.  <br /></td></tr>
<tr class="separator:a4d532205ec7e1de3183d1f9baf3d8029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines the minimal PKI implementation provided by the stack. </p>
<p>The stack will not to provide a full-blown configurable PKI. The stack provides only a minimal, always safe validating PKI. The stack provides a thread-safe PKI, it is necessary for OPC UA client use case (shared between services and secure channel layers) and PKI trust list update feature (shared between S2OPC library layers and possibly application thread).</p>
<p>See <a class="el" href="sopc__pki__stack__lib__itf_8h.html" title="Defines the cryptographic abstraction interface for the minimal PKI implementation provided by the st...">sopc_pki_stack_lib_itf.h</a> for API. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aff92dc83864bfc1b6bc1dad1a70ccf7c" name="aff92dc83864bfc1b6bc1dad1a70ccf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff92dc83864bfc1b6bc1dad1a70ccf7c">&#9670;&#160;</a></span>SOPC_PKIProvider_CreateFromStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_CreateFromStore </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>directoryStorePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> **&#160;</td>
          <td class="paramname"><em>ppPKI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the PKIProvider from a directory where certificates are stored. </p>
<p>The directory store shall be organized as follows:</p>
<ul>
<li>&lt;Directory_store_name&gt;/trusted/certs (.DER or .PEM files)</li>
<li>&lt;Directory_store_name&gt;/trusted/crl (.DER or .PEM files)</li>
<li>&lt;Directory_store_name&gt;/issuers/certs (.DER or .PEM files)</li>
<li>&lt;Directory_store_name&gt;/issuers/crl (.DER or .PEM files</li>
</ul>
<p>Optional updated trust list directory (for runtime update persistence) :</p>
<ul>
<li>&lt;Directory_store_name&gt;/updatedTrustList/trusted/certs (.DER or .PEM files)</li>
<li>&lt;Directory_store_name&gt;/updatedTrustList/trusted/crl (.DER or .PEM files)</li>
<li>&lt;Directory_store_name&gt;/updatedTrustList/issuers/certs (.DER or .PEM files)</li>
<li>&lt;Directory_store_name&gt;/updatedTrustList/issuers/crl (.DER or .PEM files)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>: file extension names are not checked and all files are considered valid certificates or CRL except for file names starting with a '.' in order to allow placeholders for empty directories.</dd></dl>
<p>The function attempts to build the PKI from the updatedTrustList directory and in case of error (missing, empty or malformed), it switches to the root trusted and issuers directories.</p>
<p>Notions :</p><ul>
<li>CA is a root CA if it is self-signed.</li>
<li>trusted/certs = trusted root CA + trusted link CA + trusted cert.</li>
<li>trusted/crl = CRLs of the trusted root CA + trusted link CA.</li>
<li>issuer/certs = untrusted root CA + untrusted link CA.</li>
<li>issuer/crl = CRLs of the untrusted root CA + untrusted link CA.</li>
<li>CAs from trusted/certs and issuers/certs allow to verify the signing chain of a cert which is included into trusted/certs.</li>
<li>CAs from trusted/certs allow to verify the signing chain of a cert which is not included into trusted/certs.</li>
</ul>
<p>This function checks that :</p><ul>
<li>the number of certificates plus CRLs does not exceed <code>SOPC_PKI_MAX_NB_CERT_AND_CRL</code> .</li>
<li>the certificate store is not empty.</li>
<li>at least one trusted certificate is provided.</li>
<li>each certificate from subfolder issuer/certs is CA.</li>
<li>each CA has exactly one Certificate Revocation List (CRL).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Content of the PKI is NULL when return value is not SOPC_STATUS_OK.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">directoryStorePath</td><td>The directory path where certificates are stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppPKI</td><td>A valid pointer to the newly created PKIProvider. You should free such provider with <a class="el" href="sopc__pki__stack_8h.html#a4d532205ec7e1de3183d1f9baf3d8029" title="Frees allocated PKIs.">SOPC_PKIProvider_Free()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful, SOPC_STATUS_INVALID_PARAMETERS when parameters are NULL, and SOPC_STATUS_NOK when there was an error. </dd></dl>

</div>
</div>
<a id="a7d7bb409d694607e31968ab7de568355" name="a7d7bb409d694607e31968ab7de568355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7bb409d694607e31968ab7de568355">&#9670;&#160;</a></span>SOPC_PKIProvider_CreateFromList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_CreateFromList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *&#160;</td>
          <td class="paramname"><em>pTrustedCerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> *&#160;</td>
          <td class="paramname"><em>pTrustedCrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *&#160;</td>
          <td class="paramname"><em>pIssuerCerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> *&#160;</td>
          <td class="paramname"><em>pIssuerCrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> **&#160;</td>
          <td class="paramname"><em>ppPKI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the PKIProvider from list representation. </p>
<p>Notions :</p><ul>
<li>CA is a root CA if it is self-signed.</li>
<li><code>pTrustedCerts</code> = trusted root CA + trusted link CA + trusted cert.</li>
<li><code>pTrustedCrl</code> = CRLs of the trusted root CA + trusted link CA.</li>
<li><code>pIssuerCerts</code> = untrusted root CA + untrusted link CA.</li>
<li><code>pIssuerCrl</code> = CRLs of the untrusted root CA + untrusted link CA.</li>
<li>CAs from trusted/certs and issuers/certs allow to verify the signing chain of a cert which is included into trusted/certs.</li>
<li>CAs from trusted/certs allow to verify the signing chain of a cert which is not included into trusted/certs.</li>
</ul>
<p>This function checks that :</p><ul>
<li>the number of certificates plus CRLs does not exceed <code>SOPC_PKI_MAX_NB_CERT_AND_CRL</code> .</li>
<li>at least one cert from <code>pTrustedCerts</code> is provided.</li>
<li>each certificate from <code>pIssuerCerts</code> is CA.</li>
<li>each CA has exactly one Certificate Revocation List (CRL).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pTrustedCerts</td><td>A valid pointer to the trusted certificate list. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pTrustedCrl</td><td>A valid pointer to the trusted CRL list. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pIssuerCerts</td><td>A valid pointer to the issuer certificate list. NULL if not used. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pIssuerCrl</td><td>A valid pointer to the issuer CRL list. NULL if not used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppPKI</td><td>A valid pointer to the newly created PKIProvider. You should free such provider with <a class="el" href="sopc__pki__stack_8h.html#a4d532205ec7e1de3183d1f9baf3d8029" title="Frees allocated PKIs.">SOPC_PKIProvider_Free()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful, SOPC_STATUS_INVALID_PARAMETERS when parameters are NULL, and SOPC_STATUS_NOK when there was an error. </dd></dl>

</div>
</div>
<a id="ac259852e29b1ea90e52ef4e77023344b" name="ac259852e29b1ea90e52ef4e77023344b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac259852e29b1ea90e52ef4e77023344b">&#9670;&#160;</a></span>SOPC_PKIProvider_CreateLeafProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_CreateLeafProfile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>securityPolicyUri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> **&#160;</td>
          <td class="paramname"><em>ppProfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a leaf certificate profile from security policy to check certificate properties. </p>
<pre class="fragment">   KeyUsage, extendedKeyUsage, URI and HostName of subjectAltName are not configured here then
   these properties have to be defined manually or though specific functions eg
   ::SOPC_PKIProvider_LeafProfileSetUsageFromType , ::SOPC_PKIProvider_LeafProfileSetURI
   and ::SOPC_PKIProvider_LeafProfileSetURL
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">securityPolicyUri</td><td>The URI describing the security policy. If NULL then an empty profile is created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppProfile</td><td>The newly created leaf profile. You should delete it with <a class="el" href="sopc__pki__stack_8h.html#afffb5b2413f0bb3e86ff2cf3b872da6b" title="Delete a leaf profile.">SOPC_PKIProvider_DeleteLeafProfile</a> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the profile is empty ( <code>securityPolicyUri</code> is NULL) then the functions that use this profile will not run any checks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a55a3db39c3de36fcf42c542c7faa3bea" name="a55a3db39c3de36fcf42c542c7faa3bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a3db39c3de36fcf42c542c7faa3bea">&#9670;&#160;</a></span>SOPC_PKIProvider_LeafProfileSetURI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_LeafProfileSetURI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> *&#160;</td>
          <td class="paramname"><em>pProfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>applicationUri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the application URI to the leaf profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pProfile</td><td>A valid pointer to the leaf profile. </td></tr>
    <tr><td class="paramname">applicationUri</td><td>The application URI to set in <code>pProfile</code> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the application URI is already defined in <code>pProfile</code>, you can not define it again.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a6adca9c4b0247e9c7654d941948fa6ea" name="a6adca9c4b0247e9c7654d941948fa6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6adca9c4b0247e9c7654d941948fa6ea">&#9670;&#160;</a></span>SOPC_PKIProvider_LeafProfileSetURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_LeafProfileSetURL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> *&#160;</td>
          <td class="paramname"><em>pProfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the endpoint URL used for connection to the leaf profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pProfile</td><td>A valid pointer to the leaf profile. </td></tr>
    <tr><td class="paramname">url</td><td>The endpoint URL used for connection to set in <code>pProfile</code> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the URL is already defined in <code>pProfile</code> , you can not define it again.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a3f61dbfe07903140976be5362f291c91" name="a3f61dbfe07903140976be5362f291c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f61dbfe07903140976be5362f291c91">&#9670;&#160;</a></span>SOPC_PKIProvider_LeafProfileSetUsageFromType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_LeafProfileSetUsageFromType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> *&#160;</td>
          <td class="paramname"><em>pProfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__pki__decl_8h.html#ae5ccc504dddfd034f68bb8dfb0c545ef">SOPC_PKI_Type</a>&#160;</td>
          <td class="paramname"><em>PKIType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the keyUsage and extendedKeyUsage to the leaf profile from the PKI type. </p>
<pre class="fragment">   For users : the keyUsage is expected to be filled with digitalSignature and the extendedKeyUsage is not
   checked.
   For clients : the keyUsage is expected to be filled with digitalSignature, nonRepudiation, keyEncipherment
   and dataEncipherment. The extendedKeyUsage is filled with serverAuth.
   For server : the keyUsage is expected to be filled with digitalSignature, nonRepudiation, keyEncipherment
   and dataEncipherment. The extendedKeyUsage is filled with clientAuth.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pProfile</td><td>A valid pointer to the leaf profile. </td></tr>
    <tr><td class="paramname">PKIType</td><td>Defines the type of PKI (user, client or server)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a53c578c607529cb2912e9676053217c4" name="a53c578c607529cb2912e9676053217c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c578c607529cb2912e9676053217c4">&#9670;&#160;</a></span>SOPC_PKIProvider_CheckLeafCertificate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_CheckLeafCertificate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *&#160;</td>
          <td class="paramname"><em>pToValidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> *&#160;</td>
          <td class="paramname"><em>pProfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__Cert__Failure__Context.html">SOPC_PKI_Cert_Failure_Context</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check leaf certificate properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pToValidate</td><td>A valid pointer to the Certificate to validate. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pProfile</td><td>A valid pointer to the leaf profile. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>Pointer to store the OpcUa error code when certificate validation failed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>Optional pointer to store some additional context when certificate validation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>error</code> is only set if returned status is different from SOPC_STATUS_OK.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when the certificate properties are successfully validated, and SOPC_STATUS_INVALID_PARAMETERS, SOPC_STATUS_INVALID_STATE or SOPC_STATUS_NOK. </dd></dl>

</div>
</div>
<a id="afffb5b2413f0bb3e86ff2cf3b872da6b" name="afffb5b2413f0bb3e86ff2cf3b872da6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffb5b2413f0bb3e86ff2cf3b872da6b">&#9670;&#160;</a></span>SOPC_PKIProvider_DeleteLeafProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SOPC_PKIProvider_DeleteLeafProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__LeafProfile.html">SOPC_PKI_LeafProfile</a> **&#160;</td>
          <td class="paramname"><em>ppProfile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a leaf profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppProfile</td><td>The leaf profile. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1423be6f4324900063ae5a43d585f5b" name="ac1423be6f4324900063ae5a43d585f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1423be6f4324900063ae5a43d585f5b">&#9670;&#160;</a></span>SOPC_PKIProvider_CreateProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_CreateProfile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>securityPolicyUri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> **&#160;</td>
          <td class="paramname"><em>ppProfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PKI profile for a validation process. Backward interoperability is enabled. Leaf profile and chain profile are created according the security policy. KeyUsage, extendedKeyUsage, URI and HostName of subjectAltName are not configured here then these properties have to be defined manually or though specific functions eg <a class="el" href="sopc__pki__stack_8h.html#ac1932cfab3b0c67ea349e3db790d0d47" title="Set the properties to the PKI profile from the PKI type.">SOPC_PKIProvider_ProfileSetUsageFromType</a> , <a class="el" href="sopc__pki__stack_8h.html#a3a8c70f1b3af6859b3f98e3671c217ec" title="Set the application URI to the PKI profile.">SOPC_PKIProvider_ProfileSetURI</a> and <a class="el" href="sopc__pki__stack_8h.html#a7ffbcb0cdc43b5340efcf755fc1fdbe4" title="Set the endpoint URL used for connection to the PKI profile.">SOPC_PKIProvider_ProfileSetURL</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">securityPolicyUri</td><td>The URI describing the security policy. Shall not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppProfile</td><td>The newly created profile. You should delete it with <a class="el" href="sopc__pki__stack_8h.html#a78f76d4feea813702e84ffa5a550da3e" title="Delete a PKI profile.">SOPC_PKIProvider_DeleteProfile</a> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="adad14091abf498a225078a906e782b4a" name="adad14091abf498a225078a906e782b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad14091abf498a225078a906e782b4a">&#9670;&#160;</a></span>SOPC_PKIProvider_CreateMinimalUserProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_CreateMinimalUserProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> **&#160;</td>
          <td class="paramname"><em>ppProfile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a minimal PKI profile for user validation process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppProfile</td><td>The newly created profile. You should delete it with <a class="el" href="sopc__pki__stack_8h.html#a78f76d4feea813702e84ffa5a550da3e" title="Delete a PKI profile.">SOPC_PKIProvider_DeleteProfile</a> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="ac1932cfab3b0c67ea349e3db790d0d47" name="ac1932cfab3b0c67ea349e3db790d0d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1932cfab3b0c67ea349e3db790d0d47">&#9670;&#160;</a></span>SOPC_PKIProvider_ProfileSetUsageFromType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_ProfileSetUsageFromType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> *&#160;</td>
          <td class="paramname"><em>pProfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__pki__decl_8h.html#ae5ccc504dddfd034f68bb8dfb0c545ef">SOPC_PKI_Type</a>&#160;</td>
          <td class="paramname"><em>PKIType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the properties to the PKI profile from the PKI type. </p>
<pre class="fragment">   For users : the backward interoperability is disabled and the leaf profile will not be applied during
   ::SOPC_PKIProvider_ValidateCertificate.
   For clients : the keyUsage is expected to be filled with digitalSignature,
   nonRepudiation, keyEncipherment and dataEncipherment. The extendedKeyUsage is filled with serverAuth. Finally
   the backward interoperability is enabled.
   For Server : the keyUsage is expected to be filled with digitalSignature, nonRepudiation, keyEncipherment
   and dataEncipherment. The extendedKeyUsage is filled with clientAuth. Finally the backward interoperability
   is enabled.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pProfile</td><td>A valid pointer to the PKI profile. </td></tr>
    <tr><td class="paramname">PKIType</td><td>Defines the type of PKI (user, client or server)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a3a8c70f1b3af6859b3f98e3671c217ec" name="a3a8c70f1b3af6859b3f98e3671c217ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8c70f1b3af6859b3f98e3671c217ec">&#9670;&#160;</a></span>SOPC_PKIProvider_ProfileSetURI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_ProfileSetURI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> *&#160;</td>
          <td class="paramname"><em>pProfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>applicationUri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the application URI to the PKI profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pProfile</td><td>A valid pointer to the PKI profile. </td></tr>
    <tr><td class="paramname">applicationUri</td><td>The application URI to set in <code>pProfile</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the application URI is already defined in <code>pProfile</code>, you can not define it again.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a7ffbcb0cdc43b5340efcf755fc1fdbe4" name="a7ffbcb0cdc43b5340efcf755fc1fdbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffbcb0cdc43b5340efcf755fc1fdbe4">&#9670;&#160;</a></span>SOPC_PKIProvider_ProfileSetURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_ProfileSetURL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> *&#160;</td>
          <td class="paramname"><em>pProfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the endpoint URL used for connection to the PKI profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pProfile</td><td>A valid pointer to the PKI profile. </td></tr>
    <tr><td class="paramname">url</td><td>The endpoint URL used for connection to set in <code>pProfile</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the URL is already defined in <code>pProfile</code>, you can not define it again.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a78f76d4feea813702e84ffa5a550da3e" name="a78f76d4feea813702e84ffa5a550da3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f76d4feea813702e84ffa5a550da3e">&#9670;&#160;</a></span>SOPC_PKIProvider_DeleteProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SOPC_PKIProvider_DeleteProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> **&#160;</td>
          <td class="paramname"><em>ppProfile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a PKI profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppProfile</td><td>The PKI profile. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa312daf1781ba7c9bdd39774e808c20" name="aaa312daf1781ba7c9bdd39774e808c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa312daf1781ba7c9bdd39774e808c20">&#9670;&#160;</a></span>SOPC_PKIProvider_SetStorePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_SetStorePath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>directoryStorePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *&#160;</td>
          <td class="paramname"><em>pPKI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redefines the directory store where the certificates will be stored with <a class="el" href="sopc__pki__stack_8h.html#a92fc93e179f91885bb26b6ef154426df" title="Write the certificate files in the updatedTrustList folder of the PKI storage. The updatedTrustList f...">SOPC_PKIProvider_WriteToStore</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directoryStorePath</td><td>The directory path where the certificates will be stored. </td></tr>
    <tr><td class="paramname">pPKI</td><td>A valid pointer to the PKIProvider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The directory is created if <code>directoryStorePath</code> does not exist. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In case of error, <code>pPKI</code> is unchanged.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful, SOPC_STATUS_INVALID_PARAMETERS or SOPC_STATUS_NOK in case of error. </dd></dl>

</div>
</div>
<a id="a401854a0b46dc631db6f6810264a0f61" name="a401854a0b46dc631db6f6810264a0f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401854a0b46dc631db6f6810264a0f61">&#9670;&#160;</a></span>SOPC_PKIProvider_ValidateCertificate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_ValidateCertificate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *&#160;</td>
          <td class="paramname"><em>pPKI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *&#160;</td>
          <td class="paramname"><em>pToValidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__PKI__Profile.html">SOPC_PKI_Profile</a> *&#160;</td>
          <td class="paramname"><em>pProfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__PKI__Cert__Failure__Context.html">SOPC_PKI_Cert_Failure_Context</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validation function for a certificate with the PKI chain. </p>
<p>It implements the validation with the certificate chain of the PKI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pPKI</td><td>A valid pointer to the PKIProvider. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pToValidate</td><td>A valid pointer to the Certificate to validate. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pProfile</td><td>A valid pointer to the PKI profile. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>Pointer to store the OpcUa error code when certificate validation failed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>Pointer to store more details when certificate validation failed. Can be NULL. Only significant when return value is not <code>SOPC_STATUS_OK</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>error</code> is only set if returned status is different from SOPC_STATUS_OK. The certificate is internally stored if it is rejected.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In case of user PKI, the leaf profile part of <code>pProfile</code> is not applied to the certificate. The user leaf properties should be checked separately with <a class="el" href="sopc__pki__stack_8h.html#a53c578c607529cb2912e9676053217c4" title="Check leaf certificate properties.">SOPC_PKIProvider_CheckLeafCertificate</a> .</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when the certificate is successfully validated, and SOPC_STATUS_INVALID_PARAMETERS or SOPC_STATUS_NOK. </dd></dl>

</div>
</div>
<a id="a92fc93e179f91885bb26b6ef154426df" name="a92fc93e179f91885bb26b6ef154426df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fc93e179f91885bb26b6ef154426df">&#9670;&#160;</a></span>SOPC_PKIProvider_WriteToStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_WriteToStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *&#160;</td>
          <td class="paramname"><em>pPKI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bEraseExistingFiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the certificate files in the updatedTrustList folder of the PKI storage. The updatedTrustList folder is created if it is missing. The format of the written files is DER. The updatedTrustList folder is organized as follows: </p>
<ul>
<li>updatedTrustList/trusted/certs</li>
<li>updatedTrustList/trusted/crl</li>
<li>updatedTrustList/issuers/certs</li>
<li>updatedTrustList/issuers/crl</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPKI</td><td>A valid pointer to the PKIProvider. </td></tr>
    <tr><td class="paramname">bEraseExistingFiles</td><td>whether the existing files of the updatedTrustList folder shall be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the <code>pPKI</code> is built from lists ( <a class="el" href="sopc__pki__stack_8h.html#a7d7bb409d694607e31968ab7de568355" title="Create the PKIProvider from list representation.">SOPC_PKIProvider_CreateFromList</a> ) then you shall define the directory store path with <a class="el" href="sopc__pki__stack_8h.html#aaa312daf1781ba7c9bdd39774e808c20" title="Redefines the directory store where the certificates will be stored with SOPC_PKIProvider_WriteToStor...">SOPC_PKIProvider_SetStorePath</a> .</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a0cd7fc75f1053ae8b7f678c2656fc6b5" name="a0cd7fc75f1053ae8b7f678c2656fc6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd7fc75f1053ae8b7f678c2656fc6b5">&#9670;&#160;</a></span>SOPC_PKIProvider_WriteOrAppendToList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_WriteOrAppendToList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *&#160;</td>
          <td class="paramname"><em>pPKI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> **&#160;</td>
          <td class="paramname"><em>ppTrustedCerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> **&#160;</td>
          <td class="paramname"><em>ppTrustedCrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> **&#160;</td>
          <td class="paramname"><em>ppIssuerCerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> **&#160;</td>
          <td class="paramname"><em>ppIssuerCrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts certificates from the PKI object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPKI</td><td>A valid pointer to the PKIProvider. </td></tr>
    <tr><td class="paramname">ppTrustedCerts</td><td>Write: a valid pointer to a copy of the trusted certificate list. Append: a pointer to a pointer to a certificate list to which append the trusted certificate list. In either cases, you should free this object. </td></tr>
    <tr><td class="paramname">ppTrustedCrl</td><td>Write: a valid pointer to a copy of the trusted CRL list. Append: a pointer to a pointer to a certificate list to which append the trusted CRL list. In either cases, you should free this object. </td></tr>
    <tr><td class="paramname">ppIssuerCerts</td><td>Write: a valid pointer to a copy of the issuer certificate list. Append: a pointer to a pointer to a certificate list to which append the issuer certificate list. In either cases, you should free this object. </td></tr>
    <tr><td class="paramname">ppIssuerCrl</td><td>Write: a valid pointer to a copy of the issuer CRL list. Append: a pointer to a pointer to a certificate list to which append the issuer CRL list. In either cases, you should free this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In case of error, the whole lists ( <code>ppTrustedCerts</code> , <code>ppTrustedCrl</code> , <code>ppIssuerCerts</code> and <code>ppIssuerCrl</code> ) are free and set to NULL.</dd>
<dd>
If the <code>pPKI</code> contains an empty list then nothing is write or append for this list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a1c96f4450afe48f620d8cf23f6025c44" name="a1c96f4450afe48f620d8cf23f6025c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c96f4450afe48f620d8cf23f6025c44">&#9670;&#160;</a></span>SOPC_PKIProvider_WriteRejectedCertToStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_WriteRejectedCertToStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *&#160;</td>
          <td class="paramname"><em>pPKI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the rejected certificates files in the rejected folder of the PKI storage. The format of the written files is DER. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPKI</td><td>A valid pointer to the PKIProvider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The maximum number of certificates written in the rejected folder is <code>SOPC_PKI_MAX_NB_CERT_REJECTED</code> . This function removes the existing files.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the <code>pPKI</code> is built from lists ( <a class="el" href="sopc__pki__stack_8h.html#a7d7bb409d694607e31968ab7de568355" title="Create the PKIProvider from list representation.">SOPC_PKIProvider_CreateFromList</a> ) then you shall define the directory store path with <a class="el" href="sopc__pki__stack_8h.html#aaa312daf1781ba7c9bdd39774e808c20" title="Redefines the directory store where the certificates will be stored with SOPC_PKIProvider_WriteToStor...">SOPC_PKIProvider_SetStorePath</a> .</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a1232b1dff72a0e014cb9cdc49477a9e6" name="a1232b1dff72a0e014cb9cdc49477a9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1232b1dff72a0e014cb9cdc49477a9e6">&#9670;&#160;</a></span>SOPC_PKIProvider_CopyRejectedList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_CopyRejectedList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *&#160;</td>
          <td class="paramname"><em>pPKI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> **&#160;</td>
          <td class="paramname"><em>ppCert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the list of certificate that have been rejected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pPKI</td><td>A valid pointer to the PKIProvider. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppCert</td><td>A copy of the PKI rejected list (NULL if no certificate has been rejected).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The maximum number of certificates returned is <code>SOPC_PKI_MAX_NB_CERT_REJECTED</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a2049e9104d3dd9eaa4847374dcea4c4f" name="a2049e9104d3dd9eaa4847374dcea4c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2049e9104d3dd9eaa4847374dcea4c4f">&#9670;&#160;</a></span>SOPC_PKIProvider_UpdateFromList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_UpdateFromList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *&#160;</td>
          <td class="paramname"><em>pPKI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>securityPolicyUri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *&#160;</td>
          <td class="paramname"><em>pTrustedCerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> *&#160;</td>
          <td class="paramname"><em>pTrustedCrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CertificateList.html">SOPC_CertificateList</a> *&#160;</td>
          <td class="paramname"><em>pIssuerCerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__CRLList.html">SOPC_CRLList</a> *&#160;</td>
          <td class="paramname"><em>pIssuerCrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bIncludeExistingList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the PKI with new lists of certificates and CRL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPKI</td><td>A valid pointer to the PKIProvider. </td></tr>
    <tr><td class="paramname">securityPolicyUri</td><td>The URI describing the security policy of the secure channel. </td></tr>
    <tr><td class="paramname">pTrustedCerts</td><td>A valid pointer to the trusted certificate list. NULL if this part shall not updated. </td></tr>
    <tr><td class="paramname">pTrustedCrl</td><td>A valid pointer to the trusted CRL list. NULL if this part shall not updated. </td></tr>
    <tr><td class="paramname">pIssuerCerts</td><td>A valid pointer to the issuer certificate list. NULL if this part shall not updated. </td></tr>
    <tr><td class="paramname">pIssuerCrl</td><td>A valid pointer to the issuer CRL list. NULL if this part shall not updated. </td></tr>
    <tr><td class="paramname">bIncludeExistingList</td><td>whether the update shall includes the existing certificates of <code>pPKI</code> plus <code>pTrustedCerts</code> , <code>pTrustedCrl</code> , <code>pIssuerCerts</code> and <code>pIssuerCrl</code> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><code>securityPolicyUri</code> is not used yet and could be NULL. </dd>
<dd>
A callback shall have been defined using <a class="el" href="sopc__pki__stack_8h.html#a81980a08e99fe2ea4068fd1112290332" title="Defines the callback to be called when a PKI certificates update is done with SOPC_PKIProvider_Update...">SOPC_PKIProvider_SetUpdateCb</a> otherwise update is not authorized.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful (SOPC_STATUS_INVALID_STATE in case update callback is not set). </dd></dl>

</div>
</div>
<a id="ac150b11f004b3f677a25a7c7be4c0995" name="ac150b11f004b3f677a25a7c7be4c0995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac150b11f004b3f677a25a7c7be4c0995">&#9670;&#160;</a></span>SOPC_PKIProvider_RemoveCertificate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_RemoveCertificate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *&#160;</td>
          <td class="paramname"><em>pPKI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pThumbprint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bIsTrusted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsRemoved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsIssuer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all the certificates matching with the given thumbprint. If the Certificate is a CA Certificate then all the CRLs for that CA are removed. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will fail if <code>pThumbprint</code> does not match the SHA1 hex digest size. </dd>
<dd>
A callback shall have been defined using <a class="el" href="sopc__pki__stack_8h.html#a81980a08e99fe2ea4068fd1112290332" title="Defines the callback to be called when a PKI certificates update is done with SOPC_PKIProvider_Update...">SOPC_PKIProvider_SetUpdateCb</a> otherwise update is not authorized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pPKI</td><td>A valid pointer to the PKIProvider. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pThumbprint</td><td>The SHA1 of the certificate formatted as an hexadecimal C string (NULL terminated) 40 bytes shall be allocated in <code>pThumbprint</code> (+ 1 byte for the NULL character) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bIsTrusted</td><td>whether the certificate to remove is a trusted certificate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pIsRemoved</td><td>A valid pointer indicating whether the certificate has been found and deleted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pIsIssuer</td><td>A valid pointer indicating whether the deleted certificate is an issuer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful (SOPC_STATUS_INVALID_STATE in case update callback is not set). </dd></dl>

</div>
</div>
<a id="a4d64367293c474d45d5ec46a8cb5c328" name="a4d64367293c474d45d5ec46a8cb5c328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d64367293c474d45d5ec46a8cb5c328">&#9670;&#160;</a></span>SOPC_PKIPermissive_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIPermissive_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> **&#160;</td>
          <td class="paramname"><em>ppPKI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a PKI Provider without security. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ppPKI</td><td>A valid pointer to the newly created PKIProvider. You should free such provider with <a class="el" href="sopc__pki__stack_8h.html#a4d532205ec7e1de3183d1f9baf3d8029" title="Frees allocated PKIs.">SOPC_PKIProvider_Free()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Using this PKI is considered harmful for the security of the connection. This PKI shall be used for tests or to set a new configuration from a TOFU state.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK when successful. </dd></dl>

</div>
</div>
<a id="a81980a08e99fe2ea4068fd1112290332" name="a81980a08e99fe2ea4068fd1112290332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81980a08e99fe2ea4068fd1112290332">&#9670;&#160;</a></span>SOPC_PKIProvider_SetUpdateCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__enums_8h.html#a343b8b5b4f515a2b9a273571ac67d3ef">SOPC_ReturnStatus</a> SOPC_PKIProvider_SetUpdateCb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> *&#160;</td>
          <td class="paramname"><em>pPKI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__pki__decl_8h.html#afc0e55b8483986bd5133212e75b5ee1e">SOPC_PKIProviderUpdateCb</a> *&#160;</td>
          <td class="paramname"><em>pUpdateCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>updateParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the callback to be called when a PKI certificates update is done with <a class="el" href="sopc__pki__stack_8h.html#a2049e9104d3dd9eaa4847374dcea4c4f" title="Update the PKI with new lists of certificates and CRL.">SOPC_PKIProvider_UpdateFromList</a> or <a class="el" href="sopc__pki__stack_8h.html#ac150b11f004b3f677a25a7c7be4c0995" title="Remove all the certificates matching with the given thumbprint. If the Certificate is a CA Certificat...">SOPC_PKIProvider_RemoveCertificate</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>It is mandatory to define an associated behavior to allow calls to these functions. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Callback is used to re-evaluate the currently used certificates or to leave a TOFU state. (As example, <a class="el" href="sopc__toolkit__async__api_8h.html#af0c6a7e269e8f542ef5025ff33f22c67" title="Requests to re-evaluate the client secure channels due to client certificate / key update (force SC r...">SOPC_ToolkitClient_AsyncReEvalSecureChannels</a> is used for the callback of the application PKI and <a class="el" href="sopc__toolkit__async__api_8h.html#a2d8d2772583da36b35af19daba1790ab" title="Request to re-evaluate X509IdentityToken certificates for all active sessions due to user PKI trustli...">SOPC_ToolkitServer_AsyncReEvalUserCertSessions</a> is used for the callback of the user PKI) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The callback shall not do anything blocking and shall not modify the content of its associated <code>pPKI</code> .</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPKI</td><td>A valid pointer to the PKIProvider for which an update callback will be defined </td></tr>
    <tr><td class="paramname">pUpdateCb</td><td>The callback to be called when an update is done </td></tr>
    <tr><td class="paramname">updateParam</td><td>A user defined parameter for the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK in case of success, SOPC_STATUS_INVALID_PARAMETERS in case of NULL parameter and SOPC_STATUS_INVALID_STATE in case a callback is already defined. </dd></dl>

</div>
</div>
<a id="a4d532205ec7e1de3183d1f9baf3d8029" name="a4d532205ec7e1de3183d1f9baf3d8029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d532205ec7e1de3183d1f9baf3d8029">&#9670;&#160;</a></span>SOPC_PKIProvider_Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SOPC_PKIProvider_Free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSOPC__PKIProvider.html">SOPC_PKIProvider</a> **&#160;</td>
          <td class="paramname"><em>ppPKI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees allocated PKIs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppPKI</td><td>A valid pointer to a PKI. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 17 2025 13:45:56 for S2OPC OPCUA Toolkit by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
