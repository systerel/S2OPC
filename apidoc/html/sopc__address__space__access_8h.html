<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>S2OPC OPCUA Toolkit: src/ClientServer/address_space/sopc_address_space_access.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">S2OPC OPCUA Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_c3d037eb94fa1aa7134660c2803d99ab.html">ClientServer</a></li><li class="navelem"><a class="el" href="dir_ef21abcdd950983a805d4327c1b02870.html">address_space</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sopc_address_space_access.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="sopc__builtintypes_8h_source.html">sopc_builtintypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sopc__types_8h_source.html">sopc_types.h</a>&quot;</code><br />
</div>
<p><a href="sopc__address__space__access_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a26f00f86a997a189685bd9a9bb389550" id="r_a26f00f86a997a189685bd9a9bb389550"><td class="memItemLeft" align="right" valign="top">typedef struct _SOPC_AddressSpaceAccess&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a></td></tr>
<tr class="memdesc:a26f00f86a997a189685bd9a9bb389550"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddressSpace Access module provides controlled access to address space. This might be used to access address space during configuration phase or during a method call.  <br /></td></tr>
<tr class="separator:a26f00f86a997a189685bd9a9bb389550"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a50ae236c5814e952b8f8f7afbba31a7b" id="r_a50ae236c5814e952b8f8f7afbba31a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#a50ae236c5814e952b8f8f7afbba31a7b">SOPC_AddressSpaceAccess_ReadAttribute</a> (const <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *addSpaceAccess, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *nodeId, <a class="el" href="sopc__builtintypes_8h.html#af4856b685935c36d4cb8e2feeeeeb1b8">SOPC_AttributeId</a> attribId, <a class="el" href="structSOPC__Variant.html">SOPC_Variant</a> **outValue)</td></tr>
<tr class="memdesc:a50ae236c5814e952b8f8f7afbba31a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an attribute and retrieve its value as a Variant.  <br /></td></tr>
<tr class="separator:a50ae236c5814e952b8f8f7afbba31a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ac68fc1f61199c84982865c6f85534" id="r_ab0ac68fc1f61199c84982865c6f85534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#ab0ac68fc1f61199c84982865c6f85534">SOPC_AddressSpaceAccess_ReadValue</a> (const <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *addSpaceAccess, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *nodeId, const <a class="el" href="sopc__numeric__range_8h.html#a3f49a7602d8d265b622e3c2c76a85bde">SOPC_NumericRange</a> *optNumRange, <a class="el" href="structSOPC__DataValue.html">SOPC_DataValue</a> **outDataValue)</td></tr>
<tr class="memdesc:ab0ac68fc1f61199c84982865c6f85534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Value attribute content with Status and Source Timestamp metadata.  <br /></td></tr>
<tr class="separator:ab0ac68fc1f61199c84982865c6f85534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c67f415931d66bbba8fd312d647416e" id="r_a8c67f415931d66bbba8fd312d647416e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#a8c67f415931d66bbba8fd312d647416e">SOPC_AddressSpaceAccess_WriteValue</a> (<a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *addSpaceAccess, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *nodeId, const <a class="el" href="sopc__numeric__range_8h.html#a3f49a7602d8d265b622e3c2c76a85bde">SOPC_NumericRange</a> *optNumRange, const <a class="el" href="structSOPC__Variant.html">SOPC_Variant</a> *value, const <a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> *optStatus, const <a class="el" href="sopc__builtintypes_8h.html#a61a73148e994b49ed5337c472faa21b4">SOPC_DateTime</a> *optSourceTimestamp, const uint16_t *optSourcePicoSeconds)</td></tr>
<tr class="memdesc:a8c67f415931d66bbba8fd312d647416e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Value attribute content with Status and Source Timestamp metadata.  <br /></td></tr>
<tr class="separator:a8c67f415931d66bbba8fd312d647416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aee02906c1d889031ece18a2362dfe" id="r_a96aee02906c1d889031ece18a2362dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#a96aee02906c1d889031ece18a2362dfe">SOPC_AddressSpaceAccess_GetFreshNodeId</a> (<a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *addSpaceAccess, uint16_t nsIndex, <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *freshNodeId)</td></tr>
<tr class="memdesc:a96aee02906c1d889031ece18a2362dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a fresh numeric node Id from the namespace <code>nsIndex</code> in <code>addSpaceAccess</code>, and copy it to the out parameter <code>freshNodeId</code>.  <br /></td></tr>
<tr class="separator:a96aee02906c1d889031ece18a2362dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1722718525864ca3388742be42a4ceb4" id="r_a1722718525864ca3388742be42a4ceb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#a1722718525864ca3388742be42a4ceb4">SOPC_AddressSpaceAccess_AddVariableNode</a> (<a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *addSpaceAccess, const <a class="el" href="structSOPC__ExpandedNodeId.html">SOPC_ExpandedNodeId</a> *parentNodeId, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *refToParentTypeId, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *newNodeId, const <a class="el" href="structSOPC__QualifiedName.html">SOPC_QualifiedName</a> *browseName, const <a class="el" href="sopc__types_8h.html#a1b7d7bfbec62f881cf388a4828593450">OpcUa_VariableAttributes</a> *varAttributes, const <a class="el" href="structSOPC__ExpandedNodeId.html">SOPC_ExpandedNodeId</a> *typeDefId, const bool addChildNodesFromType)</td></tr>
<tr class="memdesc:a1722718525864ca3388742be42a4ceb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Variable node into the AddressSpace with given attributes and references to its parent and type.  <br /></td></tr>
<tr class="separator:a1722718525864ca3388742be42a4ceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed8587293d4c1b5101243d52c4c4e9f" id="r_a3ed8587293d4c1b5101243d52c4c4e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#a3ed8587293d4c1b5101243d52c4c4e9f">SOPC_AddressSpaceAccess_AddObjectNode</a> (<a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *addSpaceAccess, const <a class="el" href="structSOPC__ExpandedNodeId.html">SOPC_ExpandedNodeId</a> *parentNodeId, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *refToParentTypeId, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *newNodeId, const <a class="el" href="structSOPC__QualifiedName.html">SOPC_QualifiedName</a> *browseName, const <a class="el" href="sopc__types_8h.html#aedb8d4e99ab5aa4d233ca7de92f73286">OpcUa_ObjectAttributes</a> *objAttributes, const <a class="el" href="structSOPC__ExpandedNodeId.html">SOPC_ExpandedNodeId</a> *typeDefId, const bool addChildNodesFromType)</td></tr>
<tr class="memdesc:a3ed8587293d4c1b5101243d52c4c4e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Object node into the AddressSpace with given attributes and references to its parent and type.  <br /></td></tr>
<tr class="separator:a3ed8587293d4c1b5101243d52c4c4e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d136a248205f0176a4f59e67a89538e" id="r_a2d136a248205f0176a4f59e67a89538e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#a2d136a248205f0176a4f59e67a89538e">SOPC_AddressSpaceAccess_AddMethodNode</a> (<a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *addSpaceAccess, const <a class="el" href="structSOPC__ExpandedNodeId.html">SOPC_ExpandedNodeId</a> *parentNodeId, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *refToParentTypeId, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *newNodeId, const <a class="el" href="structSOPC__QualifiedName.html">SOPC_QualifiedName</a> *browseName, const <a class="el" href="sopc__types_8h.html#a6fe5669d5e998c3d74c227c73f85bfc1">OpcUa_MethodAttributes</a> *metAttributes)</td></tr>
<tr class="memdesc:a2d136a248205f0176a4f59e67a89538e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Method node into the AddressSpace with given attributes and reference to its parent.  <br /></td></tr>
<tr class="separator:a2d136a248205f0176a4f59e67a89538e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7754edf98c0e2314e2370ec612361428" id="r_a7754edf98c0e2314e2370ec612361428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#a7754edf98c0e2314e2370ec612361428">SOPC_AddressSpaceAccess_TranslateBrowsePath</a> (const <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *addSpaceAccess, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *startingNode, const <a class="el" href="sopc__types_8h.html#ac292ae148e6af9444098837cd08813db">OpcUa_RelativePath</a> *relativePath, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> **targetId)</td></tr>
<tr class="memdesc:a7754edf98c0e2314e2370ec612361428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate one browse path to a NodeId.  <br /></td></tr>
<tr class="separator:a7754edf98c0e2314e2370ec612361428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68804e20d322f632d7896b78d27c407c" id="r_a68804e20d322f632d7896b78d27c407c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#a68804e20d322f632d7896b78d27c407c">SOPC_AddressSpaceAccess_BrowseNode</a> (const <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *addSpaceAccess, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *nodeId, const <a class="el" href="sopc__enum__types_8h.html#a78c08f16c38300cf104686fe464afc67">OpcUa_BrowseDirection</a> browseDirection, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *referenceTypeId, const bool includeSubtypes, const <a class="el" href="sopc__enum__types_8h.html#ad78cf6da4b0af4c7452059946fd35b50">OpcUa_NodeClass</a> nodeClassMask, const <a class="el" href="sopc__enum__types_8h.html#a0b7903cc06416ba073ee723f7db109dc">OpcUa_BrowseResultMask</a> resultMask, <a class="el" href="sopc__types_8h.html#a28dac7a88cc62e4e90a981ddd493af6d">OpcUa_ReferenceDescription</a> **references, int32_t *noOfReferences)</td></tr>
<tr class="memdesc:a68804e20d322f632d7896b78d27c407c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Browse a node and retrieve an array of reference descriptions.  <br /></td></tr>
<tr class="separator:a68804e20d322f632d7896b78d27c407c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c1111e39b69bc2972a1e62d76196a5" id="r_a73c1111e39b69bc2972a1e62d76196a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__address__space__access_8h.html#a73c1111e39b69bc2972a1e62d76196a5">SOPC_AddressSpaceAccess_DeleteNode</a> (const <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *addSpaceAccess, const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *nodeIdToDelete, bool deleteTargetReferences, bool deleteChildNodes)</td></tr>
<tr class="memdesc:a73c1111e39b69bc2972a1e62d76196a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a node from the address space.  <br /></td></tr>
<tr class="separator:a73c1111e39b69bc2972a1e62d76196a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a26f00f86a997a189685bd9a9bb389550" name="a26f00f86a997a189685bd9a9bb389550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f00f86a997a189685bd9a9bb389550">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _SOPC_AddressSpaceAccess <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddressSpace Access module provides controlled access to address space. This might be used to access address space during configuration phase or during a method call. </p>
<dl class="section note"><dt>Note</dt><dd>AddressSpace is managed by services layer and shall not be accessed unless an AddressSpaceAccess instance is provided by the S2OPC API.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>AddressSpaceAccess operations are not thread-safe, concurrent access shall be managed by caller if caller wants to do some. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a50ae236c5814e952b8f8f7afbba31a7b" name="a50ae236c5814e952b8f8f7afbba31a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ae236c5814e952b8f8f7afbba31a7b">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess_ReadAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> SOPC_AddressSpaceAccess_ReadAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *&#160;</td>
          <td class="paramname"><em>addSpaceAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__builtintypes_8h.html#af4856b685935c36d4cb8e2feeeeeb1b8">SOPC_AttributeId</a>&#160;</td>
          <td class="paramname"><em>attribId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__Variant.html">SOPC_Variant</a> **&#160;</td>
          <td class="paramname"><em>outValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an attribute and retrieve its value as a Variant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">addSpaceAccess</td><td>The AddressSpace Access used for read operation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeId</td><td>The NodeId of a node in the AddressSpace </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">attribId</td><td>The AttributeId to read in the node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>The pointer in which the Variant containing the read result will be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_GoodGenericStatus in case of success with an allocated <code>outValue</code>, otherwise:<ul>
<li>OpcUa_BadInvalidArgument: if provided parameters are invalid (NULL)</li>
<li>OpcUa_BadNodeIdUnknown: if provided <code>nodeId</code> is not present in AddressSpace</li>
<li>OpcUa_BadNotImplemented: if the requested attribute is not implemented (it might also be invalid for concerned node in this case)</li>
<li>OpcUa_BadOutOfMemory: if Variant allocation failed</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The following attributes are not supported and will lead to return an OpcUa_BadNotImplemented status:<ul>
<li>ContainsNoLoops</li>
<li>InverseName</li>
<li>Symmetric</li>
<li>EventNotifier</li>
<li>MinimumSamplingInterval</li>
<li>Historizing</li>
<li>UserAccessLevel</li>
<li>UserExecutable User related attributes will never be provided since behavior is dynamic. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab0ac68fc1f61199c84982865c6f85534" name="ab0ac68fc1f61199c84982865c6f85534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ac68fc1f61199c84982865c6f85534">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess_ReadValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> SOPC_AddressSpaceAccess_ReadValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *&#160;</td>
          <td class="paramname"><em>addSpaceAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__numeric__range_8h.html#a3f49a7602d8d265b622e3c2c76a85bde">SOPC_NumericRange</a> *&#160;</td>
          <td class="paramname"><em>optNumRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__DataValue.html">SOPC_DataValue</a> **&#160;</td>
          <td class="paramname"><em>outDataValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Value attribute content with Status and Source Timestamp metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">addSpaceAccess</td><td>The AddressSpace Access used for read operation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeId</td><td>The NodeId of a Variable/VariableType node in the AddressSpace </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">optNumRange</td><td>(Optional) The numeric range to use to read value, it shall be NULL if no range requested. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outDataValue</td><td>The pointer in which the DataValue containing the read Value result will be returned. It contains the Value as a Variant and the associated StatusCode and Source Timestamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_GoodGenericStatus in case of success with an allocated <code>outValue</code>, otherwise:<ul>
<li>OpcUa_BadInvalidArgument: if provided parameters are invalid (NULL except if optional)</li>
<li>OpcUa_BadNodeIdUnknown: if provided <code>nodeId</code> is not present in AddressSpace</li>
<li>OpcUa_BadNotImplemented: if the requested attribute is not implemented (it might also be invalid for concerned node in this case)</li>
<li>OpcUa_BadOutOfMemory: if DataValue/Variant allocation failed</li>
<li>OpcUa_BadIndexRangeInvalid: if numeric range provided is invalid</li>
<li>OpcUa_BadIndexRangeNoData: if there is no data for the numeric range provided</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Server Timestamp is never set in returned value since current date on read is used for OPC UA service. </dd></dl>

</div>
</div>
<a id="a8c67f415931d66bbba8fd312d647416e" name="a8c67f415931d66bbba8fd312d647416e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c67f415931d66bbba8fd312d647416e">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess_WriteValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> SOPC_AddressSpaceAccess_WriteValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *&#160;</td>
          <td class="paramname"><em>addSpaceAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__numeric__range_8h.html#a3f49a7602d8d265b622e3c2c76a85bde">SOPC_NumericRange</a> *&#160;</td>
          <td class="paramname"><em>optNumRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__Variant.html">SOPC_Variant</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> *&#160;</td>
          <td class="paramname"><em>optStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__builtintypes_8h.html#a61a73148e994b49ed5337c472faa21b4">SOPC_DateTime</a> *&#160;</td>
          <td class="paramname"><em>optSourceTimestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>optSourcePicoSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write Value attribute content with Status and Source Timestamp metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addSpaceAccess</td><td>The AddressSpace Access used for write operation </td></tr>
    <tr><td class="paramname">nodeId</td><td>The NodeId of a Variable/VariableType node in the AddressSpace </td></tr>
    <tr><td class="paramname">optNumRange</td><td>(Optional) The numeric range to write in the targeted node with the given value, it shall be NULL if no range requested (complete write of target value). </td></tr>
    <tr><td class="paramname">value</td><td>The value to write into the Variable/VariableType node. </td></tr>
    <tr><td class="paramname">optStatus</td><td>(Optional) The status code to associate with the value written, NULL if previous value shall be kept. </td></tr>
    <tr><td class="paramname">optSourceTimestamp</td><td>(Optional) The source timestamp as OPC UA DateTime to associate with the value written, NULL if previous source timestamp shall be kept, 0 if the current time shall be set. </td></tr>
    <tr><td class="paramname">optSourcePicoSeconds</td><td>(Optional) The source timestamp picoseconds part to associate with the value written, it shall be NULL if <code>optSourceTimestamp</code> is NULL, it might be NULL or set to 0 if the current time shall be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_GoodGenericStatus in case of success, otherwise:<ul>
<li>OpcUa_BadInvalidArgument: if provided parameters are invalid (NULL, incoherent parameters)</li>
<li>OpcUa_BadNodeIdUnknown: if provided <code>nodeId</code> is not present in AddressSpace</li>
<li>OpcUa_BadWriteNotSupported: if status code and/or timestamp provided but are read-only in AddressSpace</li>
<li>OpcUa_BadNotImplemented: if the requested attribute is not implemented (it might also be invalid for concerned node in this case)</li>
<li>OpcUa_BadOutOfMemory: if an allocation failed during write operation</li>
<li>OpcUa_BadIndexRangeInvalid: if numeric range provided is invalid</li>
<li>OpcUa_BadIndexRangeNoData: if there is no data for the numeric range provided</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No typechecking is implemented in this operation for now (value write will succeed), it is responsibility of caller to check the Value complies with the Variable DataType. </dd></dl>

</div>
</div>
<a id="a96aee02906c1d889031ece18a2362dfe" name="a96aee02906c1d889031ece18a2362dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96aee02906c1d889031ece18a2362dfe">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess_GetFreshNodeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> SOPC_AddressSpaceAccess_GetFreshNodeId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *&#160;</td>
          <td class="paramname"><em>addSpaceAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nsIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>freshNodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a fresh numeric node Id from the namespace <code>nsIndex</code> in <code>addSpaceAccess</code>, and copy it to the out parameter <code>freshNodeId</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">addSpaceAccess</td><td>The AddressSpace Access used for write operation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nsIndex</td><td>The Namespace index of the fresh nodeId requested </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">freshNodeId</td><td>A valid pointer to the nodeId which will receive the fresh nodeId.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><code>nsIndex</code> value should be less or equal to the maximum NS index in address space, using a value greater than the number of addresspace namespaces will make grow the array (of maximum numeric Ids) size to this <code>nsIndex</code> value without any prior check.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_GoodGenericStatus in case of success, otherwise:<ul>
<li>OpcUa_BadInvalidArgument: if provided parameters are invalid (NULL, incoherent parameters)</li>
<li>OpcUa_BadNodeIdInvalid: if obtaining a fresh nodeId failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1722718525864ca3388742be42a4ceb4" name="a1722718525864ca3388742be42a4ceb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1722718525864ca3388742be42a4ceb4">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess_AddVariableNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> SOPC_AddressSpaceAccess_AddVariableNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *&#160;</td>
          <td class="paramname"><em>addSpaceAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__ExpandedNodeId.html">SOPC_ExpandedNodeId</a> *&#160;</td>
          <td class="paramname"><em>parentNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>refToParentTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>newNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__QualifiedName.html">SOPC_QualifiedName</a> *&#160;</td>
          <td class="paramname"><em>browseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__types_8h.html#a1b7d7bfbec62f881cf388a4828593450">OpcUa_VariableAttributes</a> *&#160;</td>
          <td class="paramname"><em>varAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__ExpandedNodeId.html">SOPC_ExpandedNodeId</a> *&#160;</td>
          <td class="paramname"><em>typeDefId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>addChildNodesFromType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a Variable node into the AddressSpace with given attributes and references to its parent and type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addSpaceAccess</td><td>The AddressSpace Access used for AddNodes operation </td></tr>
    <tr><td class="paramname">parentNodeId</td><td>The ExpandedNodeId of the parent node in AddressSpace for the variable to add. Only "local" NodeId are supported for now (ServerIndex shall be 0 and NamespaceUri is ignored). Parent node characteristics shall be compliant to add the new Variable node as a child. See OPC UA specifications part 3 for constraints and returned error code for details. </td></tr>
    <tr><td class="paramname">refToParentTypeId</td><td>The NodeId of the reference type used for reference between parent node and new variable node. E.g. Organizes, HasComponent, etc. ReferenceType shall be compliant with parent node and variable node characteristics. See OPC UA specifications part 3 for constraints and returned error code for details. </td></tr>
    <tr><td class="paramname">newNodeId</td><td>The fresh NodeId for the new variable to add. It shall not already exist in AddressSpace. </td></tr>
    <tr><td class="paramname">browseName</td><td>The QualifiedName used when browsing the AddressSpace for the new variable node. It shall be unique in the parent node children. </td></tr>
    <tr><td class="paramname">varAttributes</td><td>The attributes defined for the new variable node. The following attributes combination are not supported and will make addition fail: WriteMask or UserWriteMask, UserAccessLevel, NoOfArrayDimensions without ArrayDimensions, Historizing = true, MinimumSamplingInterval != 0, </td></tr>
    <tr><td class="paramname">typeDefId</td><td>The ExpandedNodeId of the type definition node in AddressSpace for the variable to add. E.g. BaseDataVariable, PropertyType, etc. Only "local" NodeId are supported for now (ServerIndex shall be 0 and NamespaceUri ignored). Type characteristics shall be compliant to add the Variable into the parent node indicated. See OPC UA specifications part 3 for constraints and returned error code for details. </td></tr>
    <tr><td class="paramname">addChildNodesFromType</td><td>A flag to activate automatic generation of child nodes based on the variable type definition (only mandatory nodes by default, see note).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_GoodGenericStatus in case of success, SOPC_UncertainStatusMask if variable node is created but a (partial) failure occurred during its automatic child nodes creation based on TypeDefinition, otherwise address space is unchanged for the following errors:<ul>
<li>OpcUa_BadInvalidArgument: if provided parameters are invalid (NULL)</li>
<li>OpcUa_BadServiceUnsupported: if the AddressSpace does not support to add Variable node dynamically. Note: XML loaded AddressSpace supports this operation.</li>
<li>OpcUa_BadNodeIdExists: if <code>newNodeId</code> already exists in AddressSpace</li>
<li>OpcUa_BadParentNodeIdInvalid: if <code>parentNodeId</code> is unknown</li>
<li>OpcUa_BadReferenceNotAllowed: the <code>refToParentTypeId</code> (Organizes, HasComponent, etc.) is not compliant regarding the parent node characteristics. See OPC UA specifications part 3 for constraints and logs for detail in case of error.</li>
<li>OpcUa_BadTypeDefinitionInvalid: the <code>typeDefId</code> (BaseDataVariable, PropertyType, etc.) is unknown or is not compliant regarding the Variable characteristics and its relation to parent node. See OPC UA specifications part 3 for constraints and logs for detail in case of error.</li>
<li>OpcUa_BadBrowseNameDuplicated: if <code>browseName</code> is not unique in parent node.</li>
<li>OpcUa_BadNodeAttributesInvalid: if <code>varAttributes</code> contains unsupported attributes. See logs for detail in case of error.</li>
<li>OpcUa_BadOutOfMemory: if an allocation failed during add node operation</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: Add variable node operation includes creation of mutual references with parent / type. Inverse reference from type to new node is added by default. This reference creation can be avoided by setting S2OPC_NODE_ADD_INVERSE_TYPEDEF=0 at compile time.</dd>
<dd>
: Children of the Variable that might declared as mandatory in the <code>typeDefId</code> are generated automatically by this operation. Optional nodes can also be added by setting S2OPC_NODE_ADD_OPTIONAL=1 at compile time. Only children with an 'Aggregates' reference type or sub-type are added. Children with 'Organizes' and 'HasEventSource' reference types are ignored.</dd>
<dd>
: The uniqueness of the BrowseName among the parent's references of the added node is checked by default. This check may be avoided by setting S2OPC_NODE_DISABLE_CHECK_UNIQUENESS_BROWSENAME=1 at compile time. </dd></dl>

</div>
</div>
<a id="a3ed8587293d4c1b5101243d52c4c4e9f" name="a3ed8587293d4c1b5101243d52c4c4e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed8587293d4c1b5101243d52c4c4e9f">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess_AddObjectNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> SOPC_AddressSpaceAccess_AddObjectNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *&#160;</td>
          <td class="paramname"><em>addSpaceAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__ExpandedNodeId.html">SOPC_ExpandedNodeId</a> *&#160;</td>
          <td class="paramname"><em>parentNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>refToParentTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>newNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__QualifiedName.html">SOPC_QualifiedName</a> *&#160;</td>
          <td class="paramname"><em>browseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__types_8h.html#aedb8d4e99ab5aa4d233ca7de92f73286">OpcUa_ObjectAttributes</a> *&#160;</td>
          <td class="paramname"><em>objAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__ExpandedNodeId.html">SOPC_ExpandedNodeId</a> *&#160;</td>
          <td class="paramname"><em>typeDefId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>addChildNodesFromType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an Object node into the AddressSpace with given attributes and references to its parent and type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addSpaceAccess</td><td>The AddressSpace Access used for AddNodes operation </td></tr>
    <tr><td class="paramname">parentNodeId</td><td>The ExpandedNodeId of the parent node in AddressSpace for the Object to add. Only "local" NodeId are supported for now (ServerIndex shall be 0 and NamespaceUri is ignored). Parent node characteristics shall be compliant to add the new Object node as a child. See OPC UA specifications part 3 for constraints and returned error code for details. </td></tr>
    <tr><td class="paramname">refToParentTypeId</td><td>The NodeId of the reference type used for reference between parent node and new Object node. E.g. Organizes, HasComponent, etc. ReferenceType shall be compliant with parent node and Object node characteristics. See OPC UA specifications part 3 for constraints and returned error code for details. </td></tr>
    <tr><td class="paramname">newNodeId</td><td>The fresh NodeId for the new Object to add. It shall not already exist in AddressSpace. </td></tr>
    <tr><td class="paramname">browseName</td><td>The QualifiedName used when browsing the AddressSpace for the new Object node. It shall be unique in the parent node children. </td></tr>
    <tr><td class="paramname">objAttributes</td><td>The attributes defined for the new Object node. The following attributes combination are not supported and will make addition fail: WriteMask or UserWriteMask. </td></tr>
    <tr><td class="paramname">typeDefId</td><td>The ExpandedNodeId of the type definition node in AddressSpace for the variable to add. E.g. BaseDataVariable, PropertyType, etc. Only "local" NodeId are supported for now (ServerIndex shall be 0 and NamespaceUri ignored). Type characteristics shall be compliant to add the Variable into the parent node indicated. See OPC UA specifications part 3 for constraints and returned error code for details. </td></tr>
    <tr><td class="paramname">addChildNodesFromType</td><td>A flag to activate automatic generation of child nodes based on the object type definition (only mandatory nodes by default, see note)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_GoodGenericStatus in case of success, SOPC_UncertainStatusMask if object node is created but a (partial) failure occurred during its automatic child nodes creation based on TypeDefinition, otherwise address space is unchanged for the following errors:<ul>
<li>OpcUa_BadInvalidArgument: if provided parameters are invalid (NULL)</li>
<li>OpcUa_BadServiceUnsupported: if the AddressSpace does not support to add Object node dynamically. Note: XML loaded AddressSpace supports this operation.</li>
<li>OpcUa_BadNodeIdExists: if <code>newNodeId</code> already exists in AddressSpace</li>
<li>OpcUa_BadParentNodeIdInvalid: if <code>parentNodeId</code> is unknown</li>
<li>OpcUa_BadReferenceNotAllowed: the <code>refToParentTypeId</code> (Organizes, HasComponent, etc.) is not compliant regarding the parent node characteristics. See OPC UA specifications part 3 for constraints and logs for detail in case of error.</li>
<li>OpcUa_BadTypeDefinitionInvalid: the <code>typeDefId</code> (BaseObjectType, FolderType, etc.) is unknown or is not compliant regarding the Object characteristics and its relation to parent node. See OPC UA specifications part 3 for constraints and logs for detail in case of error.</li>
<li>OpcUa_BadBrowseNameDuplicated: if <code>browseName</code> is not unique in parent node.</li>
<li>OpcUa_BadNodeAttributesInvalid: if <code>objAttributes</code> contains unsupported attributes. See logs for detail in case of error.</li>
<li>OpcUa_BadOutOfMemory: if an allocation failed during add node operation</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: Add Object node operation includes creation of mutual references with parent / type. Inverse reference from type to new node is added by default. This reference creation can be avoided by setting S2OPC_NODE_ADD_INVERSE_TYPEDEF=0 at compile time.</dd>
<dd>
: Children of the Object that might declared as mandatory in the <code>typeDefId</code> are generated automatically by this operation. Optional nodes can also be added by setting S2OPC_NODE_ADD_OPTIONAL=1 at compile time. Only children with an 'Aggregates' reference type or sub-type are added. Children with 'Organizes' and 'HasEventSource' reference types are ignored.</dd>
<dd>
: The uniqueness of the BrowseName among the parent's references of the added node is checked by default. This check may be avoided by setting S2OPC_NODE_DISABLE_CHECK_UNIQUENESS_BROWSENAME=1 at compile time. </dd></dl>

</div>
</div>
<a id="a2d136a248205f0176a4f59e67a89538e" name="a2d136a248205f0176a4f59e67a89538e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d136a248205f0176a4f59e67a89538e">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess_AddMethodNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> SOPC_AddressSpaceAccess_AddMethodNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *&#160;</td>
          <td class="paramname"><em>addSpaceAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__ExpandedNodeId.html">SOPC_ExpandedNodeId</a> *&#160;</td>
          <td class="paramname"><em>parentNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>refToParentTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>newNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__QualifiedName.html">SOPC_QualifiedName</a> *&#160;</td>
          <td class="paramname"><em>browseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__types_8h.html#a6fe5669d5e998c3d74c227c73f85bfc1">OpcUa_MethodAttributes</a> *&#160;</td>
          <td class="paramname"><em>metAttributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an Method node into the AddressSpace with given attributes and reference to its parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addSpaceAccess</td><td>The AddressSpace Access used for AddNodes operation </td></tr>
    <tr><td class="paramname">parentNodeId</td><td>The ExpandedNodeId of the parent node in AddressSpace for the Method to add. Only "local" NodeId are supported for now (ServerIndex shall be 0 and NamespaceUri is ignored). Parent node characteristics shall be compliant to add the new Method node as a child. See OPC UA specifications part 3 for constraints and returned error code for details. </td></tr>
    <tr><td class="paramname">refToParentTypeId</td><td>The NodeId of the reference type used for reference between parent node and new Method node. E.g. Organizes, HasComponent, etc. ReferenceType shall be compliant with parent node and Method node characteristics. See OPC UA specifications part 3 for constraints and returned error code for details. </td></tr>
    <tr><td class="paramname">newNodeId</td><td>The fresh NodeId for the new Method to add. It shall not already exist in AddressSpace. </td></tr>
    <tr><td class="paramname">browseName</td><td>The QualifiedName used when browsing the AddressSpace for the new Method node. It shall be unique in the parent node children. </td></tr>
    <tr><td class="paramname">metAttributes</td><td>The attributes defined for the new Method node. The following attributes combination are not supported and will make addition fail: WriteMask or UserWriteMask, Executable or UserExecutable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_GoodGenericStatus in case of success, otherwise address space is unchanged for the following errors:<ul>
<li>OpcUa_BadInvalidArgument: if provided parameters are invalid (NULL)</li>
<li>OpcUa_BadServiceUnsupported: if the AddressSpace does not support to add Method node dynamically. Note: XML loaded AddressSpace supports this operation.</li>
<li>OpcUa_BadNodeIdExists: if <code>newNodeId</code> already exists in AddressSpace</li>
<li>OpcUa_BadParentNodeIdInvalid: if <code>parentNodeId</code> is unknown</li>
<li>OpcUa_BadReferenceNotAllowed: the <code>refToParentTypeId</code> (Organizes, HasComponent, etc.) is not compliant regarding the parent node characteristics. See OPC UA specifications part 3 for constraints and logs for detail in case of error.</li>
<li>OpcUa_BadBrowseNameDuplicated: if <code>browseName</code> is not unique in parent node.</li>
<li>OpcUa_BadNodeAttributesInvalid: if <code>metAttributes</code> contains unsupported attributes. See logs for detail in case of error.</li>
<li>OpcUa_BadOutOfMemory: if an allocation failed during add node operation</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: Add Method node operation includes creation of mutual references with parent / type. Inverse reference from type to new node is added by default. This reference creation can be avoided by setting S2OPC_NODE_ADD_INVERSE_TYPEDEF=0 at compile time.</dd>
<dd>
: The uniqueness of the BrowseName among the parent's references of the added node is checked by default. This check may be avoided by setting S2OPC_NODE_DISABLE_CHECK_UNIQUENESS_BROWSENAME=1 at compile time. </dd></dl>

</div>
</div>
<a id="a7754edf98c0e2314e2370ec612361428" name="a7754edf98c0e2314e2370ec612361428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7754edf98c0e2314e2370ec612361428">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess_TranslateBrowsePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> SOPC_AddressSpaceAccess_TranslateBrowsePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *&#160;</td>
          <td class="paramname"><em>addSpaceAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>startingNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__types_8h.html#ac292ae148e6af9444098837cd08813db">OpcUa_RelativePath</a> *&#160;</td>
          <td class="paramname"><em>relativePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> **&#160;</td>
          <td class="paramname"><em>targetId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate one browse path to a NodeId. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">addSpaceAccess</td><td>The AddressSpace Access used for TranslateBrowsePath operation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">startingNode</td><td>The startingNode is the nodeId of the starting Node for the browse path. It should not be NULL otherwise OpcUa_BadInvalidArgument is returned. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relativePath</td><td><code>relativePath</code> is the path to follow from the startingNode. The elements in the relativePath shall have a targetName specified. The elements in the relativePath shall have a referenceTypeId specified. Only elements in the address space can be fetch. If one of the target nodes is in a remote server OpcUa_BadNoMatch is returned. It should not be NULL otherwise OpcUa_BadInvalidArgument is returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">targetId</td><td><code>targetId</code> is the identifier of the target for the relativePath from the startingNode. The pointed <code>targetId</code> SHALL NOT be modified nor deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_GoodGenericStatus in case of success, otherwise :<ul>
<li>OpcUa_BadInvalidArgument: if provided parameters are invalid (NULL)</li>
<li>OpcUa_BadNodeIdUnknown <code>startingNode</code> is not found.</li>
<li>OpcUa_BadNoMatch one of the target in the relative path is not found </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a68804e20d322f632d7896b78d27c407c" name="a68804e20d322f632d7896b78d27c407c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68804e20d322f632d7896b78d27c407c">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess_BrowseNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> SOPC_AddressSpaceAccess_BrowseNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *&#160;</td>
          <td class="paramname"><em>addSpaceAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__enum__types_8h.html#a78c08f16c38300cf104686fe464afc67">OpcUa_BrowseDirection</a>&#160;</td>
          <td class="paramname"><em>browseDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>referenceTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeSubtypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__enum__types_8h.html#ad78cf6da4b0af4c7452059946fd35b50">OpcUa_NodeClass</a>&#160;</td>
          <td class="paramname"><em>nodeClassMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sopc__enum__types_8h.html#a0b7903cc06416ba073ee723f7db109dc">OpcUa_BrowseResultMask</a>&#160;</td>
          <td class="paramname"><em>resultMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__types_8h.html#a28dac7a88cc62e4e90a981ddd493af6d">OpcUa_ReferenceDescription</a> **&#160;</td>
          <td class="paramname"><em>references</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>noOfReferences</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Browse a node and retrieve an array of reference descriptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">addSpaceAccess</td><td>The addressSpace access used to browse </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeId</td><td>The nodeId of the node to browse. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">browseDirection</td><td>The browse direction to use <code>browseDirection</code> shall be in range of <a class="el" href="sopc__enum__types_8h.html#a78c08f16c38300cf104686fe464afc67">OpcUa_BrowseDirection</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">referenceTypeId</td><td>The nodeId of the reference type to follow. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">includeSubtypes</td><td>Indicates whether subtypes of the referenceType should be included in the browse. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeClassMask</td><td>Specifies the expected nodeClasses for the targetNodes. THIS IS NOT SUPPORTED IN THIS VERSION. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">resultMask</td><td>Specifies the field in the referenceDescription structure that should be returned. THIS IS NOT SUPPORTED IN THIS VERSION. referenceType and isForward are always returned. nodeClass, browseName, displayName and typeDefinition are never returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">references</td><td>The array of references that meet the criteria specified above. The pointer shall not be NULL. Returned values are allocated and it is responsibility of the caller to free this memory with <a class="el" href="sopc__builtintypes_8h.html#a1b63880d783148d0dc4f62724b9ccc45">SOPC_Clear_Array</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">noOfReferences</td><td>Number Of referenceDescription returned. The pointer shall not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_GoodGenericStatus in case of success, otherwise:<ul>
<li>OpcUa_BadInvalidArgument : if provided parameters are invalid (NULL)</li>
<li>OpcUa_BadNodeIdUnknown : <code>nodeId</code> is not found</li>
<li>OpcUa_BadReferenceTypeIdInvalid : <code>referenceTypeId</code> does not refer to a valid reference type node.</li>
<li>OpcUa_BadBrowseDirectionInvalid : if <code>browseDirection</code> is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a73c1111e39b69bc2972a1e62d76196a5" name="a73c1111e39b69bc2972a1e62d76196a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c1111e39b69bc2972a1e62d76196a5">&#9670;&#160;</a></span>SOPC_AddressSpaceAccess_DeleteNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__builtintypes_8h.html#a91f4f3f2cce383f2003cbad3c76d46aa">SOPC_StatusCode</a> SOPC_AddressSpaceAccess_DeleteNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sopc__address__space__access_8h.html#a26f00f86a997a189685bd9a9bb389550">SOPC_AddressSpaceAccess</a> *&#160;</td>
          <td class="paramname"><em>addSpaceAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSOPC__NodeId.html">SOPC_NodeId</a> *&#160;</td>
          <td class="paramname"><em>nodeIdToDelete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteTargetReferences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteChildNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a node from the address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addSpaceAccess</td><td>The AddressSpace Access to use for the operation. </td></tr>
    <tr><td class="paramname">nodeIdToDelete</td><td>The nodeId of the node to delete. </td></tr>
    <tr><td class="paramname">deleteTargetReferences</td><td>Flag indicating if the references with TargetNode = nodeToDelete need to be deleted. </td></tr>
    <tr><td class="paramname">deleteChildNodes</td><td>Flag indicating if orphans child nodes of nodeToDelete need to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- SOPC_GoodGenericStatus in case of success and b_deleteTargetReferences = FALSE,<ul>
<li>OpcUa_UncertainReferenceNotDeleted in case of success and b_deleteTargetReferencesotherwise = TRUE,</li>
<li>OpcUa_BadInvalidArgument if bad parameter,</li>
<li>OpcUa_BadNodeIdUnknown <code>nodeToDelete</code> is not found. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 17 2025 13:45:56 for S2OPC OPCUA Toolkit by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
