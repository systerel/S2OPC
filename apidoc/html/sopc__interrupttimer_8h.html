<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>S2OPC OPCUA Toolkit: src/PubSub/real_time_api/sopc_interrupttimer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">S2OPC OPCUA Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_f0204f00f7eec24e509304baf7a032c6.html">PubSub</a></li><li class="navelem"><a class="el" href="dir_36ab60e010376472964a30fd790bf6cb.html">real_time_api</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sopc_interrupttimer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interrupt timer, called from interrupt, used by <a class="el" href="sopc__rt__publisher_8h.html#addbde8a0ebf5397b378a456a097a84f1" title="RT Publisher handle.">SOPC_RT_Publisher</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="sopc__enums_8h_source.html">sopc_enums.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sopc__mem__alloc_8h_source.html">sopc_mem_alloc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sopc__doublebuffer_8h_source.html">sopc_doublebuffer.h</a>&quot;</code><br />
</div>
<p><a href="sopc__interrupttimer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af3d1c424ce9ac4a5852a3f4a01f4ec68"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a></td></tr>
<tr class="memdesc:af3d1c424ce9ac4a5852a3f4a01f4ec68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle of an interrupt timer workspace. For one interrupt timer workspace, several timer instances can be instantiated, Created by SOPC_InterruptTimer_Create, then used as following steps:  <a href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">More...</a><br /></td></tr>
<tr class="separator:af3d1c424ce9ac4a5852a3f4a01f4ec68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03a8e59d25790a196c45f25ba63fcea"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a></td></tr>
<tr class="memdesc:af03a8e59d25790a196c45f25ba63fcea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle of a interrupt timer data container. This handle is used if you want work directly with buffer of an interrupt timer instance. The buffer is externally exposed by this handle, linked to a SOPC_InterruptTimer + timer instance identifier. Created by SOPC_InterruptTimer_DataHandle_Create, which links it to one workspace and one instance, then those steps shall be followed to publish data:  <a href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">More...</a><br /></td></tr>
<tr class="separator:af03a8e59d25790a196c45f25ba63fcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047f14e59909a8212d4fb1f7726cf678"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a047f14e59909a8212d4fb1f7726cf678">sopc_irq_timer_cb_start</a>) (uint32_t timerId, void *pUserContext)</td></tr>
<tr class="memdesc:a047f14e59909a8212d4fb1f7726cf678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start callback, called when timer switch from DISABLED to ENABLED.  <a href="sopc__interrupttimer_8h.html#a047f14e59909a8212d4fb1f7726cf678">More...</a><br /></td></tr>
<tr class="separator:a047f14e59909a8212d4fb1f7726cf678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9959439476932404cf326010fbda8cdb"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a9959439476932404cf326010fbda8cdb">sopc_irq_timer_cb_stop</a>) (uint32_t timerId, void *pUserContext)</td></tr>
<tr class="memdesc:a9959439476932404cf326010fbda8cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop callback, called when timer switch from ENABLED to DISABLED.  <a href="sopc__interrupttimer_8h.html#a9959439476932404cf326010fbda8cdb">More...</a><br /></td></tr>
<tr class="separator:a9959439476932404cf326010fbda8cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232df064705c18c0d685e35c440a6927"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a232df064705c18c0d685e35c440a6927">sopc_irq_timer_cb_period_elapsed</a>) (uint32_t timerId, void *pUserContext, void *pData, uint32_t size)</td></tr>
<tr class="memdesc:a232df064705c18c0d685e35c440a6927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elapsed callback, called when timer reach its configured period.  <a href="sopc__interrupttimer_8h.html#a232df064705c18c0d685e35c440a6927">More...</a><br /></td></tr>
<tr class="separator:a232df064705c18c0d685e35c440a6927"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afc0c1002e9a4344f873e87f504a47f91"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#afc0c1002e9a4344f873e87f504a47f91">SOPC_IrqTimer_InstanceStatus</a> { <a class="el" href="sopc__interrupttimer_8h.html#afc0c1002e9a4344f873e87f504a47f91a3313e746338ff5bad5771b32c1af9bee">SOPC_INTERRUPT_TIMER_STATUS_DISABLED</a>, 
<a class="el" href="sopc__interrupttimer_8h.html#afc0c1002e9a4344f873e87f504a47f91afe149834fcdaa93d05ebd9ef550ace03">SOPC_INTERRUPT_TIMER_STATUS_ENABLED</a>, 
<a class="el" href="sopc__interrupttimer_8h.html#afc0c1002e9a4344f873e87f504a47f91a4ea7dba76832b41a913f571e024084c3">SOPC_INTERRUPT_TIMER_STATUS_INVALID</a> = INT32_MAX
 }</td></tr>
<tr class="memdesc:afc0c1002e9a4344f873e87f504a47f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status of a timer instance.  <a href="sopc__interrupttimer_8h.html#afc0c1002e9a4344f873e87f504a47f91">More...</a><br /></td></tr>
<tr class="separator:afc0c1002e9a4344f873e87f504a47f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3fd6f9e08eda65d37e3592d5b877ff09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a3fd6f9e08eda65d37e3592d5b877ff09">SOPC_InterruptTimer_Create</a> (void)</td></tr>
<tr class="memdesc:a3fd6f9e08eda65d37e3592d5b877ff09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interrupt timer. This function shall be followed by initialize function to use the timer.  <a href="sopc__interrupttimer_8h.html#a3fd6f9e08eda65d37e3592d5b877ff09">More...</a><br /></td></tr>
<tr class="separator:a3fd6f9e08eda65d37e3592d5b877ff09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4361e0c3da18b6df9c610f44c54a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#abb4361e0c3da18b6df9c610f44c54a47">SOPC_InterruptTimer_Destroy</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> **ppTimer)</td></tr>
<tr class="memdesc:abb4361e0c3da18b6df9c610f44c54a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy interrupt timer. This function shall be called only if SOPC_InterruptTimer_DeInitialize returns SOPC_STATUS_OK.  <a href="sopc__interrupttimer_8h.html#abb4361e0c3da18b6df9c610f44c54a47">More...</a><br /></td></tr>
<tr class="separator:abb4361e0c3da18b6df9c610f44c54a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86232fe915bd463e0e983534cca11ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#ae86232fe915bd463e0e983534cca11ac">SOPC_InterruptTimer_Initialize</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t nbInstances, uint32_t maxInstanceDataSize)</td></tr>
<tr class="memdesc:ae86232fe915bd463e0e983534cca11ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize interrupt timer workspace.  <a href="sopc__interrupttimer_8h.html#ae86232fe915bd463e0e983534cca11ac">More...</a><br /></td></tr>
<tr class="separator:ae86232fe915bd463e0e983534cca11ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3ad68d8b611c29388fec3ade42826e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#acd3ad68d8b611c29388fec3ade42826e">SOPC_InterruptTimer_DeInitialize</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer)</td></tr>
<tr class="memdesc:acd3ad68d8b611c29388fec3ade42826e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DeInitialize interrupt timer workspace.  <a href="sopc__interrupttimer_8h.html#acd3ad68d8b611c29388fec3ade42826e">More...</a><br /></td></tr>
<tr class="separator:acd3ad68d8b611c29388fec3ade42826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9c197034a70e3c312843b480af64a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#acd9c197034a70e3c312843b480af64a6">SOPC_InterruptTimer_Instance_Init</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t idInstanceTimer, uint32_t period, uint32_t offset, void *pUserContext, <a class="el" href="sopc__interrupttimer_8h.html#a047f14e59909a8212d4fb1f7726cf678">sopc_irq_timer_cb_start</a> cbStart, <a class="el" href="sopc__interrupttimer_8h.html#a232df064705c18c0d685e35c440a6927">sopc_irq_timer_cb_period_elapsed</a> cbElapsed, <a class="el" href="sopc__interrupttimer_8h.html#a9959439476932404cf326010fbda8cdb">sopc_irq_timer_cb_stop</a> cbStop, <a class="el" href="sopc__interrupttimer_8h.html#afc0c1002e9a4344f873e87f504a47f91">SOPC_IrqTimer_InstanceStatus</a> initStatus)</td></tr>
<tr class="memdesc:acd9c197034a70e3c312843b480af64a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset timer instance and initialize it on next SOPC_InterruptTimer_Update call.  <a href="sopc__interrupttimer_8h.html#acd9c197034a70e3c312843b480af64a6">More...</a><br /></td></tr>
<tr class="separator:acd9c197034a70e3c312843b480af64a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1ac72e3f463645e0419b054b8d4230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a1e1ac72e3f463645e0419b054b8d4230">SOPC_InterruptTimer_Instance_DeInit</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t idInstanceTimer)</td></tr>
<tr class="memdesc:a1e1ac72e3f463645e0419b054b8d4230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force next update of timer to stop without calling any intermediate callback (stop/start/elapsed)  <a href="sopc__interrupttimer_8h.html#a1e1ac72e3f463645e0419b054b8d4230">More...</a><br /></td></tr>
<tr class="separator:a1e1ac72e3f463645e0419b054b8d4230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83e31782caf45d508ea0fe77ea67cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#ab83e31782caf45d508ea0fe77ea67cb8">SOPC_InterruptTimer_Instance_Start</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t idInstanceTimer)</td></tr>
<tr class="memdesc:ab83e31782caf45d508ea0fe77ea67cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next update of timer instance will start it.  <a href="sopc__interrupttimer_8h.html#ab83e31782caf45d508ea0fe77ea67cb8">More...</a><br /></td></tr>
<tr class="separator:ab83e31782caf45d508ea0fe77ea67cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f87a05b7003ea0c4359cd908cfa167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#af5f87a05b7003ea0c4359cd908cfa167">SOPC_InterruptTimer_Instance_Stop</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t idInstanceTimer)</td></tr>
<tr class="memdesc:af5f87a05b7003ea0c4359cd908cfa167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next update of timer will stop it.  <a href="sopc__interrupttimer_8h.html#af5f87a05b7003ea0c4359cd908cfa167">More...</a><br /></td></tr>
<tr class="separator:af5f87a05b7003ea0c4359cd908cfa167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79407c31be6af3f6b8939aaa52141679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a79407c31be6af3f6b8939aaa52141679">SOPC_InterruptTimer_Instance_SetPeriod</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t idInstanceTimer, uint32_t period)</td></tr>
<tr class="memdesc:a79407c31be6af3f6b8939aaa52141679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next update of timer will set new period.  <a href="sopc__interrupttimer_8h.html#a79407c31be6af3f6b8939aaa52141679">More...</a><br /></td></tr>
<tr class="separator:a79407c31be6af3f6b8939aaa52141679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06b1bc1caa07a6834945965904530d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a9f06b1bc1caa07a6834945965904530d">SOPC_InterruptTimer_Instance_SetOffset</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t idInstanceTimer, uint32_t offset)</td></tr>
<tr class="memdesc:a9f06b1bc1caa07a6834945965904530d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next update of timer will set new offset.  <a href="sopc__interrupttimer_8h.html#a9f06b1bc1caa07a6834945965904530d">More...</a><br /></td></tr>
<tr class="separator:a9f06b1bc1caa07a6834945965904530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868c4044b6f349d05f5bd3373ee540fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a868c4044b6f349d05f5bd3373ee540fa">SOPC_InterruptTimer_Instance_SetCallback</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t idInstanceTimer, void *pUserContext, <a class="el" href="sopc__interrupttimer_8h.html#a047f14e59909a8212d4fb1f7726cf678">sopc_irq_timer_cb_start</a> cbStart, <a class="el" href="sopc__interrupttimer_8h.html#a232df064705c18c0d685e35c440a6927">sopc_irq_timer_cb_period_elapsed</a> cbElapsed, <a class="el" href="sopc__interrupttimer_8h.html#a9959439476932404cf326010fbda8cdb">sopc_irq_timer_cb_stop</a> cbStop)</td></tr>
<tr class="memdesc:a868c4044b6f349d05f5bd3373ee540fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next update of timer will set callback linked to start, stop, elapsed event.  <a href="sopc__interrupttimer_8h.html#a868c4044b6f349d05f5bd3373ee540fa">More...</a><br /></td></tr>
<tr class="separator:a868c4044b6f349d05f5bd3373ee540fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7bc18ae6383593a81701a95bf27998"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a4c7bc18ae6383593a81701a95bf27998">SOPC_InterruptTimer_Instance_SetData</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t idInstanceTimer, uint8_t *pData, uint32_t sizeToWrite)</td></tr>
<tr class="memdesc:a4c7bc18ae6383593a81701a95bf27998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish new data to the timer instance, take into account by next update call.  <a href="sopc__interrupttimer_8h.html#a4c7bc18ae6383593a81701a95bf27998">More...</a><br /></td></tr>
<tr class="separator:a4c7bc18ae6383593a81701a95bf27998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77760054f70e556ec3594feacdf0899e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a77760054f70e556ec3594feacdf0899e">SOPC_InterruptTimer_Instance_DataHandle_Create</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t idInstanceTimer)</td></tr>
<tr class="memdesc:a77760054f70e556ec3594feacdf0899e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create data handle for an interrupt timer workspace and one of its instances.  <a href="sopc__interrupttimer_8h.html#a77760054f70e556ec3594feacdf0899e">More...</a><br /></td></tr>
<tr class="separator:a77760054f70e556ec3594feacdf0899e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d7ff94606ef9c3dcb8a560d638e712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#ad8d7ff94606ef9c3dcb8a560d638e712">SOPC_InterruptTimer_DestroyDataContainer</a> (<a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> **ppDataContainer)</td></tr>
<tr class="memdesc:ad8d7ff94606ef9c3dcb8a560d638e712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy data handle.  <a href="sopc__interrupttimer_8h.html#ad8d7ff94606ef9c3dcb8a560d638e712">More...</a><br /></td></tr>
<tr class="separator:ad8d7ff94606ef9c3dcb8a560d638e712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a2f4c4bdae67bc76f73da82d890248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a33a2f4c4bdae67bc76f73da82d890248">SOPC_InterruptTimer_Instance_DataHandle_Initialize</a> (<a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> *pDataContainer)</td></tr>
<tr class="memdesc:a33a2f4c4bdae67bc76f73da82d890248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize data handle used to publish data.  <a href="sopc__interrupttimer_8h.html#a33a2f4c4bdae67bc76f73da82d890248">More...</a><br /></td></tr>
<tr class="separator:a33a2f4c4bdae67bc76f73da82d890248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd909f46b08bf38e39a8032d4b990d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#abd909f46b08bf38e39a8032d4b990d19">SOPC_InterruptTimer_Instance_DataHandle_GetBufferInfo</a> (<a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> *pContainer, uint32_t *pMaxAllowedSize, size_t *pCurrentSize, uint8_t **ppData)</td></tr>
<tr class="memdesc:abd909f46b08bf38e39a8032d4b990d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expose data handle buffer informations.  <a href="sopc__interrupttimer_8h.html#abd909f46b08bf38e39a8032d4b990d19">More...</a><br /></td></tr>
<tr class="separator:abd909f46b08bf38e39a8032d4b990d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb8b57c4808844cf454d5f09e40662f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#aceb8b57c4808844cf454d5f09e40662f">SOPC_InterruptTimer_Instance_DataHandle_SetNewSize</a> (<a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> *pContainer, size_t newSize)</td></tr>
<tr class="memdesc:aceb8b57c4808844cf454d5f09e40662f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update data handle size with newSize parameter.  <a href="sopc__interrupttimer_8h.html#aceb8b57c4808844cf454d5f09e40662f">More...</a><br /></td></tr>
<tr class="separator:aceb8b57c4808844cf454d5f09e40662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9d5239035fd4be2f6d810486292928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#a1f9d5239035fd4be2f6d810486292928">SOPC_InterruptTimer_Instance_DataHandle_Finalize</a> (<a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> *pDataContainer, bool bCancel)</td></tr>
<tr class="memdesc:a1f9d5239035fd4be2f6d810486292928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit data container with new data and its new size.  <a href="sopc__interrupttimer_8h.html#a1f9d5239035fd4be2f6d810486292928">More...</a><br /></td></tr>
<tr class="separator:a1f9d5239035fd4be2f6d810486292928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b7f668236ab0626aff812e3afa9d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#ad2b7f668236ab0626aff812e3afa9d25">SOPC_InterruptTimer_Instance_LastStatus</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t idInstanceTimer, <a class="el" href="sopc__interrupttimer_8h.html#afc0c1002e9a4344f873e87f504a47f91">SOPC_IrqTimer_InstanceStatus</a> *status)</td></tr>
<tr class="memdesc:ad2b7f668236ab0626aff812e3afa9d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a timer instance status : started or stopped.  <a href="sopc__interrupttimer_8h.html#ad2b7f668236ab0626aff812e3afa9d25">More...</a><br /></td></tr>
<tr class="separator:ad2b7f668236ab0626aff812e3afa9d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa570e949af70228936297d6216728d15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sopc__interrupttimer_8h.html#aa570e949af70228936297d6216728d15">SOPC_InterruptTimer_Update</a> (<a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *pTimer, uint32_t externalTickValue)</td></tr>
<tr class="memdesc:aa570e949af70228936297d6216728d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update timer tick with external tick value. Invoke callback if necessary.  <a href="sopc__interrupttimer_8h.html#aa570e949af70228936297d6216728d15">More...</a><br /></td></tr>
<tr class="separator:aa570e949af70228936297d6216728d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interrupt timer, called from interrupt, used by <a class="el" href="sopc__rt__publisher_8h.html#addbde8a0ebf5397b378a456a097a84f1" title="RT Publisher handle.">SOPC_RT_Publisher</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="af3d1c424ce9ac4a5852a3f4a01f4ec68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d1c424ce9ac4a5852a3f4a01f4ec68">&#9670;&nbsp;</a></span>SOPC_InterruptTimer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> <a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle of an interrupt timer workspace. For one interrupt timer workspace, several timer instances can be instantiated, Created by SOPC_InterruptTimer_Create, then used as following steps: </p>
<ul>
<li>Initialize an instance by SOPC_InterruptTimer_Initialize (period, callback called on elapsed period...)</li>
<li>Publish new data to the instance by SOPC_InterruptTimer_SetData</li>
</ul>
<p>The function SOPC_InterruptTimer_Update shall be called from periodic process or interrupt. </p>

</div>
</div>
<a id="af03a8e59d25790a196c45f25ba63fcea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03a8e59d25790a196c45f25ba63fcea">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_DataHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> <a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle of a interrupt timer data container. This handle is used if you want work directly with buffer of an interrupt timer instance. The buffer is externally exposed by this handle, linked to a SOPC_InterruptTimer + timer instance identifier. Created by SOPC_InterruptTimer_DataHandle_Create, which links it to one workspace and one instance, then those steps shall be followed to publish data: </p>
<ul>
<li>Initialized by SOPC_InterruptTimer_DataHandle_Initialize.</li>
<li>Used by SOPC_InterruptTimer_DataHandle_GetBufferInfo and SOPC_InterruptTimer_DataHandle_SetNewSize</li>
<li>Modification committed by SOPC_InterruptTimer_DataHandle_Finalize. </li>
</ul>

</div>
</div>
<a id="a047f14e59909a8212d4fb1f7726cf678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047f14e59909a8212d4fb1f7726cf678">&#9670;&nbsp;</a></span>sopc_irq_timer_cb_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sopc_irq_timer_cb_start) (uint32_t timerId, void *pUserContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start callback, called when timer switch from DISABLED to ENABLED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timerId</td><td>Timer instance identifier, Between 0 and number of possible instance configured by SOPC_IniterruptTimer_Initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pUserContext</td><td>User context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9959439476932404cf326010fbda8cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9959439476932404cf326010fbda8cdb">&#9670;&nbsp;</a></span>sopc_irq_timer_cb_stop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sopc_irq_timer_cb_stop) (uint32_t timerId, void *pUserContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop callback, called when timer switch from ENABLED to DISABLED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timerId</td><td>Timer instance identifier. Between 0 and number of possible instance configured by SOPC_IniterruptTimer_Initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pUserContext</td><td>User context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a232df064705c18c0d685e35c440a6927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232df064705c18c0d685e35c440a6927">&#9670;&nbsp;</a></span>sopc_irq_timer_cb_period_elapsed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sopc_irq_timer_cb_period_elapsed) (uint32_t timerId, void *pUserContext, void *pData, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elapsed callback, called when timer reach its configured period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timerId</td><td>Timer instance identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pUserContext</td><td>User context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Data published by SOPC_InterruptTimer_Instance_SetData </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data</td><td>size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afc0c1002e9a4344f873e87f504a47f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0c1002e9a4344f873e87f504a47f91">&#9670;&nbsp;</a></span>SOPC_IrqTimer_InstanceStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sopc__interrupttimer_8h.html#afc0c1002e9a4344f873e87f504a47f91">SOPC_IrqTimer_InstanceStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status of a timer instance. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afc0c1002e9a4344f873e87f504a47f91a3313e746338ff5bad5771b32c1af9bee"></a>SOPC_INTERRUPT_TIMER_STATUS_DISABLED&#160;</td><td class="fielddoc"><p>Timer instance is stopped. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc0c1002e9a4344f873e87f504a47f91afe149834fcdaa93d05ebd9ef550ace03"></a>SOPC_INTERRUPT_TIMER_STATUS_ENABLED&#160;</td><td class="fielddoc"><p>Timer instance is started. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc0c1002e9a4344f873e87f504a47f91a4ea7dba76832b41a913f571e024084c3"></a>SOPC_INTERRUPT_TIMER_STATUS_INVALID&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3fd6f9e08eda65d37e3592d5b877ff09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd6f9e08eda65d37e3592d5b877ff09">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a>* SOPC_InterruptTimer_Create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interrupt timer. This function shall be followed by initialize function to use the timer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not thread safe! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns pointer on SOPC_InterruptTimer. </dd></dl>

</div>
</div>
<a id="abb4361e0c3da18b6df9c610f44c54a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4361e0c3da18b6df9c610f44c54a47">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SOPC_InterruptTimer_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> **&#160;</td>
          <td class="paramname"><em>ppTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy interrupt timer. This function shall be called only if SOPC_InterruptTimer_DeInitialize returns SOPC_STATUS_OK. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not thread safe! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppTimer</td><td>Address from where SOPC_InterruptTimer object will be deleted. Set to NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae86232fe915bd463e0e983534cca11ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86232fe915bd463e0e983534cca11ac">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nbInstances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxInstanceDataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize interrupt timer workspace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbInstances</td><td>Maximum of timer instances (timer identifiers will be between 0 and nbInstances - 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxInstanceDataSize</td><td>Maximum of data in bytes hold by each timer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if interrupt timer is in use, initializing or resetting state. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="acd3ad68d8b611c29388fec3ade42826e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3ad68d8b611c29388fec3ade42826e">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_DeInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_DeInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DeInitialize interrupt timer workspace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if interrupt timer is in other state that initialized (in use, resetting, </dd>
<dd>
initializing). SOPC_STATUS_NOK for others error or already not initialized. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="acd9c197034a70e3c312843b480af64a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9c197034a70e3c312843b480af64a6">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idInstanceTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#a047f14e59909a8212d4fb1f7726cf678">sopc_irq_timer_cb_start</a>&#160;</td>
          <td class="paramname"><em>cbStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#a232df064705c18c0d685e35c440a6927">sopc_irq_timer_cb_period_elapsed</a>&#160;</td>
          <td class="paramname"><em>cbElapsed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#a9959439476932404cf326010fbda8cdb">sopc_irq_timer_cb_stop</a>&#160;</td>
          <td class="paramname"><em>cbStop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#afc0c1002e9a4344f873e87f504a47f91">SOPC_IrqTimer_InstanceStatus</a>&#160;</td>
          <td class="paramname"><em>initStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset timer instance and initialize it on next SOPC_InterruptTimer_Update call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idInstanceTimer</td><td>Interrupt timer instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>Timer period (tick) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Timer offset (tick) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pUserContext</td><td>Use context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbStart</td><td>Start event callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbElapsed</td><td>Elapsed event callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbStop</td><td>Stop event callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initStatus</td><td>Initial status, set STARTED or STOPPED status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="a1e1ac72e3f463645e0419b054b8d4230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1ac72e3f463645e0419b054b8d4230">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idInstanceTimer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force next update of timer to stop without calling any intermediate callback (stop/start/elapsed) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idInstanceTimer</td><td>Interrupt timer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="ab83e31782caf45d508ea0fe77ea67cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83e31782caf45d508ea0fe77ea67cb8">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idInstanceTimer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next update of timer instance will start it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idInstanceTimer</td><td>Interrupt timer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="af5f87a05b7003ea0c4359cd908cfa167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f87a05b7003ea0c4359cd908cfa167">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idInstanceTimer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next update of timer will stop it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idInstanceTimer</td><td>Interrupt timer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="a79407c31be6af3f6b8939aaa52141679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79407c31be6af3f6b8939aaa52141679">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_SetPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_SetPeriod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idInstanceTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next update of timer will set new period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idInstanceTimer</td><td>Interrupt timer instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>Period in ticks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="a9f06b1bc1caa07a6834945965904530d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f06b1bc1caa07a6834945965904530d">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_SetOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_SetOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idInstanceTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next update of timer will set new offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idInstanceTimer</td><td>Interrupt timer instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in ticks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="a868c4044b6f349d05f5bd3373ee540fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868c4044b6f349d05f5bd3373ee540fa">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_SetCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_SetCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idInstanceTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#a047f14e59909a8212d4fb1f7726cf678">sopc_irq_timer_cb_start</a>&#160;</td>
          <td class="paramname"><em>cbStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#a232df064705c18c0d685e35c440a6927">sopc_irq_timer_cb_period_elapsed</a>&#160;</td>
          <td class="paramname"><em>cbElapsed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#a9959439476932404cf326010fbda8cdb">sopc_irq_timer_cb_stop</a>&#160;</td>
          <td class="paramname"><em>cbStop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next update of timer will set callback linked to start, stop, elapsed event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idInstanceTimer</td><td>Interrupt timer instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pUserContext</td><td>Use context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbStart</td><td>Callback called when timer is started </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbElapsed</td><td>Callback called when timer is elapsed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbStop</td><td>Callback called when timer is stopped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="a4c7bc18ae6383593a81701a95bf27998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7bc18ae6383593a81701a95bf27998">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_SetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_SetData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idInstanceTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sizeToWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish new data to the timer instance, take into account by next update call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idInstanceTimer</td><td>Timer instance identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Data to publish </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeToWrite</td><td>Data size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="a77760054f70e556ec3594feacdf0899e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77760054f70e556ec3594feacdf0899e">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_DataHandle_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a>* SOPC_InterruptTimer_Instance_DataHandle_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idInstanceTimer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create data handle for an interrupt timer workspace and one of its instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idInstanceTimer</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_InterruptTimer_DataHandle object </dd></dl>

</div>
</div>
<a id="ad8d7ff94606ef9c3dcb8a560d638e712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d7ff94606ef9c3dcb8a560d638e712">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_DestroyDataContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SOPC_InterruptTimer_DestroyDataContainer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> **&#160;</td>
          <td class="paramname"><em>ppDataContainer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy data handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppDataContainer</td><td>Address where Interrupt timer data handle shall be destroyed. Set to NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33a2f4c4bdae67bc76f73da82d890248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a2f4c4bdae67bc76f73da82d890248">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_DataHandle_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_DataHandle_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> *&#160;</td>
          <td class="paramname"><em>pDataContainer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize data handle used to publish data. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function shall be called before GetBufferInfo and SetNewSize </dd>
<dd>
After modification, SOPC_InterruptTimer_DataHandle_Finalize shall be called in order to take into account new data with new size </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDataContainer</td><td>Interrupt timer data handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="abd909f46b08bf38e39a8032d4b990d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd909f46b08bf38e39a8032d4b990d19">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_DataHandle_GetBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_DataHandle_GetBufferInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> *&#160;</td>
          <td class="paramname"><em>pContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pMaxAllowedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pCurrentSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>ppData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expose data handle buffer informations. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function shall be used between SOPC_InterruptTimer_Instance_DataHandle_Initialize and SOPC_InterruptTimer_Instance_DataHandle_Finalize </dd>
<dd>
User becomes the "owner" of the exposed data. He doesn't shall write above *pMaxAllowedSize. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pContainer</td><td>Interrupt timer instance data handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pMaxAllowedSize</td><td>Function returns max allowed size of returned exposed buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pCurrentSize</td><td>Function returns current significant bytes present in the returned exposed buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppData</td><td>Address where is returned pointer on exposed buffer. Do not free this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK in case of success. </dd></dl>

</div>
</div>
<a id="aceb8b57c4808844cf454d5f09e40662f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb8b57c4808844cf454d5f09e40662f">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_DataHandle_SetNewSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_DataHandle_SetNewSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> *&#160;</td>
          <td class="paramname"><em>pContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update data handle size with newSize parameter. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function shall be used between SOPC_InterruptTimer_Instance_DataHandle_Initialize and SOPC_InterruptTimer_Instance_DataHandle_Finalize </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pContainer</td><td>Interrupt timer instance data handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newSize</td><td>Significant bytes to take into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_OK in case of success. </dd>
<dd>
SOPC_INVALID_PARAMETERS if newSize &gt; max allowed size returned by SOPC_InterruptTimer_Instance_DataHandle_GetBufferInfo </dd></dl>

</div>
</div>
<a id="a1f9d5239035fd4be2f6d810486292928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9d5239035fd4be2f6d810486292928">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_DataHandle_Finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_DataHandle_Finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af03a8e59d25790a196c45f25ba63fcea">SOPC_InterruptTimer_DataHandle</a> *&#160;</td>
          <td class="paramname"><em>pDataContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCancel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit data container with new data and its new size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDataContainer</td><td>Interrupt timer instance data handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bCancel</td><td>Modification canceled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="ad2b7f668236ab0626aff812e3afa9d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b7f668236ab0626aff812e3afa9d25">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Instance_LastStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Instance_LastStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idInstanceTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#afc0c1002e9a4344f873e87f504a47f91">SOPC_IrqTimer_InstanceStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a timer instance status : started or stopped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idInstanceTimer</td><td>Interrupt timer instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Address where is returned timer instance status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
<a id="aa570e949af70228936297d6216728d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa570e949af70228936297d6216728d15">&#9670;&nbsp;</a></span>SOPC_InterruptTimer_Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libs2opc__client_8h.html#a8419f6ec9e9cf6f33b24806124972652">SOPC_ReturnStatus</a> SOPC_InterruptTimer_Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sopc__interrupttimer_8h.html#af3d1c424ce9ac4a5852a3f4a01f4ec68">SOPC_InterruptTimer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>externalTickValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update timer tick with external tick value. Invoke callback if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimer</td><td>Interrupt timer workspace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalTickValue</td><td>value. Shall be always incremented. Internally, tick value is declared as uint64_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOPC_STATUS_INVALID_STATE if workspace is not initialized or API for this instance is currently in use. </dd>
<dd>
SOPC_STATUS_NOK for others error. Else SOPC_STATUS_OK. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 7 2021 09:35:46 for S2OPC OPCUA Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
