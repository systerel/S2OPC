/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef SOPC_BUILTINTYPES_H_
#define SOPC_BUILTINTYPES_H_

#include <stdbool.h>
#include <stdint.h>
#include <time.h>

#include "sopc_dict.h"
#include "sopc_encodeabletype.h"
#include "sopc_enums.h"
#include "sopc_numeric_range.h"
#include "sopc_singly_linked_list.h"

// s2opc_common_export.h is generated by CMake, when not using CMake, copy and include
// "src/Common/helpers_platform_dep/<platform>/s2opc_common_export.h_"
#include "s2opc_common_export.h"

typedef uint32_t SOPC_StatusCode;

/**
 * \brief A generic Good status code
 */
#define SOPC_GoodGenericStatus 0x00000000

/**
 * \brief An opposite mask for Good status code: Good status <=> (status & SOPC_GoodStatusOppositeMask) == 0
 */
#define SOPC_GoodStatusOppositeMask 0xC0000000

/**
 * \brief Evaluates if the provided status is Good.
 *
 * \param status  The status to evaluate
 * \return        True if the provided status is Good, false otherwise
 */
bool SOPC_IsGoodStatus(SOPC_StatusCode status);

/**
 * \brief Masks to check status for Uncertain/Bad/Reserved status code: X status <=> (status & SOPC_<X>StatusMask) != 0
 */
#define SOPC_UncertainStatusMask 0x40000000
#define SOPC_BadStatusMask 0x80000000

/**
 * \brief Mask to check status contains the DataValue overflow bit set (InfoType DataValue bit + Overflow bit)
 */
#define SOPC_DataValueOverflowStatusMask 0x00000480

/**
 * \brief Enumerated for all possible OPC UA attribute ids
 */
typedef enum
{
    SOPC_AttributeId_Invalid = 0,
    SOPC_AttributeId_NodeId = 1,
    SOPC_AttributeId_NodeClass = 2,
    SOPC_AttributeId_BrowseName = 3,
    SOPC_AttributeId_DisplayName = 4,
    SOPC_AttributeId_Description = 5,
    SOPC_AttributeId_WriteMask = 6,
    SOPC_AttributeId_UserWriteMask = 7,
    SOPC_AttributeId_IsAbstract = 8,
    SOPC_AttributeId_Symmetric = 9,
    SOPC_AttributeId_InverseName = 10,
    SOPC_AttributeId_ContainsNoLoops = 11,
    SOPC_AttributeId_EventNotifier = 12,
    SOPC_AttributeId_Value = 13,
    SOPC_AttributeId_DataType = 14,
    SOPC_AttributeId_ValueRank = 15,
    SOPC_AttributeId_ArrayDimensions = 16,
    SOPC_AttributeId_AccessLevel = 17,
    SOPC_AttributeId_UserAccessLevel = 18,
    SOPC_AttributeId_MinimumSamplingInterval = 19,
    SOPC_AttributeId_Historizing = 20,
    SOPC_AttributeId_Executable = 21,
    SOPC_AttributeId_UserExecutable = 22,
    SOPC_AttributeId_DataTypeDefinition = 23,
    SOPC_AttributeId_RolePermissions = 24,
    SOPC_AttributeId_UserRolePermissions = 25,
    SOPC_AttributeId_AccessRestrictions = 26,
    SOPC_AttributeId_AccessLevelEx = 27,
} SOPC_AttributeId;

/**
 * \brief Restricts and converts the status code to the only status code authorized for TCP error code
 */
SOPC_StatusCode SOPC_StatusCode_ToTcpErrorCode(SOPC_StatusCode status);

typedef enum SOPC_BuiltinId
{
    SOPC_Null_Id = 0,
    SOPC_Boolean_Id = 1,
    SOPC_SByte_Id = 2,
    SOPC_Byte_Id = 3,
    SOPC_Int16_Id = 4,
    SOPC_UInt16_Id = 5,
    SOPC_Int32_Id = 6,
    SOPC_UInt32_Id = 7,
    SOPC_Int64_Id = 8,
    SOPC_UInt64_Id = 9,
    SOPC_Float_Id = 10,
    SOPC_Double_Id = 11,
    SOPC_String_Id = 12,
    SOPC_DateTime_Id = 13,
    SOPC_Guid_Id = 14,
    SOPC_ByteString_Id = 15,
    SOPC_XmlElement_Id = 16,
    SOPC_NodeId_Id = 17,
    SOPC_ExpandedNodeId_Id = 18,
    SOPC_StatusCode_Id = 19,
    SOPC_QualifiedName_Id = 20,
    SOPC_LocalizedText_Id = 21,
    SOPC_ExtensionObject_Id = 22,
    SOPC_DataValue_Id = 23,
    SOPC_Variant_Id = 24,
    SOPC_DiagnosticInfo_Id = 25
} SOPC_BuiltinId;
#define SOPC_BUILTINID_MAX 25

typedef uint8_t SOPC_Byte;

typedef SOPC_Byte SOPC_Boolean;

typedef int8_t SOPC_SByte;

/**
 *  \brief This structure provides string encapsulation
 */
typedef struct SOPC_String
{
    int32_t Length;
    bool DoNotClear; // flag indicating if bytes must be freed
    SOPC_Byte* Data; // Consider as <em>const SOPC_Byte*</em> if DoNotClear is set
} SOPC_String;

typedef SOPC_String SOPC_XmlElement;
typedef SOPC_String SOPC_ByteString;

typedef int64_t SOPC_DateTime;

typedef struct SOPC_Guid
{
    /* Reproduces the specification memory format:
     * - Data1 to Data3 are local-endian
     * - Data4 is big endian and spans across the 16 last digits.
     */
    uint32_t Data1;
    uint16_t Data2;
    uint16_t Data3;
    SOPC_Byte Data4[8];
} SOPC_Guid;

/**
 *  \brief This enum provides fundamental identifier type
 */
typedef enum SOPC_IdentifierType
{
    SOPC_IdentifierType_Numeric = 0x00,
    SOPC_IdentifierType_String = 0x01,
    SOPC_IdentifierType_Guid = 0x02,
    SOPC_IdentifierType_ByteString = 0x03,
} SOPC_IdentifierType;

/**
 *  \brief This structure describes a basic NodeID in OPC UA
 */
typedef struct SOPC_NodeId
{
    SOPC_IdentifierType IdentifierType;
    uint16_t Namespace;

    union {
        uint32_t Numeric;
        SOPC_String String;
        SOPC_Guid* Guid;
        SOPC_ByteString Bstring;
    } Data;
} SOPC_NodeId;

/**
 *  \brief ExpandedNodeId allows the namespace to be specified explicitly as a string
 *  or with an index in the Serverâ€™s namespace table.
 */
typedef struct SOPC_ExpandedNodeId
{
    SOPC_NodeId NodeId;
    SOPC_String NamespaceUri;
    uint32_t ServerIndex;
} SOPC_ExpandedNodeId;

/**
 *  \brief This structure provides vendor specific diagnostic information
 */
typedef struct SOPC_DiagnosticInfo
{
    int32_t SymbolicId;
    int32_t NamespaceUri;
    int32_t Locale;
    int32_t LocalizedText;
    SOPC_String AdditionalInfo;
    SOPC_StatusCode InnerStatusCode;
    struct SOPC_DiagnosticInfo* InnerDiagnosticInfo;
} SOPC_DiagnosticInfo;

typedef struct SOPC_QualifiedName
{
    uint16_t NamespaceIndex;
    SOPC_String Name;
} SOPC_QualifiedName;

typedef struct SOPC_LocalizedText
{
    /* The default locale shall be stored only here and not in the list.
     * It is the only one encoded / decoded for SOPC_LocalizedText structure. */
    SOPC_String defaultLocale;
    SOPC_String defaultText;

    /* This field is only used on SERVER side for toolkit configuration structures (OpcUa_ApplicationDescription)
     * or for node values (of type localized text) in the address space to store several locales.
     * On CLIENT side this field is always NULL and shall be ignored. */
    SOPC_SLinkedList* localizedTextList; // If NULL => no other localized text defined
} SOPC_LocalizedText;

/**
 *  \brief This enum provides additional information on which data type format transported.
 */
typedef enum SOPC_ExtObjectBodyEncoding
{
    SOPC_ExtObjBodyEncoding_None = 0x00,
    SOPC_ExtObjBodyEncoding_ByteString = 0x01,
    SOPC_ExtObjBodyEncoding_XMLElement = 0x02,
    SOPC_ExtObjBodyEncoding_Object = 0x03
} SOPC_ExtObjectBodyEncoding;

/**
 *  \brief An ExtensionObject is a container for any Structured DataTypes which cannot be encoded as one of the other
 * built-in data types. it contains fields that describes which data is transported and how it is described.
 */
typedef struct SOPC_ExtensionObject
{
    SOPC_ExpandedNodeId TypeId;
    SOPC_ExtObjectBodyEncoding Encoding;

    union {
        SOPC_ByteString Bstring;
        SOPC_XmlElement Xml;
        struct
        {
            void* Value;
            SOPC_EncodeableType* ObjType;
        } Object;

    } Body;

    int32_t Length;

} SOPC_ExtensionObject;

typedef enum SOPC_VariantArrayTypeFlag
{
    SOPC_VariantArrayValueFlag = 128,    // 2^7 => bit 7
    SOPC_VariantArrayDimensionsFlag = 64 // 2^6 => bit 6
} SOPC_VariantArrayTypeFlag;

// Binary compatible types
typedef enum SOPC_VariantArrayType
{
    SOPC_VariantArrayType_SingleValue = 0x0,
    SOPC_VariantArrayType_Array = 0x1,
    SOPC_VariantArrayType_Matrix = 0x2
} SOPC_VariantArrayType;

/**
 *  \brief This union provides all possible contents for Variant arrays, depending on their \a SOPC_BuiltinId.
 */
typedef union SOPC_VariantArrayValue {
    SOPC_Boolean* BooleanArr;
    SOPC_SByte* SbyteArr;
    SOPC_Byte* ByteArr;
    int16_t* Int16Arr;
    uint16_t* Uint16Arr;
    int32_t* Int32Arr;
    uint32_t* Uint32Arr;
    int64_t* Int64Arr;
    uint64_t* Uint64Arr;
    float* FloatvArr;
    double* DoublevArr;
    SOPC_String* StringArr;
    SOPC_DateTime* DateArr;
    SOPC_Guid* GuidArr;
    SOPC_ByteString* BstringArr;
    SOPC_XmlElement* XmlEltArr;
    SOPC_NodeId* NodeIdArr;
    SOPC_ExpandedNodeId* ExpNodeIdArr;
    SOPC_StatusCode* StatusArr;
    SOPC_QualifiedName* QnameArr;
    SOPC_LocalizedText* LocalizedTextArr;
    SOPC_ExtensionObject* ExtObjectArr;
    struct SOPC_DataValue* DataValueArr;
    struct SOPC_Variant* VariantArr;
    SOPC_DiagnosticInfo* DiagInfoArr; // TODO: not present ?
} SOPC_VariantArrayValue;

/**
 *  \brief This union provides all possible contents for Variant, depending on their \a SOPC_BuiltinId.
 */
typedef union SOPC_VariantValue {
    SOPC_Boolean Boolean;
    SOPC_SByte Sbyte;
    SOPC_Byte Byte;
    int16_t Int16;
    uint16_t Uint16;
    int32_t Int32;
    uint32_t Uint32;
    int64_t Int64;
    uint64_t Uint64;
    float Floatv;
    double Doublev;
    SOPC_String String;
    SOPC_DateTime Date;
    SOPC_Guid* Guid;
    SOPC_ByteString Bstring;
    SOPC_XmlElement XmlElt;
    SOPC_NodeId* NodeId;
    SOPC_ExpandedNodeId* ExpNodeId;
    SOPC_StatusCode Status;
    SOPC_QualifiedName* Qname;
    SOPC_LocalizedText* LocalizedText;
    SOPC_ExtensionObject* ExtObject;
    struct SOPC_DataValue* DataValue;
    SOPC_DiagnosticInfo* DiagInfo; // TODO: not present ?
    struct
    {
        int32_t Length;
        SOPC_VariantArrayValue Content;
    } Array;
    struct
    {
        int32_t Dimensions;
        int32_t*
            ArrayDimensions; // Product of dimensions must be <= INT32_MAX ! (binary arrayLength valid for matrix too)
        SOPC_VariantArrayValue Content;
    } Matrix;

} SOPC_VariantValue;

/**
 *  \brief This structure provides variant encapsulation
 */
typedef struct SOPC_Variant
{
    bool DoNotClear; // flag indicating if variant content must be freed
    SOPC_BuiltinId BuiltInTypeId;
    SOPC_VariantArrayType ArrayType;
    SOPC_VariantValue Value;
} SOPC_Variant;

/**
 *  \brief Each attribute in OPC UA has a DataValue caracterized by the following structure
 */
typedef struct SOPC_DataValue
{
    SOPC_Variant Value;
    SOPC_StatusCode Status;
    SOPC_DateTime SourceTimestamp; // 100 nanoseconds
    SOPC_DateTime ServerTimestamp; // 100 nanoseconds
    uint16_t SourcePicoSeconds;    // 10 picoseconds
    uint16_t ServerPicoSeconds;    // 10 picoseconds
} SOPC_DataValue;

S2OPC_COMMON_EXPORT extern const SOPC_NodeId* SOPC_BuiltInTypeId_To_DataTypeNodeId[26];

#define SECURITY_POLICY_NONE "http://opcfoundation.org/UA/SecurityPolicy#None"
#define SECURITY_POLICY_BASIC128RSA15 "http://opcfoundation.org/UA/SecurityPolicy#Basic128Rsa15"
#define SECURITY_POLICY_BASIC256 "http://opcfoundation.org/UA/SecurityPolicy#Basic256"
#define SECURITY_POLICY_BASIC256SHA256 "http://opcfoundation.org/UA/SecurityPolicy#Basic256Sha256"

/**** BOOLEAN ****/
/**
 * \note The functions which have prototype as : \p SOPC_BUILTINTYPE_Initialize() will get the
 *  same description.
 *
 * \warning This kind of function must be used to prevent indeterminist behavior for any builtintypes.
 *
 * \brief Initialize a pointer for a specific builtintype (Boolean, String, Int16...)
 *
 * \param b  The pointer related to the specific builtintype will be initialized to "0".
 */
void SOPC_Boolean_Initialize(SOPC_Boolean* b);

/**
 * \note The functions which have prototype as: \p SOPC_BUILTINTYPE_InitializeAux() will get the
 *  same description.
 * \brief Initialize a generic pointer using cast method.
 *
 * \param value  The pointer will be initialized to "0".
 */
void SOPC_Boolean_InitializeAux(void* value);

/**
 * \note The functions which have prototype as : \p SOPC_BUILTINTYPE_CopyAux() will get the
 *  same description.
 *
 * \brief Copy the content of a generic pointer to another one.
 *
 * \param dest a generic pointer that will be casted in <em>specific builtintype pointer</em> to receive \p src content.
 *
 * \param src a generic pointer that will be casted in <em>specific builtintype pointer</em> and its content will be
 * copied in \p dest.
 *
 * \return SOPC_STATUS_OK in case of success, otherwise SOPC_STATUS_INVALID_PARAMETERS
 */
SOPC_ReturnStatus SOPC_Boolean_CopyAux(void* dest, const void* src);

/**
 * \note The functions which have prototype as : \p SOPC_BUILTINTYPE_CompareAux() will get the
 *  same description.
 * \brief Compare the content of a generic pointer to another one and set the result in the comparison parameter.
 *
 * \param left a generic pointer that will be casted in <em>specific builtintype pointer</em>
 *
 * \param right a generic pointer that will be casted in <em>specific builtintype pointer</em>
 *
 * \param comparison these possible values are:
 *                      * 1 : left pointer < right pointer
 *                      * 0 : left pointer == right pointer
 *                      * -1 : right pointer < left pointer
 *
 * \return SOPC_STATUS_OK in case of success, otherwise SOPC_STATUS_INVALID_PARAMETERS
 */
SOPC_ReturnStatus SOPC_Boolean_CompareAux(const void* left, const void* right, int32_t* comparison);
/**
 * \note The functions which have prototype as : \p SOPC_BUILTINTYPE_Clear() will get the
 *  same description.
 *
 * \brief Clear the content of a specific builtintype pointer.
 *
 * \param b The specific builtintype pointer content will be cleared to  \a "0,false,Free": depending on if
 *  it is a String, Boolean, integer, etc.
 */
void SOPC_Boolean_Clear(SOPC_Boolean* b);

/**
 * \note The functions which have prototype as : \p SOPC_BUILTINTYPE_ClearAux() will get the
 *  same description.
 *
 * \brief Clear the content of a generic pointer.
 *
 * \param value The generic pointer content will be casted in <em>specific builtintype pointer</em>
 *  and its content will be cleared to  \a "0,false,Free" depending on if it is a String, Boolean, integer, etc.
 */
void SOPC_Boolean_ClearAux(void* value);

/**** SByte ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_SByte_Initialize(SOPC_SByte* sbyte);
void SOPC_SByte_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_SByte_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_SByte_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_SByte_Clear(SOPC_SByte* sbyte);
void SOPC_SByte_ClearAux(void* value);

/**** Byte ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_Byte_Initialize(SOPC_Byte* byte);
void SOPC_Byte_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_Byte_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_Byte_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_Byte_Clear(SOPC_Byte* byte);
void SOPC_Byte_ClearAux(void* value);

/**** Int16 ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_Int16_Initialize(int16_t* intv);
void SOPC_Int16_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_Int16_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_Int16_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_Int16_Clear(int16_t* intv);
void SOPC_Int16_ClearAux(void* value);

/**** UInt16 ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_UInt16_Initialize(uint16_t* uint);
void SOPC_UInt16_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_UInt16_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_UInt16_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_UInt16_Clear(uint16_t* uint);
void SOPC_UInt16_ClearAux(void* value);

/**** Int32 ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_Int32_Initialize(int32_t* intv);
void SOPC_Int32_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_Int32_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_Int32_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_Int32_Clear(int32_t* intv);
void SOPC_Int32_ClearAux(void* value);

/**** UInt32 ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_UInt32_Initialize(uint32_t* uint);
void SOPC_UInt32_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_UInt32_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_UInt32_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_UInt32_Clear(uint32_t* uint);
void SOPC_UInt32_ClearAux(void* value);

/**** Int64 ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_Int64_Initialize(int64_t* intv);
void SOPC_Int64_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_Int64_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_Int64_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_Int64_Clear(int64_t* intv);
void SOPC_Int64_ClearAux(void* value);

/**** UInt64 ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_UInt64_Initialize(uint64_t* uint);
void SOPC_UInt64_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_UInt64_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_UInt64_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_UInt64_Clear(uint64_t* uint);
void SOPC_UInt64_ClearAux(void* value);

/**** Float ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_Float_Initialize(float* f);
void SOPC_Float_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_Float_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_Float_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_Float_Clear(float* f);
void SOPC_Float_ClearAux(void* value);

/**** Double ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_Double_Initialize(double* d);
void SOPC_Double_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_Double_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_Double_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_Double_Clear(double* d);
void SOPC_Double_ClearAux(void* value);

/**** ByteString ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_ByteString_Initialize(SOPC_ByteString* bstring);
void SOPC_ByteString_InitializeAux(void* value);

/**
 * \note The functions which have prototype as : \p SOPC_BUILTINTYPE_Create() will get the
 *  same description.
 *
 * \warning This kind of function do x-bytes of allocation memory, so the pointer must be freed by invoking
 * \p SOPC_BUILTINTYPE_Delete() function.
 *
 * \brief Create a valid specific builtintype pointer.
 *
 * \return A valid pointer otherwise it returns NULL pointer if allocation failed.
 */
SOPC_ByteString* SOPC_ByteString_Create(void);

/**
 * \warning This function do x-bytes of allocation memory, so the pointer must be freed by invoking
 * \p SOPC_ByteString_Delete() function.
 *
 * \brief Allocate a number of \p size bytes and initialize its content to "0", this allocation looks like calloc
 * function.
 *
 * \param bstring The ByteString pointer which will be initialized.
 *
 * \param size number of bytes to be allocate.
 *
 * \return A valid pointer otherwise it returns NULL pointer if allocation failed.
 */
SOPC_ReturnStatus SOPC_ByteString_InitializeFixedSize(SOPC_ByteString* bstring, uint32_t size);

/**
 * \brief Return a deep copy of a Byte array.
 * \param[out] dest Must be a non-NULL pointer to an uninitialized ByteString. Do not use an already allocated string
 *      or this will lead to a memory leak.
 * \param bytes A pointer to at least \a length bytes. (Can contain zeros)
 * \param length The number of bytes to copy.
 */
SOPC_ReturnStatus SOPC_ByteString_CopyFromBytes(SOPC_ByteString* dest, const SOPC_Byte* bytes, int32_t length);

/** \brief Return a deep copy of another ByteString. See SOPC_ByteString_CopyFromBytes */
SOPC_ReturnStatus SOPC_ByteString_Copy(SOPC_ByteString* dest, const SOPC_ByteString* src);
/** \see SOPC_ByteString_Copy */
SOPC_ReturnStatus SOPC_ByteString_CopyAux(void* dest, const void* src);
/** \see SOPC_Boolean_Clear */
void SOPC_ByteString_Clear(SOPC_ByteString* bstring);
/** \see SOPC_Boolean_ClearAux */
void SOPC_ByteString_ClearAux(void* value);

/**
 * \note The functions which have prototype as : \p SOPC_BUILTINTYPE_Delete() will get the
 *  same description.
 *
 * \warning This kind of function frees the memory used, so each \p SOPC_BUILTINTYPE_Create() function
 * need to call \p SOPC_BUILTINTYPE_Delete() function to avoid <em>leak memory or segmentation fault error</em>.
 * \brief Free a specific builtintype pointer thus it will transform it into an invalid pointer.
 * \param bstring The specific builtintype pointer that will be freed.
 *
 */
void SOPC_ByteString_Delete(SOPC_ByteString* bstring);

/** \see description in similar function SOPC_Boolean_CompareAux */
SOPC_ReturnStatus SOPC_ByteString_Compare(const SOPC_ByteString* left,
                                          const SOPC_ByteString* right,
                                          int32_t* comparison);
/** \see description in similar function SOPC_Boolean_CompareAux */
SOPC_ReturnStatus SOPC_ByteString_CompareAux(const void* left, const void* right, int32_t* comparison);

/**
 * \note The functions which have prototype as : \p SOPC_BUILTINTYPE_Equal() will get the
 *  same description.
 * \brief Compare the content of two specific builtintype pointer and return true or false according to the result
 * \param left The content of a specific builtintype pointer to be compare with another pointer of the same type.
 * \param right The content of a specific builtintype pointer to be compare with another pointer of the same type.
 *
 * \return true if the two contents are equal otherwise false.
 */
bool SOPC_ByteString_Equal(const SOPC_ByteString* left, const SOPC_ByteString* right);

/** \see description in similar function SOPC_Boolean_Initialize */
void SOPC_String_Initialize(SOPC_String* string);
/** \see description in similar function SOPC_Boolean_InitializeAux */
void SOPC_String_InitializeAux(void* value);
/** Allocates and return a new String (initialized as empty). */
SOPC_String* SOPC_String_Create(void);

/**
 * \brief Copy a C-String to the Data field of the SOPC_String object
 * \param string The pointer to the SOPC_String object
 * \param cString  The C-String that would be copied in the Data field
 *
 * \return SOPC_STATUS_OK in case of success, otherwise SOPC_STATUS_INVALID_STATE
 */
SOPC_ReturnStatus SOPC_String_CopyFromCString(SOPC_String* string, const char* cString);
SOPC_ReturnStatus SOPC_String_CopyAux(void* dest, const void* src);

/**
 * \note The functions which have prototype as : \p SOPC_BUILTINTYPE_InitializeFromCString() will get the
 *  same description.
 * \brief Initialize the content of a specific builtintype pointer with a C-String.
 * \param string Must be a non-NULL pointer to an uninitialized 'BUILTINTYPE'. Do not use an already allocated object
 *      or this will lead to a memory leak.
 * \param cString The C-String.
 * \return SOPC_STATUS_OK in case of success, otherwise SOPC_STATUS_INVALID_PARAMETERS if there are bad input
 *  parameters or SOPC_STATUS_NOK if an error occurs.
 */
SOPC_ReturnStatus SOPC_String_InitializeFromCString(SOPC_String* string, const char* cString);

/**
 * \warning This function allocates new memory, so the return value must be freed after this call function.
 * \brief Retrieve the C-String of a SOPC_String pointer.
 * \param string The SOPC_String pointer whose content will be extracted.
 * \return A valid C-String otherwise it returns NULL pointer if allocation failed or there were bad input parameters.
 */
char* SOPC_String_GetCString(const SOPC_String* string);

/**
 * \warning The value returned is not a copy, so :
 *  - The returned value can only be used while the input object is defined.
 *  - The returned value shall not be freed.
 *
 * \brief Retrieve the raw C-String of a SOPC_String pointer.
 * \param string The SOPC_String pointer whose content will be extracted.
 * \return A valid C-String otherwise it returns NULL pointer if allocation failed.
 */
const char* SOPC_String_GetRawCString(const SOPC_String* string);

/**
 * \brief Create a shallow copy of \a src into \a dest. The \a src string must not be cleared before \a dest is cleared
 * \param dest  The pointer to the destination SOPC_String object.
 * \param src  The pointer to the source SOPC_String object.
 * \return SOPC_STATUS_OK in case of success, otherwise SOPC_STATUS_INVALID_PARAMETERS
 */
SOPC_ReturnStatus SOPC_String_AttachFrom(SOPC_String* dest, SOPC_String* src);

/**
 * \brief Create a shallow copy of \a src (C-String) into \a dest.
 * \param dest  The pointer to the destination SOPC_String object
 * \param src  The C-String data that will be copied to the destination SOPC_String object
 * \return SOPC_STATUS_OK in case of success, otherwise SOPC_STATUS_INVALID_PARAMETERS
 */
SOPC_ReturnStatus SOPC_String_AttachFromCstring(SOPC_String* dest, const char* src);

/**
 * \note Since an allocation is used, the user must freed the \a dest pointer after using it.
 *  Furthermore, it is a copy, so be sure to clear bytes on clear.
 *
 * \brief Create a copy of \a src into \a dest.
 * \param dest  The pointer to the destination SOPC_String object.
 * \param src  The pointer to the source SOPC_String object.
 *
 * \return SOPC_STATUS_OK in case of success, otherwise SOPC_STATUS_INVALID_PARAMETERS if there are bad inputs
 * parameters or SOPC_STATUS_OUT_OF_MEMORY if no space memory available.
 */
SOPC_ReturnStatus SOPC_String_Copy(SOPC_String* dest, const SOPC_String* src);
/** \see SOPC_Boolean_Clear */
void SOPC_String_Clear(SOPC_String* bstring);
/** \see SOPC_Boolean_ClearAux */
void SOPC_String_ClearAux(void* value);
/** \see SOPC_Boolean_Delete */
void SOPC_String_Delete(SOPC_String* bstring);

/**
 * \note The functions which have prototype as : \p SOPC_BUILTINTYPE_Compare() will get approximately the
 *  same description (some parameters might change according to the goal function).
 *
 * \brief Compare the content of a String pointer to another one and set the result in the comparison parameter.
 *
 * \param left a generic pointer that will be casted in <em>specific builtintype pointer</em>
 * \param right a generic pointer that will be casted in <em>specific builtintype pointer</em>
 * \param ignoreCase false if ignore sensitive case otherwise it is true.
 * \param comparison these possible values are:
 *                      * 1 : left pointer < right pointer
 *                      * 0 : left pointer == right pointer
 *                      * -1 : right pointer < left pointer
 *
 * \return SOPC_STATUS_OK in case of success, otherwise SOPC_STATUS_INVALID_PARAMETERS
 */
SOPC_ReturnStatus SOPC_String_Compare(const SOPC_String* left,
                                      const SOPC_String* right,
                                      bool ignoreCase,
                                      int32_t* comparison);
SOPC_ReturnStatus SOPC_String_CompareAux(const void* left, const void* right, int32_t* comparison);

bool SOPC_String_Equal(const SOPC_String* left, const SOPC_String* right);

/**
 * \brief Returns a NULL terminated C-string array without copying the strings.
 *        The caller is responsible to NOT modify the content of the returned array and
 *        to call SOPC_Free on the array (and NOT the array content) after use.
 *
 * \param nbOfStrings  The number of elements in \p stringArray
 * \param stringArray  The array of SOPC_String to retrieve as C-string array
 *
 *
 * \return C-String array containing the strings contains in the SOPC_String array without string copy.
 *         NULL is returned in case of invalid arguments, and {NULL} in case of empty SOPC_String array.
 *
 */
const char** SOPC_String_GetRawCStringArray(int32_t nbOfStrings, SOPC_String* stringArray);

/**
 * \brief Returns a NULL terminated C-string array copying the strings.
 *
 * \param nbOfStrings  The number of elements in \p stringArray
 * \param stringArray  The array of SOPC_String to retrieve as C-string array
 *
 *
 * \return C-String array containing the strings contains in the SOPC_String array without string copy.
 *         NULL is returned in case of invalid arguments, and {NULL} in case of empty SOPC_String array.
 *
 */
char** SOPC_String_GetCStringArray(int32_t nbOfStrings, SOPC_String* stringArray);

/**** XmlElement ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_XmlElement_Initialize(SOPC_XmlElement* xmlElt);
void SOPC_XmlElement_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_XmlElement_Copy(SOPC_XmlElement* dest, const SOPC_XmlElement* src);
SOPC_ReturnStatus SOPC_XmlElement_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_XmlElement_Compare(const SOPC_XmlElement* left,
                                          const SOPC_XmlElement* right,
                                          int32_t* comparison);
SOPC_ReturnStatus SOPC_XmlElement_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_XmlElement_Clear(SOPC_XmlElement* xmlElt);
void SOPC_XmlElement_ClearAux(void* value);

/**** DateTime ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_DateTime_Initialize(SOPC_DateTime* dateTime);
void SOPC_DateTime_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_DateTime_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_DateTime_Compare(const SOPC_DateTime* left, const SOPC_DateTime* right, int32_t* comparison);
SOPC_ReturnStatus SOPC_DateTime_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_DateTime_Clear(SOPC_DateTime* dateTime);
void SOPC_DateTime_ClearAux(void* value);

/**** Guid ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_Guid_Initialize(SOPC_Guid* guid);
void SOPC_Guid_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_Guid_FromCString(SOPC_Guid* guid, const char* str, size_t len);
char* SOPC_Guid_ToCString(const SOPC_Guid* guid);
SOPC_ReturnStatus SOPC_Guid_Copy(SOPC_Guid* dest, const SOPC_Guid* src);
SOPC_ReturnStatus SOPC_Guid_CompareAux(const void* left, const void* right, int32_t* comparison);
SOPC_ReturnStatus SOPC_Guid_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_Guid_Compare(const SOPC_Guid* left, const SOPC_Guid* right, int32_t* comparison);
void SOPC_Guid_Clear(SOPC_Guid* guid);
void SOPC_Guid_ClearAux(void* value);

/**** NodeId ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_NodeId_Initialize(SOPC_NodeId* nodeId);
void SOPC_NodeId_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_NodeId_Copy(SOPC_NodeId* dest, const SOPC_NodeId* src);
SOPC_ReturnStatus SOPC_NodeId_CopyAux(void* dest, const void* src);
void SOPC_NodeId_Clear(SOPC_NodeId* nodeId);
void SOPC_NodeId_ClearAux(void* value);

SOPC_ReturnStatus SOPC_NodeId_Compare(const SOPC_NodeId* left, const SOPC_NodeId* right, int32_t* comparison);
SOPC_ReturnStatus SOPC_NodeId_CompareAux(const void* left, const void* right, int32_t* comparison);
bool SOPC_NodeId_Equal(const SOPC_NodeId* left, const SOPC_NodeId* right);
bool SOPC_NodeId_IsNull(const SOPC_NodeId* nodeId);

void SOPC_NodeId_Hash(const SOPC_NodeId* nodeId, uint64_t* hash);

/** \brief Allocates a C string containing the normalized representation of a NodeId. Must be freed by caller after use
 */
char* SOPC_NodeId_ToCString(const SOPC_NodeId* nodeId);
/** \brief Initializes a NodeId from a normalized C string. See SOPC_String_InitializeFromCString */
SOPC_ReturnStatus SOPC_NodeId_InitializeFromCString(SOPC_NodeId* pNid, const char* cString, int32_t len);
/** \brief Alloacates and initializes a NodeId from a normalized C string. See SOPC_String_InitializeFromCString */
SOPC_NodeId* SOPC_NodeId_FromCString(const char* cString, int32_t len);
/** \brief Creates a dictionary which keys are \a NodeId.
 * \param free_keys True if the dictionary is responsible for deleting keys on element removal
 * \param value_free The Free function for deleted elements. (Can be null if no deletion is required)
 */
SOPC_Dict* SOPC_NodeId_Dict_Create(bool free_keys, SOPC_Dict_Free_Fct value_free);

/**** ExpandedNodeId ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_ExpandedNodeId_Initialize(SOPC_ExpandedNodeId* expNodeId);
void SOPC_ExpandedNodeId_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_ExpandedNodeId_Copy(SOPC_ExpandedNodeId* dest, const SOPC_ExpandedNodeId* src);
SOPC_ReturnStatus SOPC_ExpandedNodeId_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_ExpandedNodeId_Compare(const SOPC_ExpandedNodeId* left,
                                              const SOPC_ExpandedNodeId* right,
                                              int32_t* comparison);
SOPC_ReturnStatus SOPC_ExpandedNodeId_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_ExpandedNodeId_Clear(SOPC_ExpandedNodeId* expNodeId);
void SOPC_ExpandedNodeId_ClearAux(void* value);

/**** StatusCode ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_StatusCode_Initialize(SOPC_StatusCode* status);
void SOPC_StatusCode_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_StatusCode_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_StatusCode_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_StatusCode_Clear(SOPC_StatusCode* status);
void SOPC_StatusCode_ClearAux(void* value);

/**** DiagnosticInfo ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_DiagnosticInfo_Initialize(SOPC_DiagnosticInfo* diagInfo);
void SOPC_DiagnosticInfo_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_DiagnosticInfo_Copy(SOPC_DiagnosticInfo* dest, const SOPC_DiagnosticInfo* src);
SOPC_ReturnStatus SOPC_DiagnosticInfo_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_DiagnosticInfo_Compare(const SOPC_DiagnosticInfo* left,
                                              const SOPC_DiagnosticInfo* right,
                                              int32_t* comparison);
SOPC_ReturnStatus SOPC_DiagnosticInfo_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_DiagnosticInfo_Clear(SOPC_DiagnosticInfo* diagInfo);
void SOPC_DiagnosticInfo_ClearAux(void* value);

/**** QualifiedName ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_QualifiedName_Initialize(SOPC_QualifiedName* qname);
void SOPC_QualifiedName_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_QualifiedName_Copy(SOPC_QualifiedName* dest, const SOPC_QualifiedName* src);
SOPC_ReturnStatus SOPC_QualifiedName_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_QualifiedName_Compare(const SOPC_QualifiedName* left,
                                             const SOPC_QualifiedName* right,
                                             int32_t* comparison);
SOPC_ReturnStatus SOPC_QualifiedName_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_QualifiedName_Clear(SOPC_QualifiedName* qname);
void SOPC_QualifiedName_ClearAux(void* value);
SOPC_ReturnStatus SOPC_QualifiedName_ParseCString(SOPC_QualifiedName* qname, const char* str);

/**** LocalizedText ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_LocalizedText_Initialize(SOPC_LocalizedText* localizedText);
void SOPC_LocalizedText_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_LocalizedText_Copy(SOPC_LocalizedText* dest, const SOPC_LocalizedText* src);
SOPC_ReturnStatus SOPC_LocalizedText_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_LocalizedText_Compare(const SOPC_LocalizedText* left,
                                             const SOPC_LocalizedText* right,
                                             int32_t* comparison);
SOPC_ReturnStatus SOPC_LocalizedText_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_LocalizedText_Clear(SOPC_LocalizedText* localizedText);
void SOPC_LocalizedText_ClearAux(void* value);

/**
 * \brief Copy into the given empty localized text an array of localized text to create a LocalizedText set.
 * Note: array is considered to contain only LocalizedText single values (other values than default fields are ignored)
 *
 * \param destSetOfLt   The destination empty LocalizedText which will contain data of the LocalizedText array
 *                      (default field will contain index 0 of array and the list the rest)
 * \param nbElts        Number of element of the array
 * \param srcArrayOfLt  The source array of LocalizedText to be copied into a unique LocalizedText structure (as a set).
 *                      The array should contain only single LocalizedText value (default fields only), the rest will be
 *                      ignored.
 *
 * \return SOPC_STATUS_OK in case of success
 */
SOPC_ReturnStatus SOPC_LocalizedText_CopyFromArray(SOPC_LocalizedText* destSetOfLt,
                                                   int32_t nbElts,
                                                   const SOPC_LocalizedText* srcArrayOfLt);

/**
 * \brief Copy into a new LocalizedText array the content of a LocalizedText set (or single value).
 *
 * \param dstArray      The destination pointer in which the array of LocalizedText will be allocated.
 *                      The array contain only single LocalizedText value (default fields only).
 * \param nbElts        The destination pointer in which the number of elements in the array will be stored
 * \param srcSetOfLt    The source LocalizedText set (or single value) to be copied into the array.
 *
 * \return SOPC_STATUS_OK in case of success
 */
SOPC_ReturnStatus SOPC_LocalizedText_CopyToArray(SOPC_LocalizedText** dstArray,
                                                 int32_t* nbElts,
                                                 const SOPC_LocalizedText* srcSetOfLt);

/**
 * \brief Add a src LocalizedText to the LocalizedText list of dest.
 * If locale already exists overwrite it, if it is a NULL LocalizedText clear all localized text stored
 * Note: src shall not contain a list of localized text, only default localized text fields
 *
 * \param destSetOfLt        The localizedText object in which additional (or existent) localized text will be added
 * \param supportedLocaleIds The NULL terminated list of supported locales of the owner of the localizedText object
 *                           (use as read only)
 * \param src                The localizedText object containing a single localized text, the locale shall be "" or
 * one of the locales supported. Otherwise the SOPC_STATUS_NOT_SUPPORTED is returned.
 *
 * \return SOPC_STATUS_OK if the operation succeeded and error status otherwise
 */
SOPC_ReturnStatus SOPC_LocalizedText_AddOrSetLocale(SOPC_LocalizedText* destSetOfLt,
                                                    char** supportedLocaleIds,
                                                    const SOPC_LocalizedText* src);

/**
 * \brief Set the single localized text \p dest with preferred locale from the multiple localized texts contained in \p
 * src. The preferred locale is selected using the preferred locale Ids array \p localeIds (ordered by preference
 * priority).
 * 1. Attempt to find the first matching locale considering the whole localeId which may contain
 * [language]-[courntry/region] or only [language]
 * 2. Attempt to find the first matching locale considering only the [language] part
 * 3. If no there is no locale match, returns the default locale of \p src localized text
 *
 * \param dest               The empty or single value localizedText object in a preferred localized text shall be set
 * \param preferredLocaleIds The NULL terminated list of preferred locales by priority order (use as read only)
 * \param srcSetOfLt         The localizedText object containing multiple localized texts in which the preferred one
 *                           shall be chosen. If none is compatible, choose the default one.
 *
 * \return SOPC_STATUS_OK if the operation succeeded and error status otherwise
 */
SOPC_ReturnStatus SOPC_LocalizedText_GetPreferredLocale(SOPC_LocalizedText* dest,
                                                        char** preferredLocaleIds,
                                                        const SOPC_LocalizedText* srcSetOfLt);

/* Same as SOPC_LocalizedText_GetPreferredLocale but using an array of single LocalizedText as source */
SOPC_ReturnStatus SOPC_LocalizedTextArray_GetPreferredLocale(SOPC_LocalizedText* dest,
                                                             char** preferredLocaleIds,
                                                             int32_t nbLocalizedText,
                                                             const SOPC_LocalizedText* srcArray);

/**** ExtensionObject ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_ExtensionObject_Initialize(SOPC_ExtensionObject* extObj);
void SOPC_ExtensionObject_InitializeAux(void* value);

/* Copy returned is encoded version of the extension object if its representation was an Object.
 * i.e.: if src contains an Object, dest contains a ByteString with encoded object. In other case the ByteString or
 * XmlElement content is just copied.
 *
 * Note: reason is we do not have a copy method for Object type but we have an encoder
 */
SOPC_ReturnStatus SOPC_ExtensionObject_Copy(SOPC_ExtensionObject* dest, const SOPC_ExtensionObject* src);
/* Move extension object content from src to dest.
 * Note: this function is provided to allow to keep the object format when no copy is needed
 *       (since copy encode the object)
 */
SOPC_ReturnStatus SOPC_ExtensionObject_Move(SOPC_ExtensionObject* dest, SOPC_ExtensionObject* src);
SOPC_ReturnStatus SOPC_ExtensionObject_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_ExtensionObject_Compare(const SOPC_ExtensionObject* left,
                                               const SOPC_ExtensionObject* right,
                                               int32_t* comparison);
SOPC_ReturnStatus SOPC_ExtensionObject_CompareAux(const void* left, const void* right, int32_t* comparison);
void SOPC_ExtensionObject_Clear(SOPC_ExtensionObject* extObj);
void SOPC_ExtensionObject_ClearAux(void* value);

/**** Variant ****/

/**
 * \brief Generic comparison function type for values contained in a variant
 *
 * \param customContext  The custom context provided to the custom comparison function
 * \param builtInTypeId  The value type of \p left and \p right comparison operands
 * \param left           The left operand for which type is defined by \p builtInTypeId
 * \param right          The right operand for which type is defined by \p builtInTypeId
 * \param[out]           The comparison result set when status returned is ::SOPC_STATUS_OK.
 *                       When result is set it is expected to be:
 *                       - (-1) if left < right
 *                       - (0) if left == right
 *                       - (+1) if left > right
 *
 * \return               SOPC_STATUS_OK if the comparison succeeded,
 *                       SOPC_STATUS_UNSUPPORTED if the type is not supported.
 */
typedef SOPC_ReturnStatus(SOPC_VariantValue_PfnCompCustom)(const void* customContext,
                                                           SOPC_BuiltinId builtInTypeId,
                                                           const void* left,
                                                           const void* right,
                                                           int32_t* compResult);

/** \brief allocates and return a SOPC_Variant */
SOPC_Variant* SOPC_Variant_Create(void);
/** \brief Initialize a Variant. Do not initialize existing variants without clearing them first.*/
void SOPC_Variant_Initialize(SOPC_Variant* variant);
/** \brief Initialize a Variant as an array of given length. Do not initialize existing variants without clearing them
 * first.*/
bool SOPC_Variant_Initialize_Array(SOPC_Variant* var, SOPC_BuiltinId builtInId, int32_t length);
void SOPC_Null_ClearAux(void* value);
SOPC_ReturnStatus SOPC_Null_CompareAux(const void* dest, const void* src, int32_t* comparison);
SOPC_ReturnStatus SOPC_Null_CopyAux(void* dest, const void* src);
void SOPC_Variant_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_Variant_Copy(SOPC_Variant* dest, const SOPC_Variant* src);
SOPC_ReturnStatus SOPC_Variant_CopyAux(void* dest, const void* src);

/**
 * \brief Checks if the given range is valid for the given variant:
 *        - the number of dimensions is compatible with the variant value
 *        - range(s) start is valid for variant value
 *        - range(s) end is valid for variant value if not for a write operation
 *
 * \note  Intrinsic range validity was already checked by ::SOPC_NumericRange_Parse
 *        (the first integer shall have a lower value than the second).
 *
 *
 * \param      variant     The variant for which the range is checked
 * \param      range       The range to check for given variant
 * \param      fullRange   When true, the function checks that at least one element of the array is valid
 *                         for \p range (typical for a "Read" array check).
 *                         When  false, the function checks that all elements of the array are valid
 *                         for \p range (typical for a "Write" array check).
 * \param[out] hasRange    The result pointer parameter, the result is true if the range is valid for the given variant
 *                         and false otherwise
 *
 * \return                 SOPC_STATUS_INVALID_PARAMETERS if a parameter is NULL or the number of dimensions is 0,
 *                         SOPC_STATUS_OK otherwise.
 */
SOPC_ReturnStatus SOPC_Variant_HasRange(const SOPC_Variant* variant,
                                        const SOPC_NumericRange* range,
                                        bool fullRange,
                                        bool* hasRange);
SOPC_ReturnStatus SOPC_Variant_GetRange(SOPC_Variant* dst, const SOPC_Variant* src, const SOPC_NumericRange* range);
SOPC_ReturnStatus SOPC_Variant_SetRange(SOPC_Variant* dst, const SOPC_Variant* src, const SOPC_NumericRange* range);

// Raw copy of structure content without new allocation: destination variant content will not be freed on clear
SOPC_ReturnStatus SOPC_Variant_ShallowCopy(SOPC_Variant* dst, const SOPC_Variant* src);

// Does a shallow copy from src to dst, transfering the ownership to dst.
//
// The value of DoNotClear is transfered from src to dst, and src->DoNotClear is
// set to true after this function returns (since the ownership of the data moved
// to dst).
void SOPC_Variant_Move(SOPC_Variant* dest, SOPC_Variant* src);

SOPC_ReturnStatus SOPC_Variant_Compare(const SOPC_Variant* left, const SOPC_Variant* right, int32_t* comparison);
SOPC_ReturnStatus SOPC_Variant_CompareAux(const void* left, const void* right, int32_t* comparison);
SOPC_ReturnStatus SOPC_Variant_CompareCustom(SOPC_VariantValue_PfnCompCustom* compCustom,
                                             const void* compCustomContext,
                                             const SOPC_Variant* left,
                                             const SOPC_Variant* right,
                                             int32_t* comparison);
SOPC_ReturnStatus SOPC_Variant_CompareRange(const SOPC_Variant* left,
                                            const SOPC_Variant* right,
                                            const SOPC_NumericRange* range,
                                            int32_t* comparison);

SOPC_ReturnStatus SOPC_Variant_CompareCustomRange(SOPC_VariantValue_PfnCompCustom* compCustom,
                                                  const void* compCustomContext,
                                                  const SOPC_Variant* left,
                                                  const SOPC_Variant* right,
                                                  const SOPC_NumericRange* range,
                                                  int32_t* comparison);

void SOPC_Variant_Clear(SOPC_Variant* variant);
void SOPC_Variant_ClearAux(void* value);
void SOPC_Variant_Delete(SOPC_Variant* variant);

// Raw function to print a variant on standard output. Do not display array or matrix.
void SOPC_Variant_Print(SOPC_Variant* variant);

const void* SOPC_Variant_Get_SingleValue(const SOPC_Variant* var, SOPC_BuiltinId builtInTypeId);
const void* SOPC_Variant_Get_ArrayValue(const SOPC_Variant* var, SOPC_BuiltinId builtInTypeId, int32_t index);
bool SOPC_Variant_CopyInto_ArrayValueAt(const SOPC_Variant* var,
                                        SOPC_BuiltinId builtInTypeId,
                                        int32_t index,
                                        const void* value);
const SOPC_NodeId* SOPC_Variant_Get_DataType(const SOPC_Variant* var);
int32_t SOPC_Variant_Get_ValueRank(const SOPC_Variant* var);
bool SOPC_ValueRank_IsAssignableInto(int32_t dest_ValueRank, int32_t src_valueRank);

/**** DataValue ****/
/** \see description in similar function SOPC_Boolean_xxxx */
void SOPC_DataValue_Initialize(SOPC_DataValue* dataValue);
void SOPC_DataValue_InitializeAux(void* value);
SOPC_ReturnStatus SOPC_DataValue_Copy(SOPC_DataValue* dest, const SOPC_DataValue* src);
SOPC_ReturnStatus SOPC_DataValue_CopyAux(void* dest, const void* src);
SOPC_ReturnStatus SOPC_DataValue_Compare(const SOPC_DataValue* left, const SOPC_DataValue* right, int32_t* comparison);
SOPC_ReturnStatus SOPC_DataValue_CompareAux(const void* left, const void* right, int32_t* comparison);
SOPC_ReturnStatus SOPC_DataValue_CompareRange(const SOPC_DataValue* left,
                                              const SOPC_DataValue* right,
                                              const SOPC_NumericRange* range,
                                              int32_t* comparison);
void SOPC_DataValue_Clear(SOPC_DataValue* dataValue);
void SOPC_DataValue_ClearAux(void* value);

void SOPC_Initialize_Array(int32_t noOfElts,
                           void* eltsArray,
                           size_t sizeOfElt,
                           SOPC_EncodeableObject_PfnInitialize* initFct);
SOPC_ReturnStatus SOPC_Copy_Array(int32_t noOfElts,
                                  void* eltsArrayDest,
                                  const void* eltsArraySrc,
                                  size_t sizeOfElt,
                                  SOPC_EncodeableObject_PfnCopy* opFct);
SOPC_ReturnStatus SOPC_Comp_Array(int32_t noOfElts,
                                  const void* eltsArrayLeft,
                                  const void* eltsArrayRight,
                                  size_t sizeOfElt,
                                  SOPC_EncodeableObject_PfnComp* compFct,
                                  int32_t* comparisonResult);
SOPC_ReturnStatus SOPC_CompCustom_Array(int32_t noOfElts,
                                        const void* eltsArrayLeft,
                                        const void* eltsArrayRight,
                                        size_t sizeOfElt,
                                        SOPC_VariantValue_PfnCompCustom* compCustomFct,
                                        const void* customCompContext,
                                        SOPC_BuiltinId builtInId,
                                        int32_t* comparisonResult);
void SOPC_Clear_Array(int32_t* noOfElts, void** eltsArray, size_t sizeOfElt, SOPC_EncodeableObject_PfnClear* clearFct);

/**
 *  \brief Built-in type handling. Provides all the generic service functions
 *  associated with a built-in type (except encoders and decoders which are
 *  declared in struct \c SOPC_BuiltInType_Encoders). Also define the
 *  allocation size of objects of a built-in type.
 */
typedef struct SOPC_BuiltInType_Handling
{
    size_t size;
    SOPC_EncodeableObject_PfnInitialize* initialize;
    SOPC_EncodeableObject_PfnClear* clear;
    SOPC_EncodeableObject_PfnCopy* copy;
    SOPC_EncodeableObject_PfnComp* compare;
} SOPC_BuiltInType_Handling;

/**
 *  \brief Table of all built-in type handlers. To be indexed with a \c
 *  SOPC_BuiltinId.  Provides all the generic service functions associated with
 *  each built-in type.
 */
S2OPC_COMMON_EXPORT extern const SOPC_BuiltInType_Handling SOPC_BuiltInType_HandlingTable[SOPC_BUILTINID_MAX + 1];

#endif /* SOPC_SOPC_BUILTINTYPES_H_ */
