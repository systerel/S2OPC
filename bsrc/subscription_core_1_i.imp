/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    subscription_core_1_i

REFINES
    subscription_core_1

SEES
    constants,
    request_handle_bs,
    message_out_bs,
    message_in_bs,
    channel_mgr,
    constants_statuscodes_bs

CONCRETE_VARIABLES
    s_subscription_i,
    a_subscription_state_i,
    a_subscription_session_i,
    a_publishInterval_i,
    a_lifetimeExpCount_i,
    a_keepAliveExpCount_i,
    a_maxNotifsPerPublish_i,
    a_subscription_priority_i,
    a_session_nb_priorities_i,
    a_session_seq_priority_i,
    a_session_priority_idx_i,
    a_session_nb_subscriptions_i,
    a_session_seq_subscription_i,
    a_session_subscription_idx_i,
    a_session_priority_nb_subs_i,
    a_session_priority_min_sub_idx_i,
    a_session_priority_next_sub_idx_i,
    a_PublishingEnabled_i,
    a_MoreNotifications_i,
    a_LifetimeCounter_i,
    a_KeepAliveCounter_i,
    a_MessageSent_i,
    a_SeqNum_i,
    a_publishRequestQueue_i,
    a_notifRepublishQueue_i,
    a_monitoredItemQueue_i,
    a_publishTimer_i

INVARIANT
    s_subscription_i          : t_subscription_i --> BOOL                                      &
    a_subscription_state_i    : t_subscription_i --> t_subscriptionState_i                     &
    s_subscription            = s_subscription_i~[{TRUE}]                                      &
    dom(a_subscription_state) = s_subscription                                                 &

    a_subscription_state      = s_subscription <| a_subscription_state_i |> t_subscriptionState_i &
    a_subscription_session_i  : t_subscription_i --> t_session_i                               &
    dom(a_subscription_session) = s_subscription                                               &
    a_subscription_session    = s_subscription <| a_subscription_session_i |> t_session        &

    /* Priority for a given subscription */
    a_subscription_priority_i : t_subscription_i --> t_priority_i                              &
    a_subscription_priority   = t_subscription <| a_subscription_priority_i |> t_priority      &

    /* Number of pro indexes for a given session */
    a_session_nb_priorities_i : t_session_i --> t_prio_idx_i                                   &
    !session.(session : t_session
              =>
              card(a_session_seq_priority(session)) = a_session_nb_priorities_i(session))      &

    /* Priority for a given prio index */
    a_session_seq_priority_i : t_session_i --> (t_prio_idx_i --> t_priority_i)                 &

    /* Prio index for a given priority */
    a_session_priority_idx_i : t_session_i --> (t_priority_i --> t_prio_idx_i)                 &
    !session.(session : t_session
              =>
              a_session_seq_priority(session) = a_session_seq_priority_i(session) |> t_prio_idx) &
    !session.(session : t_session
              =>
              a_session_seq_priority(session)~ = a_session_priority_idx_i(session) |> t_prio_idx) &

    /* Number of subscriptions indexes => Note: this is not an index but a NAT */
    a_session_nb_subscriptions_i : t_session_i --> t_sub_idx_i &
    !session.(session : t_session
              =>
              card(a_session_seq_subscription(session)) = a_session_nb_subscriptions_i(session))      &

    /* Subscription for a given index */
    a_session_seq_subscription_i : t_session_i --> (t_sub_idx_i --> t_subscription_i) &
    !session.(session : t_session
              =>
              a_session_seq_subscription(session) = 1..a_session_nb_subscriptions_i(session) <| a_session_seq_subscription_i(session)) &

    /* Index for a given subscription */
    a_session_subscription_idx_i : t_session_i --> (t_subscription_i --> t_sub_idx_i) &
    !session.(session : t_session
              =>
              a_session_seq_subscription(session)~ = t_subscription <| a_session_subscription_idx_i(session)) &

    /* Nb sub (indexes) for a given priority => NOTE: this is not an index but a NAT ! */
    a_session_priority_nb_subs_i : t_session_i --> (t_prio_idx_i --> t_sub_idx_i) &
    a_session_priority_nb_subs = t_session <| a_session_priority_nb_subs_i &

    /* First index of subscription for the given priority */
    a_session_priority_min_sub_idx_i : t_session_i --> (t_prio_idx_i --> t_sub_idx_i) &
    !session.(session : t_session
              =>
              a_session_priority_min_sub_idx(session) = a_session_priority_min_sub_idx_i(session) |> t_sub_idx) &

    /* Record of the next index of subscription in the given priority to try => used for round robin policy */
    a_session_priority_next_sub_idx_i : t_session_i --> (t_prio_idx_i --> t_sub_idx_i) &
    !session.(session : t_session
              =>
              a_session_priority_next_sub_idx(session) = a_session_priority_next_sub_idx_i(session) |> t_sub_idx) &

    a_publishInterval_i       : t_subscription_i --> t_opcua_duration_i                        &
    dom(a_publishInterval)    = s_subscription                                                 &
    a_publishInterval         <: a_publishInterval_i                                           &

    a_lifetimeExpCount_i      : t_subscription_i --> t_counter                                 &
    dom(a_lifetimeExpCount)   = s_subscription                                                 &
    a_lifetimeExpCount        <: a_lifetimeExpCount_i                                          &

    a_keepAliveExpCount_i     : t_subscription_i --> t_counter                                 &
    dom(a_keepAliveExpCount)  = s_subscription                                                 &
    a_keepAliveExpCount       <: a_keepAliveExpCount_i                                         &

    a_maxNotifsPerPublish_i   : t_subscription_i --> t_counter                                 &
    dom(a_maxNotifsPerPublish) = s_subscription                                                &
    a_maxNotifsPerPublish     <: a_maxNotifsPerPublish_i                                       &

    a_PublishingEnabled_i     : t_subscription_i --> BOOL                                      &
    a_PublishingEnabled       = dom(s_subscription <| a_PublishingEnabled_i |> {TRUE})         &

    a_MoreNotifications_i     : t_subscription_i --> BOOL                                      &
    a_MoreNotifications       = dom(s_subscription <| a_MoreNotifications_i |> {TRUE})         &

    a_LifetimeCounter_i       : t_subscription_i --> t_counter                                 &
    dom(a_LifetimeCounter)    = s_subscription                                                 &
    a_LifetimeCounter         <: a_LifetimeCounter_i                                           &

    a_KeepAliveCounter_i      : t_subscription_i --> t_counter                                 &
    dom(a_KeepAliveCounter)   = s_subscription                                                 &
    a_KeepAliveCounter        <: a_KeepAliveCounter_i                                          &

    a_MessageSent_i           : t_subscription_i --> BOOL                                      &
    a_MessageSent             = dom(s_subscription <| a_MessageSent_i |> {TRUE})               &

    a_SeqNum_i                : t_subscription_i --> t_sub_seq_num_i                           &
    dom(a_SeqNum)             = s_subscription                                                 &
    a_SeqNum                  = s_subscription <| a_SeqNum_i |> t_sub_seq_num                  &

    a_publishRequestQueue_i      : t_session_i --> t_publishReqQueue_i                    &
    ran(a_subscription_session)  <: dom(a_publishRequestQueue)                            &
    a_publishRequestQueue        = t_session <| a_publishRequestQueue_i |> t_publishReqQueue &

    a_notifRepublishQueue_i      : t_subscription_i --> t_notifRepublishQueue_i                &
    dom(a_notifRepublishQueue)   = s_subscription                                              &
    a_notifRepublishQueue        = s_subscription <| a_notifRepublishQueue_i |> t_notifRepublishQueue &

    a_monitoredItemQueue_i       : t_subscription_i --> t_monitoredItemQueue_i                 &
    dom(a_monitoredItemQueue)    = s_subscription                                              &
    a_monitoredItemQueue         = s_subscription <| a_monitoredItemQueue_i |> t_monitoredItemQueue &

    a_publishTimer_i             : t_subscription_i --> t_timer_id_i                           &
    dom(a_publishTimer)          = s_subscription                                              &
    a_publishTimer               = s_subscription <| a_publishTimer_i |> t_timer_id

INITIALISATION
    s_subscription_i             := t_subscription_i * {FALSE};
    a_subscription_state_i       := t_subscription_i * {c_subscriptionState_indet};
    a_subscription_session_i     := t_subscription_i * {c_session_indet};
    a_publishInterval_i          := t_subscription_i * {c_opcua_duration_indet};
    a_lifetimeExpCount_i         := t_subscription_i * {0};
    a_keepAliveExpCount_i        := t_subscription_i * {0};
    a_maxNotifsPerPublish_i      := t_subscription_i * {0};

    a_subscription_priority_i    := t_subscription_i * {c_priority_indet};
    a_session_nb_priorities_i    := t_session_i * {0};
    a_session_seq_priority_i     := t_session_i * {t_prio_idx_i * {c_priority_indet}};
    a_session_priority_idx_i     := t_session_i * {t_priority_i * {0}};
    a_session_nb_subscriptions_i := t_session_i * {0};
    a_session_seq_subscription_i := t_session_i * {t_sub_idx_i * {c_subscription_indet}};
    a_session_subscription_idx_i := t_session_i * {t_subscription_i * {0}};
    a_session_priority_nb_subs_i := t_session_i * {t_prio_idx_i * {0}};
    a_session_priority_min_sub_idx_i  := t_session_i * {t_prio_idx_i * {0}};
    a_session_priority_next_sub_idx_i := t_session_i * {t_prio_idx_i * {0}};

    a_PublishingEnabled_i        := t_subscription_i * {FALSE};
    a_MoreNotifications_i        := t_subscription_i * {FALSE};
    a_LifetimeCounter_i          := t_subscription_i * {0};
    a_KeepAliveCounter_i         := t_subscription_i * {0};
    a_MessageSent_i              := t_subscription_i * {FALSE};
    a_SeqNum_i                   := t_subscription_i * {c_sub_seq_num_indet};
    a_publishRequestQueue_i      := t_session_i * {c_publishReqQueue_indet};
    a_notifRepublishQueue_i      := t_subscription_i * {c_notifRepublishQueue_indet};
    a_monitoredItemQueue_i       := t_subscription_i * {c_monitoredItemQueue_indet};
    a_publishTimer_i             := t_subscription_i * {c_timer_id_indet}

LOCAL_OPERATIONS

    is_valid <-- local_is_valid_subscription (p_subscription) =
    PRE
        p_subscription : t_subscription_i
    THEN
        is_valid := s_subscription_i(p_subscription)
    END


OPERATIONS

    is_valid <-- local_is_valid_subscription (p_subscription) =
    VAR
        l_subscription_card,
        l_subscription_int
    IN
        is_valid := FALSE;
        l_subscription_card <-- get_card_t_subscription;
        l_subscription_int <-- get_reverse_cast_t_subscription (p_subscription);
        IF l_subscription_int /= 0 & l_subscription_int <= l_subscription_card
        THEN
            is_valid := s_subscription_i(p_subscription)
        END
    END
    ;

    is_valid <-- is_valid_subscription_on_session (p_session, p_subscription) =
    VAR
        l_is_valid_sub,
        l_session
    IN
        l_session := c_session_indet;
        l_is_valid_sub <-- local_is_valid_subscription(p_subscription);
        IF l_is_valid_sub = TRUE
        THEN
            l_session := a_subscription_session_i(p_subscription)
        END
        ;
        is_valid := bool(l_is_valid_sub = TRUE &
                         l_session = p_session)
    END
    ;

    is_valid <-- is_valid_subscription (p_subscription) =
    BEGIN
        is_valid <-- local_is_valid_subscription(p_subscription)
    END
    ;

    p_session <-- getall_session (p_subscription) =
    BEGIN
        p_session := a_subscription_session_i(p_subscription)
    END
    ;

    p_priority_idx <-- get_card_session_seq_priority (p_session) =
    BEGIN
        p_priority_idx := a_session_nb_priorities_i(p_session)
    END
    ;

    p_sub_idx <-- get_card_session_seq_subscription (p_session) =
    BEGIN
        p_sub_idx := a_session_nb_subscriptions_i(p_session)
    END
    ;

    p_subscription <-- get_session_seq_subscription (p_session, p_idx_sub) =
    BEGIN
        p_subscription := a_session_seq_subscription_i(p_session)(p_idx_sub)
    END
    ;

    p_nb_subs <-- get_session_priority_nb_subs (p_session, p_prio_idx) =
    BEGIN
        p_nb_subs := a_session_priority_nb_subs_i(p_session)(p_prio_idx)
    END
    ;

    p_min_idx_sub <-- get_session_priority_min_sub_idx (p_session, p_prio_idx) =
    BEGIN
        p_min_idx_sub := a_session_priority_min_sub_idx_i(p_session)(p_prio_idx)
    END
    ;

    p_next_idx_sub <-- get_session_priority_next_sub_idx (p_session, p_prio_idx) =
    BEGIN
        p_next_idx_sub := a_session_priority_next_sub_idx_i(p_session)(p_prio_idx)
    END
    ;

    set_session_priority_next_sub_idx (p_session, p_prio_idx, p_next_idx_sub) =
    BEGIN
        a_session_priority_next_sub_idx_i(p_session)(p_prio_idx) := p_next_idx_sub
    END
    ;

    StatusCode_service <-- add_subscription
       (p_subscription,
        p_session,
        p_state,
        p_firstMsgSent,
        p_priority,
        p_revPublishInterval,
        p_revLifetimeCount,
        p_revMaxKeepAlive,
        p_maxNotificationsPerPublish,
        p_publishEnabled,
        p_seqNumInit,
        p_republishQueue,
        p_monitoredItemQueue,
        p_timerId) =
    VAR
        l_prio_idx,
        l_prio_nb_subs,
        l_nb_prio,
        l_idx,
        l_int_continue,
        l_sub_idx_it,
        l_prio,
        l_sub_idx_max,
        l_reset_next_sub_idx,
        l_sub_idx,
        l_sub
    IN
        l_reset_next_sub_idx := FALSE;
        l_sub_idx_max := a_session_nb_subscriptions_i(p_session) + 1;
        IF l_sub_idx_max > k_n_subscriptionPerSession_max
        THEN
            StatusCode_service := e_sc_bad_too_many_subscriptions
        ELSE
            StatusCode_service := e_sc_ok;

            s_subscription_i(p_subscription) := TRUE;
            a_subscription_state_i(p_subscription) := p_state;

            a_subscription_session_i(p_subscription) := p_session;
            a_subscription_priority_i(p_subscription) := p_priority;
            a_publishInterval_i(p_subscription) := p_revPublishInterval;
            a_lifetimeExpCount_i(p_subscription) := p_revLifetimeCount;
            a_LifetimeCounter_i(p_subscription) := p_revLifetimeCount;
            a_keepAliveExpCount_i(p_subscription) := p_revMaxKeepAlive;
            a_KeepAliveCounter_i(p_subscription) := p_revMaxKeepAlive;
            a_maxNotifsPerPublish_i(p_subscription) := p_maxNotificationsPerPublish;
            a_MessageSent_i(p_subscription) := p_firstMsgSent;
            a_PublishingEnabled_i(p_subscription) := p_publishEnabled;
            a_SeqNum_i (p_subscription) := p_seqNumInit;
            a_notifRepublishQueue_i(p_subscription) := p_republishQueue;
            a_monitoredItemQueue_i(p_subscription) := p_monitoredItemQueue;
            a_publishTimer_i(p_subscription) := p_timerId;

            l_prio_idx := a_session_priority_idx_i(p_session)(p_priority);
            IF l_prio_idx = 0 THEN
                // the added subscription has a priority that does not exist,
                // so it shall be inserted in the sequence of priorities
                // let's search for the new priority index (l_prio_idx)
                l_nb_prio  := a_session_nb_priorities_i(p_session);
                l_prio_idx := l_nb_prio + 1;
                l_int_continue := 1;
                WHILE 0 < l_prio_idx & l_int_continue = 1
                DO
                    l_prio := a_session_seq_priority_i(p_session)(l_prio_idx - 1);
                    IF l_prio /= c_priority_indet & p_priority < l_prio
                    THEN
                        // priorities higher than the subscription priority are shifted of +1 index
                        a_session_seq_priority_i(p_session)(l_prio_idx) := l_prio;
                        a_session_priority_idx_i(p_session)(l_prio) := l_prio_idx;
                        a_session_priority_nb_subs_i (p_session)(l_prio_idx) := a_session_priority_nb_subs_i (p_session)(l_prio_idx-1);
                        l_prio_idx := l_prio_idx - 1
                    ELSE
                        // insertion of the subscription priority
                        a_session_seq_priority_i(p_session)(l_prio_idx) := p_priority;
                        a_session_priority_idx_i(p_session)(p_priority) := l_prio_idx;
                        a_session_priority_nb_subs_i (p_session)(l_prio_idx) := 0;
                        IF (l_prio_idx > l_nb_prio) // <=> l_prio_idx = l_nb_prio + 1
                        THEN
                            // Last priority and subscription idx added, initialize the min and next sub idx to max
                            // (in other cases the index values for this new priority are set in the following loop)
                            a_session_priority_min_sub_idx_i (p_session)(l_prio_idx) := l_sub_idx_max;
                            a_session_priority_next_sub_idx_i (p_session)(l_prio_idx) := l_sub_idx_max
                        ELSE
                            // Next sub index is not valid anymore for l_prio_idx and shall be reset after being shifted
                            l_reset_next_sub_idx := TRUE
                        END
                        ;
                        l_int_continue := 0
                    END
                INVARIANT
                    /* TODO: model to iterate on session priorities to find priority index for insertion of new priority  */
                    0=0
                VARIANT
                    l_prio_idx + l_int_continue
                END;
                a_session_nb_priorities_i(p_session) := l_nb_prio + 1
            END;

            // index data on subscriptions with a priority higher than the current priority are shifted of +1 index
            // to leave 1 space for the new subscription
            l_idx         := a_session_nb_priorities_i(p_session);
            l_sub_idx := l_sub_idx_max; /* If subscription is already the higher priority, its index will be the last one */
            WHILE l_prio_idx < l_idx
            DO
                l_prio := a_session_seq_priority_i(p_session)(l_idx);
                l_sub_idx := a_session_priority_min_sub_idx_i(p_session)(l_idx - 1);
                a_session_priority_min_sub_idx_i (p_session)(l_idx) := l_sub_idx + 1;
                a_session_priority_next_sub_idx_i(p_session)(l_idx) := a_session_priority_next_sub_idx_i(p_session)(l_idx-1) + 1;

                l_idx := l_idx - 1
            INVARIANT
                 /* TODO: model iteration to shift subscription indexes for each session priority higher than the one inserted */
                0=0
            VARIANT
                l_idx
            END;
            // Update nb subs in priority
            a_session_priority_nb_subs_i(p_session)(l_prio_idx) := a_session_priority_nb_subs_i(p_session)(l_prio_idx) + 1;
            // We never change min sub idx: either priority existed => same or we created one but we reuse the min sub idx
            // The next sub idx need to be fixed if we created a new priority
            IF l_reset_next_sub_idx = TRUE
            THEN
                a_session_priority_next_sub_idx_i(p_session)(l_prio_idx) := a_session_priority_min_sub_idx_i(p_session)(l_prio_idx)
            END
            ;

            // in the subscription sequence, shift every subscription after the current subscription
            // (starting from the end)
            l_sub_idx_it := l_sub_idx_max;
            WHILE l_sub_idx < l_sub_idx_it
            DO
                l_sub := a_session_seq_subscription_i(p_session)(l_sub_idx_it - 1);
                a_session_seq_subscription_i(p_session)(l_sub_idx_it) := l_sub;
                a_session_subscription_idx_i(p_session)(l_sub) := l_sub_idx_it;
                l_sub_idx_it := l_sub_idx_it - 1
            INVARIANT
                /* TODO: model iteration to shift subscriptions after the new one in session subscription sequence */
                0=0
            VARIANT
                l_sub_idx_it
            END;

            // set the current subscription in the subscription sequence and
            // increment the number of substitutions for its priority
            a_session_nb_subscriptions_i(p_session) := l_sub_idx_max; // set new max value

            a_session_seq_subscription_i(p_session)(l_sub_idx)  := p_subscription;
            a_session_subscription_idx_i(p_session)(p_subscription) := l_sub_idx
        END
    END
    ;

    delete_subscription (p_subscription) =
    VAR
        l_prio,
        l_session,
        l_priority,
        l_nb_subs,
        l_sub_prio_idx,
        l_prio_idx_it,
        l_nb_prio,
        l_nb_sub_prio,
        l_sub_idx_next,
        l_sub_idx_del,
        l_sub_idx,
        l_sub
    IN
        s_subscription_i(p_subscription) := FALSE;
        a_subscription_state_i(p_subscription) := c_subscriptionState_indet;

        l_session := a_subscription_session_i(p_subscription);
        a_subscription_session_i(p_subscription) := c_session_indet;

        a_publishInterval_i(p_subscription) := c_opcua_duration_indet;
        a_lifetimeExpCount_i(p_subscription) := 0;
        a_keepAliveExpCount_i(p_subscription) := 0;
        a_maxNotifsPerPublish_i(p_subscription) := 0;
        a_PublishingEnabled_i(p_subscription) := FALSE;
        a_MoreNotifications_i(p_subscription) := FALSE;
        a_LifetimeCounter_i(p_subscription) := 0;
        a_KeepAliveCounter_i(p_subscription) := 0;
        a_MessageSent_i(p_subscription) := FALSE;
        a_SeqNum_i (p_subscription) := c_sub_seq_num_indet;
        a_notifRepublishQueue_i(p_subscription) := c_notifRepublishQueue_indet;
        a_monitoredItemQueue_i(p_subscription) := c_monitoredItemQueue_indet;
        a_publishTimer_i(p_subscription) := c_timer_id_indet;

        l_priority     := a_subscription_priority_i(p_subscription);
        l_nb_subs  := a_session_nb_subscriptions_i(l_session);
        l_sub_prio_idx     := a_session_priority_idx_i(l_session)(l_priority);
        l_nb_prio      := a_session_nb_priorities_i(l_session);
        l_nb_sub_prio  := a_session_priority_nb_subs_i(l_session)(l_sub_prio_idx);
        l_sub_idx_next := a_session_priority_next_sub_idx_i(l_session)(l_sub_prio_idx);
        l_sub_idx_del  := a_session_subscription_idx_i(l_session)(p_subscription);

        l_prio_idx_it := l_sub_prio_idx;
        WHILE l_prio_idx_it < l_nb_prio
        DO
            l_prio := a_session_seq_priority_i(l_session)(l_prio_idx_it + 1);
            // sub index data on subscriptions with a priority higher than the current priority are shifted of -1 index
            a_session_priority_min_sub_idx_i (l_session)(l_prio_idx_it + 1) := a_session_priority_min_sub_idx_i (l_session)(l_prio_idx_it + 1) - 1;
            a_session_priority_next_sub_idx_i(l_session)(l_prio_idx_it + 1) := a_session_priority_next_sub_idx_i(l_session)(l_prio_idx_it + 1) - 1;
            IF l_nb_sub_prio = 1
            THEN
                // prio index on higher priority than the one removed are shifted of -1 index
                a_session_seq_priority_i(l_session)(l_prio_idx_it) := l_prio;
                a_session_priority_idx_i(l_session)(l_prio) := l_prio_idx_it;
                a_session_priority_min_sub_idx_i (l_session)(l_prio_idx_it) := a_session_priority_min_sub_idx_i (l_session)(l_prio_idx_it + 1);
                a_session_priority_next_sub_idx_i(l_session)(l_prio_idx_it) := a_session_priority_next_sub_idx_i(l_session)(l_prio_idx_it + 1);
                a_session_priority_nb_subs_i(l_session)(l_prio_idx_it) := a_session_priority_nb_subs_i(l_session)(l_prio_idx_it + 1)
            END;
            l_prio_idx_it := l_prio_idx_it + 1
        INVARIANT
            /* TODO1: model iteration to shift subscription indexes for each session priority higher than the one deleted */
            /* TODO2: model shift of index priority for each session priority higher than the one deleted when the subscription was the last of its priority */
            0=0
        VARIANT
            l_nb_prio - l_prio_idx_it
        END;

        IF l_nb_sub_prio = 1
        THEN
            // the subscription priority shall be removed
            // => previous last prio index data is invalidated (prio indexes were shifted in previous loop)
            a_session_priority_idx_i         (l_session)(l_priority) := 0;
            a_session_priority_min_sub_idx_i (l_session)(l_nb_prio) := 0;
            a_session_priority_next_sub_idx_i (l_session)(l_nb_prio) := 0;
            a_session_priority_nb_subs_i (l_session)(l_nb_prio) := 0;
            a_session_seq_priority_i (l_session)(l_nb_prio) := c_priority_indet;
            a_session_nb_priorities_i        (l_session) := l_nb_prio - 1
        ELSE
            // subscription priority remains for other subscription(s)
            a_session_priority_nb_subs_i(l_session)(l_sub_prio_idx) := l_nb_sub_prio - 1;
            // sub next index in prio shall be shifted if deleted sub index preceded the next index or the next index was the last one
            IF l_sub_idx_del < l_sub_idx_next or l_sub_idx_next = l_nb_sub_prio
            THEN
                a_session_priority_next_sub_idx_i(l_session)(l_sub_prio_idx) := l_sub_idx_next - 1
            END
        END
        ;

        // in the subscription sequence, shift every subscription after the current subscription of -1 index
        l_sub_idx := l_sub_idx_del;
        WHILE l_sub_idx < l_nb_subs
        DO
            l_sub := a_session_seq_subscription_i(l_session)(l_sub_idx + 1);
            a_session_seq_subscription_i(l_session)(l_sub_idx) := l_sub;
            a_session_subscription_idx_i(l_session)(l_sub) := l_sub_idx;
            l_sub_idx := l_sub_idx + 1
        INVARIANT
            /* TODO: model iteration to shift subscriptions after the one deleted in session subscription sequence */
            0=0
        VARIANT
            l_nb_subs - l_sub_idx
        END;
        // clear deleted subscription index
        a_session_subscription_idx_i(l_session)(p_subscription) := 0;
        // clear previous last subscription index and decrease nb of subs
        a_session_seq_subscription_i(l_session)(l_nb_subs) := c_subscription_indet;
        a_session_nb_subscriptions_i(l_session) := l_nb_subs - 1
    END
    ;

    p_priority <-- get_subscription_priority(p_subscription) =
    BEGIN
        p_priority := a_subscription_priority_i(p_subscription)
    END
    ;

    p_publishInterval <-- get_subscription_publishInterval (p_subscription) =
    BEGIN
        p_publishInterval := a_publishInterval_i (p_subscription)
    END
    ;

    set_subscription_publishInterval (p_subscription, p_revPublishInterval) =
    BEGIN
        a_publishInterval_i (p_subscription) := p_revPublishInterval
    END
    ;

    set_subscription_timer_id (p_subscription, p_timer_id) =
    BEGIN
        a_publishTimer_i (p_subscription) := p_timer_id
    END
    ;

    p_timer_id <-- get_subscription_timer_id (p_subscription) =
    BEGIN
        p_timer_id := a_publishTimer_i (p_subscription)
    END
    ;

    set_subscription_state (p_subscription, p_state) =
    BEGIN
        a_subscription_state_i(p_subscription) := p_state
    END
    ;

    p_state <-- get_subscription_state (p_subscription) =
    BEGIN
        p_state := a_subscription_state_i(p_subscription)
    END
    ;

    set_subscription_MoreNotifications (p_subscription, p_moreNotifs) =
    BEGIN
        a_MoreNotifications_i(p_subscription) := p_moreNotifs
    END
    ;

    p_moreNotifs <-- get_subscription_MoreNotifications (p_subscription) =
    BEGIN
        p_moreNotifs := a_MoreNotifications_i(p_subscription)
    END
    ;

    set_subscription_MaxLifetimeAndKeepAliveCount (p_subscription, p_revLifetimeCount, p_revMaxKeepAlive) =
    BEGIN
        a_lifetimeExpCount_i(p_subscription) := p_revLifetimeCount;
        a_keepAliveExpCount_i(p_subscription) := p_revMaxKeepAlive
    END
    ;

    decrement_subscription_LifetimeCounter (p_subscription) =
    BEGIN
        a_LifetimeCounter_i(p_subscription) := a_LifetimeCounter_i(p_subscription) - 1
    END
    ;

    reset_subscription_LifetimeCounter (p_subscription) =
    BEGIN
        a_LifetimeCounter_i(p_subscription) := a_lifetimeExpCount_i(p_subscription)
    END
    ;

    p_lifetimeCounter <-- get_subscription_LifetimeCounter (p_subscription) =
    BEGIN
        p_lifetimeCounter := a_LifetimeCounter_i(p_subscription)
    END
    ;

    decrement_subscription_KeepAliveCounter (p_subscription) =
    BEGIN
        a_KeepAliveCounter_i(p_subscription) := a_KeepAliveCounter_i(p_subscription) - 1
    END
    ;

    reset_subscription_KeepAliveCounter (p_subscription) =
    BEGIN
        a_KeepAliveCounter_i(p_subscription) := a_keepAliveExpCount_i(p_subscription)
    END
    ;

    p_keepAliveCounter <-- get_subscription_KeepAliveCounter (p_subscription) =
    BEGIN
        p_keepAliveCounter := a_KeepAliveCounter_i(p_subscription)
    END
    ;

    set_subscription_MaxNotifsPerPublish (p_subscription, p_maxNotificationsPerPublish) =
    BEGIN
        a_maxNotifsPerPublish_i (p_subscription) := p_maxNotificationsPerPublish
    END
    ;

    p_maxNotificationsPerPublish <-- get_subscription_MaxNotifsPerPublish (p_subscription) =
    BEGIN
        p_maxNotificationsPerPublish := a_maxNotifsPerPublish_i (p_subscription)
    END
    ;

    set_subscription_MessageSent (p_subscription) =
    BEGIN
        a_MessageSent_i(p_subscription) :=  TRUE
    END
    ;

    p_firstMsgSent <-- get_subscription_MessageSent (p_subscription) =
    BEGIN
        p_firstMsgSent := a_MessageSent_i(p_subscription)
    END
    ;

    set_subscription_PublishingEnabled (p_subscription, p_pubEnabled) =
    BEGIN
        a_PublishingEnabled_i(p_subscription) := p_pubEnabled;
        a_MoreNotifications_i(p_subscription) := FALSE;
        a_LifetimeCounter_i(p_subscription) := a_lifetimeExpCount_i(p_subscription)
    END
    ;

    p_pubEnabled <-- get_subscription_PublishingEnabled (p_subscription) =
    BEGIN
        p_pubEnabled := a_PublishingEnabled_i(p_subscription)
    END
    ;

    set_subscription_SeqNum (p_subscription, p_nextSeqNum) =
    BEGIN
        a_SeqNum_i(p_subscription) := p_nextSeqNum
    END
    ;

    p_seqNumToSend <-- get_subscription_SeqNum (p_subscription) =
    BEGIN
        p_seqNumToSend := a_SeqNum_i(p_subscription)
    END
    ;

    reset_session_publishRequestQueue (p_session) =
    BEGIN
        a_publishRequestQueue_i(p_session) := c_publishReqQueue_indet
    END
    ;

    set_session_publishRequestQueue (p_session, p_publishReqQueue) =
    BEGIN
        a_publishRequestQueue_i(p_session) := p_publishReqQueue
    END
    ;

    p_publishReqQueue <-- get_session_publishRequestQueue (p_session) =
    BEGIN
        p_publishReqQueue := a_publishRequestQueue_i(p_session)
    END
    ;

    p_republishQueue <-- get_subscription_notifRepublishQueue (p_subscription) =
    BEGIN
        p_republishQueue := a_notifRepublishQueue_i(p_subscription)
    END
    ;

    p_monitoredItemQueue <-- get_subscription_monitoredItemQueue (p_subscription) =
    BEGIN
        p_monitoredItemQueue := a_monitoredItemQueue_i(p_subscription)
    END

END
