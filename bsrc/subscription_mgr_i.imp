/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    subscription_mgr_i
REFINES
    subscription_mgr

SEES
    constants,
    constants_statuscodes_bs,
    message_in_bs,
    message_out_bs,
    write_value_pointer_bs,
    address_space_itf,
    request_handle_bs,
    session_mgr

DEFINITIONS
    "definitions.def"

IMPORTS
    subscription_core,
    msg_subscription_create_bs,
    msg_subscription_delete_bs,
    msg_subscription_publish_ack_bs,
    msg_subscription_set_publishing_mode_bs,
    msg_subscription_create_monitored_item,
    subscription_create_monitored_item_it,
    subscription_absent_node

PROMOTES
    is_valid_subscription

LOCAL_OPERATIONS

    fill_publish_response_msg (p_resp_msg, p_subscription, p_moreNotifs) =
    PRE
        p_resp_msg : t_msg_i &
        p_resp_msg : t_msg &
        p_subscription : t_subscription_i & p_subscription : t_subscription &
        p_moreNotifs : BOOL
    THEN
        CHOICE
            subscription_available_seq_nums_resp_SeqNum
            :(subscription_available_seq_nums_resp_SeqNum : NAT +-> t_sub_seq_num)
        OR
            skip /* Allocation failed, still send the notification message */
        END
    END
    ;

    fill_publish_response_msg_ack_results (p_session, p_req_msg, p_resp_msg, p_nb_acks) =
    PRE
        p_session : t_session_i & p_session : t_session &
        p_session : ran(a_subscription_session) &
        p_req_msg : t_msg_i &
        p_req_msg : t_msg &
        p_req_msg = c_msg_in &
        a_msg_in_type = e_msg_subscription_publish_req &
        p_resp_msg : t_msg_i &
        p_resp_msg : t_msg &
        p_resp_msg = c_msg_out &
        a_msg_out_type = e_msg_subscription_publish_resp &
        p_nb_acks : NAT &
        p_nb_acks : 1..k_n_genericOperationPerReq_max &
        subscription_ack_resp_allocated = TRUE
    THEN
        LET l_subscription_ack_resp_StatusCode, l_acknowledged_notif_msgs BE
            l_subscription_ack_resp_StatusCode =
             %p_index.(p_index : 1..p_nb_acks
                       |
                       {FALSE |-> e_sc_bad_subscription_id_invalid,
                        TRUE |-> {FALSE |-> e_sc_bad_sequence_number_unknown,
                                  TRUE |-> e_sc_ok
                              }(bool(subscription_ack_req_ackSeqNum(p_index) :
                                      a_notification_seq_num[ /* sub republish queue notification msgs seq numbers */
                                       a_republish_notification~[ /* sub republish queue notification msgs */
                                          {a_notifRepublishQueue /* sub republish queue */
                                            (subscription_ack_req_subscription(p_index)) /* sub */
                                          }
                                       ]
                                      ]
                                    )
                               )
                       }(bool(subscription_ack_req_subscription(p_index) :
                                a_subscription_session~[{p_session}])) /* subscription is valid in current session */
                      ) &
            l_acknowledged_notif_msgs =
             %p_index.(p_index : 1..p_nb_acks &
                       l_subscription_ack_resp_StatusCode(p_index) = e_sc_ok
                       |
                       a_republish_notification~[ /* sub republish queue notification msgs */
                                                 {a_notifRepublishQueue /* sub republish queue */
                                                  (subscription_ack_req_subscription(p_index)) /* sub */
                                                 }
                                             ]
                      )
        IN
            subscription_ack_resp_StatusCode := l_subscription_ack_resp_StatusCode ||
            a_republish_notification := union(ran(l_acknowledged_notif_msgs)) <<| a_republish_notification ||
            a_notification_seq_num := union(ran(l_acknowledged_notif_msgs)) <<| a_notification_seq_num
        END
    END
    ;

    fill_publish_response_msg_available_seq_nums (p_resp_msg, republishQueue, nb_seq_nums) =
    PRE
        p_resp_msg : t_msg_i &
        p_resp_msg : t_msg &
        ((p_resp_msg = c_msg_out & a_msg_out_type = e_msg_subscription_publish_resp)
            or publish_response_message = p_resp_msg) &
        republishQueue : t_notifRepublishQueue_i &
        republishQueue : t_notifRepublishQueue &
        republishQueue = notification_republish_iter_queue &
        nb_seq_nums : NAT & nb_seq_nums > 0 & /* Give guarantee on maximum value*/
        nb_seq_nums = subscription_available_seq_nums_resp_nb
    THEN
        ANY l_subscription_available_seq_nums_resp_SeqNum WHERE
            l_subscription_available_seq_nums_resp_SeqNum : 1..nb_seq_nums --> t_sub_seq_num &
            ran(l_subscription_available_seq_nums_resp_SeqNum) =
             a_notification_seq_num[a_republish_notification~[{republishQueue}]]
        THEN
             subscription_available_seq_nums_resp_SeqNum := l_subscription_available_seq_nums_resp_SeqNum
        END
    END
    ;

    fill_response_subscription_create_monitored_items (p_session, p_subscription, p_tsToReturn, p_user, p_locales, p_req_msg, p_resp_msg, p_nb_monitored_items) =
    PRE
        p_session : t_session_i & p_session : t_session &
        p_session : ran(a_subscription_session) &
        p_subscription : t_subscription_i &
        p_subscription : s_subscription &
        p_tsToReturn : t_TimestampsToReturn_i &
        p_tsToReturn : t_TimestampsToReturn &
        p_user : t_user_i &
        p_user : t_user   &
        p_locales : t_LocaleIds_i &
        p_locales : t_LocaleIds   &
        p_req_msg : t_msg_i &
        p_req_msg : t_msg &
        p_req_msg = c_msg_in &
        a_msg_in_type = e_msg_subscription_publish_req &
        p_resp_msg : t_msg_i &
        p_resp_msg : t_msg &
        p_resp_msg = c_msg_out &
        a_msg_out_type = e_msg_subscription_publish_resp &
        p_nb_monitored_items : NAT &
        p_nb_monitored_items : t_monitoredItemReqIndex &
        p_nb_monitored_items = nb_monitored_items
    THEN
        LET l_monitoredItemResp_StatusCode BE
            /* Evaluate the expected valid responses for which a monitored item should be allocated (e_sc_ok case) */
            l_monitoredItemResp_StatusCode =
            %mi_index.(mi_index : t_monitoredItemReqIndex &
                mi_index : 1..nb_monitored_items &
                /* ith node id has a node in the Address Space */
                mi_index : dom(MonitoredItemReq_NodeId) &
                /* Node is in the domain of the attribute */
                mi_index : dom(MonitoredItemReq_AttributeId)
                /* TODO: add use-access levels */
                |
                {TRUE |-> e_sc_bad_attribute_id_invalid,
                 FALSE |-> {TRUE |-> e_sc_bad_monitoring_mode_invalid,
                            FALSE |-> {TRUE |-> e_sc_bad_monitored_item_filter_unsupported,
                                       FALSE |-> {TRUE |-> e_sc_bad_node_id_unknown,
                                                  FALSE |-> {TRUE |-> e_sc_bad_attribute_id_invalid,
                                                             FALSE |-> {FALSE |-> e_sc_bad_index_range_invalid,
                                                                        TRUE |-> {TRUE |-> e_sc_bad_out_of_memory, /* Since we do not have limit it is the case when no more MI */
                                                                                  FALSE |-> e_sc_ok
                                                                                 }(bool(t_monitoredItemPointer = s_monitoredItemPointer or
                                                                                        t_monitoredItemId = s_monitoredItemId))
                                                                        }(bool(MonitoredItemReq_IndexRange(mi_index) : t_IndexRange))
                                                           }(bool(a_NodeId~(MonitoredItemReq_NodeId(mi_index)) /:
                                                                   dom(AttributeID_Node_Variant(MonitoredItemReq_AttributeId(mi_index))) or
                                                                   a_NodeClass_Attribute
                                                                    (a_Node_availableInFuture(MonitoredItemReq_NodeId(mi_index)) |->
                                                                       MonitoredItemReq_AttributeId(mi_index)) = FALSE))
                                                }(bool(MonitoredItemReq_NodeId(mi_index) /: dom(a_NodeId~) &
                                                       MonitoredItemReq_NodeId(mi_index) /: dom(a_Node_availableInFuture)))
                                     }(bool(MonitoredItemReq_FilterPresence(mi_index) = TRUE))
                            }(bool(MonitoredItemReq_ValidMonitoringMode(mi_index) = FALSE))
                }(bool(mi_index /: dom(MonitoredItemReq_AttributeId)))
            )
        IN
            ANY max_mi_ids, max_mi_pointers, s_maximums, nb_allocated_monitored_items WHERE
                /* Define the number of really allocated monitored items (minimum between expected and available) */
                max_mi_ids = card(t_monitoredItemId - s_monitoredItemId) &
                max_mi_pointers = card(t_monitoredItemPointer - s_monitoredItemPointer) &
                s_maximums = {max_mi_ids} \/ {max_mi_pointers} \/ {card((l_monitoredItemResp_StatusCode |> {e_sc_ok}))} &
                nb_allocated_monitored_items = min(s_maximums)
            THEN
                LET l_allocMonitoredItemResp_StatusCode BE
                    /* Define the valid responses restricted by number of allocated monitored items */
                    l_allocMonitoredItemResp_StatusCode =
                      %mi_index.(mi_index : t_monitoredItemReqIndex &
                                 mi_index : 1..nb_monitored_items
                                 |
                                 {TRUE |-> l_monitoredItemResp_StatusCode(mi_index), /* Copy if no restriction due to allocation */
                                  FALSE |-> {TRUE |-> e_sc_bad_out_of_memory, /* Since we do not have limit it is the case when no more MI */
                                             FALSE |-> l_monitoredItemResp_StatusCode(mi_index) /* Copy result if not e_sc_ok */
                                            }(bool(l_monitoredItemResp_StatusCode(mi_index) = e_sc_ok))
                                 }(bool(card((1..mi_index <| l_monitoredItemResp_StatusCode |> {e_sc_ok})) <
                                               nb_allocated_monitored_items))
                                )
                IN
                    /* Define monitored items allocated (with unique id) */
                    ANY s_newMonitoredItemId, miIndexToMiId, s_newMonitoredItemPointer, l_MonitoredItemResp_Id WHERE

                        /* Allocate the new monitored items */
                        s_newMonitoredItemId <: t_monitoredItemId &
                        s_newMonitoredItemId /\ s_monitoredItemId = {} &

                        miIndexToMiId : dom(l_allocMonitoredItemResp_StatusCode |> {e_sc_ok}) >-> t_monitoredItemId &
                        ran(miIndexToMiId) = s_newMonitoredItemId &

                        s_newMonitoredItemPointer <: t_monitoredItemPointer &
                        s_newMonitoredItemPointer /\ s_monitoredItemPointer = {} &
                        card(s_newMonitoredItemPointer) = card(s_newMonitoredItemId) &

                        /* Reserve those new monitored items for the response */
                        l_MonitoredItemResp_Id : t_monitoredItemReqIndex +-> t_monitoredItemId_i &
                        l_MonitoredItemResp_Id[dom(l_allocMonitoredItemResp_StatusCode |>> {e_sc_ok})] = {c_monitoredItemId_indet} &
                        l_MonitoredItemResp_Id[dom(l_allocMonitoredItemResp_StatusCode |> {e_sc_ok})] = ran(miIndexToMiId)
                    THEN
                        /* Define the queues of monitored items that will be modified */
                        LET miSubQueue, miIndexToNodeIds, s_miNodeQueues, s_miQueues BE
                            miSubQueue = a_monitoredItemQueue(p_subscription) &
                            /* Nodes ids concerned by the new monitored items */
                            miIndexToNodeIds = %mi_index.(mi_index : t_monitoredItemReqIndex &
                                                          mi_index : 1..nb_monitored_items &
                                                          l_allocMonitoredItemResp_StatusCode (mi_index) = e_sc_ok
                                                          |
                                                          MonitoredItemReq_NodeId(mi_index)) &
                            s_miNodeQueues = a_nodeToMonitoredItemQueue[ran(miIndexToNodeIds)] &
                            s_miQueues = {miSubQueue} \/ s_miNodeQueues
                        IN
                            /* Set response variables */
                            MonitoredItemResp_StatusCode := l_allocMonitoredItemResp_StatusCode ||
                            MonitoredItemResp_Id := l_MonitoredItemResp_Id ||

                            /* Update set of valid monitored items and their properties */
                            s_monitoredItemId := s_monitoredItemId \/ s_newMonitoredItemId ||
                            s_monitoredItemPointer := s_monitoredItemPointer \/ s_newMonitoredItemPointer ||
                            a_monitoredItemId, a_monitoredItemSubs, a_monitoredItemNodeId,
                            a_monitored_item_notifications, a_defined_monitored_items
                            :(/* Associate new pointers with new ids */
                              a_monitoredItemId <: a_monitoredItemId$0 &
                              s_newMonitoredItemPointer <<| a_monitoredItemId =
                               s_newMonitoredItemPointer <<| a_monitoredItemId$0 &
                              a_monitoredItemId[s_newMonitoredItemPointer] = s_newMonitoredItemId &
                              /* Associate new pointers with nodeIds */
                              a_monitoredItemNodeId <: a_monitoredItemNodeId$0 &
                              s_newMonitoredItemPointer <<| a_monitoredItemNodeId =
                               s_newMonitoredItemPointer <<| a_monitoredItemNodeId$0 &
                              a_monitoredItemNodeId[s_newMonitoredItemPointer] = ran(miIndexToNodeIds) &

                              /* Associate new pointers with current subscription */
                              a_monitoredItemSubs <: a_monitoredItemSubs$0 &
                              s_newMonitoredItemPointer <<| a_monitoredItemSubs =
                               s_newMonitoredItemPointer <<| a_monitoredItemSubs$0 &
                              a_monitoredItemSubs[s_newMonitoredItemPointer] = {p_subscription} &
                              /* Add notifications to subscription notification queue */
                              a_monitored_item_notifications <: a_monitored_item_notifications$0 &
                              {a_pendingNotificationQueue(p_subscription)} <<| a_monitored_item_notifications =
                               {a_pendingNotificationQueue(p_subscription)} <<| a_monitored_item_notifications$0 &
                               a_monitored_item_notifications[{a_pendingNotificationQueue(p_subscription)}] =
                               s_monitoredItemPointer &
                              /* Add monitored items to the monitored items queues */
                              a_defined_monitored_items <: a_defined_monitored_items$0 &
                              s_miQueues <<| a_defined_monitored_items =
                               s_miQueues <<| a_defined_monitored_items$0 &
                              a_defined_monitored_items[s_miQueues] = s_monitoredItemPointer
                            )
                       END
                    END
                END
            END
        END
    END
    ;


    create_notification_on_monitored_items_if_data_changed (p_monitoredItemQueue, p_old_wv_pointer, p_new_wv_pointer) =
    PRE
        p_monitoredItemQueue : t_monitoredItemQueue_i &
        p_monitoredItemQueue : t_monitoredItemQueue &
        p_old_wv_pointer : t_WriteValuePointer_i &
        p_old_wv_pointer : t_WriteValuePointer &
        p_new_wv_pointer : t_WriteValuePointer_i &
        p_new_wv_pointer : t_WriteValuePointer
    THEN
        /* notifications may have been triggered */
        a_monitored_item_notifications
        :(a_monitored_item_notifications$0 <: a_monitored_item_notifications)
        /* Note: if NodeId / AttributeId are represented in t_WriteValuePointer,
           it is possible to describe first part of criteria to generate notification.
           But other filters will be necessary (index array, ...) */
    END
    ;

    fill_delete_subscriptions_response (p_req_msg, p_resp_msg, p_has_sub, p_session_sub, p_nb_reqs) =
    PRE
        p_req_msg : t_msg_i &
        p_req_msg : t_msg &
        p_req_msg = c_msg_in &
        a_msg_in_type = e_msg_subscription_delete_subscriptions_req &
        p_resp_msg : t_msg_i &
        p_resp_msg : t_msg &
        p_resp_msg = c_msg_out &
        a_msg_out_type = e_msg_subscription_delete_subscriptions_resp &
        p_has_sub : BOOL &
        p_session_sub : t_subscription_i &
        p_nb_reqs : NAT &
        p_nb_reqs > 0 &
        p_nb_reqs <= k_n_genericOperationPerReq_max &
        p_nb_reqs = nb_delete_subscriptions &
        delete_subscriptions_resp_allocated = TRUE
    THEN
        LET l_delete_subscriptions_resp_StatusCode BE
            l_delete_subscriptions_resp_StatusCode =
              %p_index.(p_index : 1..p_nb_reqs |
                        {FALSE |-> e_sc_bad_subscription_id_invalid,
                         TRUE  |-> e_sc_ok
                        }(bool(p_has_sub = TRUE &
                               delete_subscriptions_req_sub_id(p_index) = p_session_sub &
                               delete_subscriptions_req_sub_id(p_index) : s_subscription
                              )
                         )
                       )
        IN
            delete_subscriptions_resp_StatusCode := l_delete_subscriptions_resp_StatusCode ||
            LET l_valid_sub_ids, l_deleted_subs BE
              l_valid_sub_ids =
              %p_index.(p_index : 1..p_nb_reqs &
                        l_delete_subscriptions_resp_StatusCode(p_index) = e_sc_ok
                        |
                        delete_subscriptions_req_sub_id(p_index)
                       ) &
              l_deleted_subs = ran(l_valid_sub_ids)
            IN
                s_subscription := s_subscription - l_deleted_subs ||

                a_subscription_session := l_deleted_subs <<| a_subscription_session ||
                a_publishInterval := l_deleted_subs <<| a_publishInterval ||
                a_lifetimeExpCount := l_deleted_subs <<| a_lifetimeExpCount  ||
                a_keepAliveExpCount := l_deleted_subs <<| a_keepAliveExpCount ||
                a_maxNotifsPerPublish := l_deleted_subs <<| a_maxNotifsPerPublish ||

                a_subscription_state := l_deleted_subs <<| a_subscription_state ||
                a_MoreNotifications := a_MoreNotifications - l_deleted_subs ||
                a_LifetimeCounter := l_deleted_subs <<| a_LifetimeCounter ||
                a_KeepAliveCounter := l_deleted_subs <<| a_KeepAliveCounter ||
                a_MessageSent := a_MessageSent - l_deleted_subs               ||
                a_PublishingEnabled := a_PublishingEnabled - l_deleted_subs   ||
                a_SeqNum := l_deleted_subs <<| a_SeqNum ||

                /* Queues emptied : publish responses should be sent if remaining */
                a_publish_responses := a_publish_responses |>> a_publishRequestQueue[l_deleted_subs] ||
                a_monitored_item_notifications := a_pendingNotificationQueue[l_deleted_subs] <<| a_monitored_item_notifications ||

                /* Queues deleted */
                s_notificationQueue := s_notificationQueue - a_pendingNotificationQueue[l_deleted_subs] ||
                a_pendingNotificationQueue := l_deleted_subs <<| a_pendingNotificationQueue ||

                s_publishReqQueue := s_publishReqQueue - a_publishRequestQueue[l_deleted_subs] ||
                a_publishRequestQueue := l_deleted_subs <<| a_publishRequestQueue ||


                /* Remove monitoredItems */
                LET s_removedMonitoredItemPointer BE
                    s_removedMonitoredItemPointer = a_defined_monitored_items[a_monitoredItemQueue[l_deleted_subs]]
                IN
                    s_monitoredItemPointer := s_monitoredItemPointer - s_removedMonitoredItemPointer ||
                    s_monitoredItemId := s_monitoredItemId - a_monitoredItemId[s_removedMonitoredItemPointer] ||
                    a_monitoredItemId := a_monitoredItemId - (s_removedMonitoredItemPointer <| a_monitoredItemId) ||
                    a_monitoredItemSubs := s_removedMonitoredItemPointer <<| a_monitoredItemSubs ||
                    a_monitoredItemNodeId := s_removedMonitoredItemPointer <<| a_monitoredItemNodeId ||

                    s_monitoredItemQueue := s_monitoredItemQueue - a_monitoredItemQueue[l_deleted_subs] ||
                    a_monitoredItemQueue := l_deleted_subs <<| a_monitoredItemQueue ||

                    /* Remove subscription monitoredItem queue and all removed monitored items from other queues (i.e.:nodeId to mi queues) */
                    a_defined_monitored_items :=
                    a_monitoredItemQueue[l_deleted_subs]
                    <<| a_defined_monitored_items |>>
                    s_removedMonitoredItemPointer
                END ||
                a_publishTimer := l_deleted_subs <<| a_publishTimer
            END
        END
    END
    ;

    fill_set_publishing_mode_response (p_req_msg, p_resp_msg, p_has_sub, p_session_sub, p_pub_enabled, p_nb_reqs) =
    PRE
        p_req_msg : t_msg_i &
        p_req_msg : t_msg &
        p_req_msg = c_msg_in &
        a_msg_in_type = e_msg_subscription_set_publishing_mode_req &
        p_resp_msg : t_msg_i &
        p_resp_msg : t_msg &
        p_resp_msg = c_msg_out &
        a_msg_out_type = e_msg_subscription_set_publishing_mode_resp &
        p_has_sub : BOOL &
        p_session_sub : t_subscription_i &
        p_pub_enabled : BOOL &
        p_nb_reqs : NAT &
        p_nb_reqs > 0 &
        p_nb_reqs <= k_n_genericOperationPerReq_max &
        p_nb_reqs = nb_set_publishing_mode &
        set_publishing_mode_resp_allocated = TRUE
    THEN
        LET l_set_publishing_mode_resp_StatusCode BE
            l_set_publishing_mode_resp_StatusCode =
              %p_index.(p_index : 1..p_nb_reqs |
                        {FALSE |-> e_sc_bad_subscription_id_invalid,
                         TRUE  |-> e_sc_ok
                        }(bool(p_has_sub = TRUE & set_publishing_mode_req_sub_id(p_index) = p_session_sub))
                       )
        IN
            set_publishing_mode_resp_StatusCode := l_set_publishing_mode_resp_StatusCode ||
            LET l_valid_sub_ids BE
              l_valid_sub_ids =
              %p_index.(p_index : 1..p_nb_reqs &
                        l_set_publishing_mode_resp_StatusCode(p_index) = e_sc_ok
                        |
                        set_publishing_mode_req_sub_id(p_index)
                       )
            IN
                IF p_pub_enabled = TRUE
                THEN
                    a_PublishingEnabled := a_PublishingEnabled \/ ran(l_valid_sub_ids)
                ELSE
                    a_PublishingEnabled := a_PublishingEnabled - ran(l_valid_sub_ids)
                END
            END
        END
    END

OPERATIONS

    /* LOCAL OPERATIONS */
    fill_publish_response_msg (p_resp_msg, p_subscription, p_moreNotifs) =
    VAR
        l_republishQueue,
        l_nb_seq_nums,
        l_bres
    IN
        l_republishQueue <-- get_subscription_notifRepublishQueue (p_subscription);
        l_nb_seq_nums <-- get_available_republish (l_republishQueue);
        IF l_nb_seq_nums > 0
        THEN
            l_bres <-- allocate_subscription_available_seq_nums (p_resp_msg, l_nb_seq_nums);
            IF l_bres = TRUE
            THEN
                fill_publish_response_msg_available_seq_nums (p_resp_msg, l_republishQueue, l_nb_seq_nums)
            END
        END
        ;
        set_msg_publish_resp_subscription (p_resp_msg, p_subscription);
        set_msg_publish_resp_notificationMsg (p_resp_msg, p_moreNotifs)
    END
    ;

    fill_publish_response_msg_ack_results (p_session, p_req_msg, p_resp_msg, p_nb_acks) =
    VAR
        l_has_sub,
        l_session_sub,
        l_index,
        l_sub,
        l_seq_num,
        l_valid_seq_num
    IN
        l_has_sub, l_session_sub <-- getall_subscription (p_session);
        l_index := 1;
        WHILE l_index <= p_nb_acks DO
            l_sub, l_seq_num <-- getall_msg_publish_request_ack (p_req_msg, l_index);
            IF l_has_sub = TRUE & l_sub = l_session_sub
            THEN
                l_valid_seq_num <-- subscription_ack_notif_msg (l_session_sub, l_seq_num);
                IF l_valid_seq_num = TRUE
                THEN
                    setall_msg_publish_resp_ack_result (p_resp_msg, l_index, e_sc_ok)
                ELSE
                    setall_msg_publish_resp_ack_result (p_resp_msg, l_index, e_sc_bad_sequence_number_unknown)
                END
            ELSE
                setall_msg_publish_resp_ack_result (p_resp_msg, l_index, e_sc_bad_subscription_id_invalid)
            END;
            l_index := l_index + 1
        INVARIANT
            dom(subscription_ack_resp_StatusCode) = 1..l_index &
            dom(subscription_ack_req_ackSeqNum) = 1..p_nb_acks
        VARIANT
            (p_nb_acks - l_index)
        END
    END
    ;

    fill_publish_response_msg_available_seq_nums (p_resp_msg, republishQueue, nb_seq_nums) =
    VAR
        l_continue,
        l_republishIterator,
        l_index,
        l_seq_num
    IN
        l_index := 1;
        l_continue, l_republishIterator <-- init_iter_notif_republish (republishQueue);
        WHILE l_continue = TRUE & l_index <= nb_seq_nums DO
            l_continue, l_seq_num <-- continue_iter_notif_republish (republishQueue, l_republishIterator);
            setall_msg_publish_resp_available_seq_num (p_resp_msg, l_index, l_seq_num);
            l_index := l_index + 1
        INVARIANT
            s_to_iterate_sub_seq_num /\ s_iterated_sub_seq_num = {} &
            s_to_iterate_sub_seq_num \/ s_iterated_sub_seq_num =
             a_notification_seq_num[a_republish_notification~[{republishQueue}]]
        VARIANT
            card(s_to_iterate_sub_seq_num)
        END
        ;
        clear_notif_republish_iterator (republishQueue, l_republishIterator)
    END
    ;

    fill_response_subscription_create_monitored_items (p_session, p_subscription, p_tsToReturn, p_user, p_locales, p_req_msg, p_resp_msg, p_nb_monitored_items) =
    VAR
        l_endpoint_config_idx,
        l_continue,
        l_index,
        l_bres,
        l_bres_presentNode,
        l_bres_absent_knownNode,
        l_knownNodeClass,
        l_nid,
        l_aid,
        l_monitMode,
        l_clientHandle,
        l_samplingItv,
        l_queueSize,
        l_node,
        l_sc,
        l_value,
        l_valueSc,
        l_val_ts_src,
        l_val_ts_srv,
        l_monitoredItemPointer,
        l_monitoredItemId,
        l_revSamplingItv,
        l_revQueueSize,
        l_indexRange
    IN
        l_endpoint_config_idx <-- session_get_endpoint_config(p_session);
        l_continue <-- init_iter_monitored_item_request(p_nb_monitored_items);
        WHILE l_continue = TRUE DO
            l_node := c_Node_indet;
            l_value := c_Variant_indet;
            l_monitoredItemId := c_monitoredItemId_indet;
            l_revSamplingItv := c_opcua_duration_indet;
            l_revQueueSize := 0;
            l_indexRange := c_IndexRange_indet;
            l_continue, l_index <-- continue_iter_monitored_item_request;
            l_bres, l_sc, l_nid, l_aid, l_monitMode, l_clientHandle, l_samplingItv, l_queueSize, l_indexRange
              <-- getall_monitored_item_req_params(p_req_msg, l_index);
            /* Check validity of NodeId */
            IF l_bres = TRUE
            THEN
                l_bres_presentNode, l_node <-- readall_AddressSpace_Node (l_nid);
                l_bres_absent_knownNode, l_knownNodeClass, l_valueSc <-- if_not_present_is_Node_known(l_bres_presentNode, l_endpoint_config_idx, l_nid);
                IF l_bres_presentNode = FALSE & l_bres_absent_knownNode = FALSE
                THEN
                    l_sc := e_sc_bad_node_id_unknown
                ELSE
                    IF l_bres_presentNode = TRUE
                    THEN
                        /* Read monitored item value */
                        l_sc, l_value, l_valueSc, l_val_ts_src, l_val_ts_srv <-- read_Node_Attribute(p_user, p_locales, l_node, l_nid, l_aid, l_indexRange)
                    ELSE
                        /* Known node but not yet available: evaluate attribute based on NodeClass and check if index range is not invalid */
                        l_sc, l_value, l_val_ts_src, l_val_ts_srv <-- eval_knownNode_requested_properties(l_nid, l_knownNodeClass, l_aid, l_indexRange)
                    END;
                    /* Create monitored item */
                    /* From part 4:
                       When a user adds a monitored item that the user is denied read access to, the add operation for
                       the item shall succeed and the bad status Bad_NotReadable or Bad_UserAccessDenied shall be
                       returned in the Publish response.
                       The same procedure shall be applied for an IndexRange that does not deliver data
                       for the current value but could deliver data in the future.
                    */
                    IF l_sc /= e_sc_ok & (l_sc = e_sc_bad_not_readable or
                                          l_sc = e_sc_bad_user_access_denied or
                                          l_sc = e_sc_bad_index_range_no_data)
                    THEN
                        /* For PublishResponse */
                        l_valueSc <-- getall_conv_StatusCode_To_RawStatusCode(l_sc);
                        l_sc := e_sc_ok
                    END;
                    IF l_sc = e_sc_ok
                    THEN
                        l_sc, l_monitoredItemPointer, l_monitoredItemId <-- create_monitored_item (p_subscription,
                                                                                                   l_nid,
                                                                                                   l_aid,
                                                                                                   l_indexRange,
                                                                                                   l_value,
                                                                                                   l_valueSc,
                                                                                                   l_val_ts_src,
                                                                                                   l_val_ts_srv,
                                                                                                   p_tsToReturn,
                                                                                                   l_monitMode,
                                                                                                   l_clientHandle);
                        l_revSamplingItv, l_revQueueSize <-- compute_create_monitored_item_revised_params(l_queueSize);
                        read_AddressSpace_free_variant(l_value)
                    END
                END
            END
            ;
            setall_msg_monitored_item_resp_params (p_resp_msg, l_index, l_sc, l_monitoredItemId, l_revSamplingItv, l_revQueueSize)

        INVARIANT
            rreqs_to_iterate <: t_monitoredItemReqIndex &
            rreqs_iterated   <: t_monitoredItemReqIndex &
            rreqs_to_iterate /\ rreqs_iterated = {} &
            rreqs_to_iterate \/ rreqs_iterated = 1..nb_monitored_items &
            l_continue = bool(rreqs_to_iterate /= {})

            /* TODO: reprendre les propriétés de fill_response_subscription_create_monitored_items */
        VARIANT
            card(rreqs_to_iterate)
        END
    END
    ;

    create_notification_on_monitored_items_if_data_changed (p_monitoredItemQueue, p_old_wv_pointer, p_new_wv_pointer) =
    VAR
        l_continue,
        l_iterator,
        l_monitoredItemPointer,
        l_notification_triggered,

        l_monitoredItemId,
        l_subscription,
        l_valid_subscription,
        l_session,
        l_session_valid,
        l_user,
        l_valid_user_access,
        l_nid,
        l_aid,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle
    IN
        l_continue, l_iterator <-- init_iter_monitored_item (p_monitoredItemQueue);
        WHILE l_continue = TRUE DO
            l_continue, l_monitoredItemPointer <-- continue_iter_monitored_item (l_iterator, p_monitoredItemQueue);
            /* Check if notification is triggered: indexRange is evaluated here */
            l_notification_triggered <-- is_notification_triggered (l_monitoredItemPointer, p_old_wv_pointer, p_new_wv_pointer);
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle <--getall_monitoredItemPointer (l_monitoredItemPointer);
            l_valid_subscription <-- is_valid_subscription (l_subscription);
            l_valid_user_access := FALSE;
            IF l_valid_subscription = TRUE
            THEN
                /* Note: AccessLevel not checked here, it shall be a condition to generate a DataChange event (inhibition if read forbidden)*/
                l_session <-- getall_session (l_subscription);
                l_session_valid <-- is_valid_session (l_session);
                IF l_session_valid = TRUE
                THEN
                    l_user <-- get_session_user_server(l_session);
                    /* TODO: when user access right property will be modifiable previous user right shall be
                    checked to notify a user access denied status when it is newly denied for the user
                    */
                    l_valid_user_access <-- get_user_authorization (e_operation_type_read, l_nid, l_aid, l_user)
                END
            ELSE
                l_valid_user_access := FALSE
            END
            ;
            IF l_valid_user_access = TRUE & l_notification_triggered = TRUE & l_monitoringMode = e_monitoringMode_reporting
            THEN
                /* Note: indexRange filtering on value done in C implementation for now */
                server_subscription_add_notification (l_subscription, l_monitoredItemPointer, l_timestampToReturn, p_new_wv_pointer)
            END
        INVARIANT
            s_mi_to_iterate_it <: t_monitoredItemPointer &
            s_mi_iterated_it   <: t_monitoredItemPointer &

            s_mi_to_iterate_it /\ s_mi_iterated_it = {} &
            card(s_mi_to_iterate_it \/ s_mi_iterated_it) = nb_monitored_items_it &
            l_continue = bool(s_mi_to_iterate_it /= {})

        VARIANT
            card(s_mi_to_iterate_it)
        END;
        clear_iter_monitored_item (l_iterator)
    END
    ;

    fill_delete_subscriptions_response (p_req_msg, p_resp_msg, p_has_sub, p_session_sub, p_nb_reqs) =
    VAR
        l_index,
        l_sub,
        l_sub_still_valid
    IN
        l_index := 1;
        WHILE l_index <= p_nb_reqs DO
            l_sub <-- getall_msg_delete_subscriptions_at_index (p_req_msg, l_index);
            IF p_has_sub = TRUE & l_sub = p_session_sub
            THEN
                l_sub_still_valid <-- is_valid_subscription (l_sub); /* Avoid to close 2 times same subscription */
                IF l_sub_still_valid = TRUE
                THEN
                    close_subscription (l_sub)
                END;
                setall_msg_subscription_delete_subscriptions_resp_at_index (p_resp_msg, l_index, TRUE)
            ELSE
                setall_msg_subscription_delete_subscriptions_resp_at_index (p_resp_msg, l_index, FALSE)
            END;
            l_index := l_index + 1
        INVARIANT
            dom(delete_subscriptions_resp_StatusCode) = 1..l_index &
            dom(delete_subscriptions_req_sub_id) = 1..p_nb_reqs
        VARIANT
            (p_nb_reqs - l_index)
        END
    END
    ;

    fill_set_publishing_mode_response (p_req_msg, p_resp_msg, p_has_sub, p_session_sub, p_pub_enabled, p_nb_reqs) =
    VAR
        l_index,
        l_sub
    IN
        l_index := 1;
        WHILE l_index <= p_nb_reqs DO
            l_sub <-- getall_msg_set_publishing_mode_at_index (p_req_msg, l_index);
            IF p_has_sub = TRUE & l_sub = p_session_sub
            THEN
                set_subscription_PublishingEnabled (l_sub, p_pub_enabled);
                setall_msg_subscription_set_publishing_mode_resp_at_index (p_resp_msg, l_index, TRUE)
            ELSE
                setall_msg_subscription_set_publishing_mode_resp_at_index (p_resp_msg, l_index, FALSE)
            END;
            l_index := l_index + 1
        INVARIANT
            dom(set_publishing_mode_resp_StatusCode) = 1..l_index &
            dom(set_publishing_mode_req_sub_id) = 1..p_nb_reqs
        VARIANT
            (p_nb_reqs - l_index)
        END
    END
    ;

    /* END OF LOCAL OPERATIONS */

    StatusCode_service <-- treat_create_subscription_request (p_session, p_req_msg, p_resp_msg) =
    VAR
        l_session_has_subscription,
        l_sub,
        l_reqPublishInterval,
        l_reqLifetimeCount,
        l_reqMaxKeepAlive,
        l_maxNotificationsPerPublish,
        l_publishEnabled,
        l_subscription,
        l_revisedPublishInterval,
        l_revisedLifetimeCount,
        l_revisedMaxKeepAlive,
        l_revisedMaxNotificationsPerPublish
    IN
        l_session_has_subscription, l_sub <-- getall_subscription (p_session);
        IF l_session_has_subscription = FALSE
        THEN
            /* Extract create subscription parameters */
            l_reqPublishInterval, l_reqLifetimeCount, l_reqMaxKeepAlive, l_maxNotificationsPerPublish, l_publishEnabled
              <-- get_msg_create_subscription_req_params (p_req_msg);

            /* Compute revised parameters */
            l_revisedPublishInterval, l_revisedLifetimeCount, l_revisedMaxKeepAlive, l_revisedMaxNotificationsPerPublish
              <-- compute_create_subscription_revised_params (l_reqPublishInterval,
                                                              l_reqLifetimeCount,
                                                              l_reqMaxKeepAlive,
                                                              l_maxNotificationsPerPublish);

            /* Create subscription */
            StatusCode_service, l_subscription <-- create_subscription (p_session,
                l_revisedPublishInterval,
                l_revisedLifetimeCount,
                l_revisedMaxKeepAlive,
                l_revisedMaxNotificationsPerPublish,
                l_publishEnabled);
            IF StatusCode_service = e_sc_ok
            THEN
                /* Fill values to response message */
                set_msg_create_subscription_resp_params (p_resp_msg,
                    l_subscription,
                    l_revisedPublishInterval,
                    l_revisedLifetimeCount,
                    l_revisedMaxKeepAlive)
            END
        ELSE
            StatusCode_service := e_sc_bad_too_many_subscriptions
        END
    END
    ;

    StatusCode_service <-- treat_modify_subscription_request (p_session, p_req_msg, p_resp_msg) =
    VAR
        l_session_has_subscription,
        l_session_sub,
        l_sub,
        l_reqPublishInterval,
        l_reqLifetimeCount,
        l_reqMaxKeepAlive,
        l_maxNotifPerPublish,
        l_revisedPublishInterval,
        l_revisedLifetimeCount,
        l_revisedMaxKeepAlive,
        l_revisedMaxNotificationsPerPublish
    IN
        l_session_has_subscription, l_session_sub <-- getall_subscription (p_session);
        /* Extract create subscription parameters */
        l_sub, l_reqPublishInterval, l_reqLifetimeCount, l_reqMaxKeepAlive, l_maxNotifPerPublish
          <-- get_msg_modify_subscription_req_params (p_req_msg);
        IF l_session_has_subscription = TRUE & l_sub = l_session_sub
        THEN

            /* Compute revised parameters */
            l_revisedPublishInterval, l_revisedLifetimeCount, l_revisedMaxKeepAlive, l_revisedMaxNotificationsPerPublish
              <-- compute_create_subscription_revised_params (l_reqPublishInterval,
                                                              l_reqLifetimeCount,
                                                              l_reqMaxKeepAlive,
                                                              l_maxNotifPerPublish);

            /* Modify subscription */
            /* Guaranteed by getall_subscription: a_subscription_session (p_subscription) = p_session */
            modify_subscription (l_session_sub,
                                 l_revisedPublishInterval,
                                 l_revisedLifetimeCount,
                                 l_revisedMaxKeepAlive,
                                 l_revisedMaxNotificationsPerPublish);

            /* Fill values to response message */
            set_msg_modify_subscription_resp_params (p_resp_msg,
                                                     l_revisedPublishInterval,
                                                     l_revisedLifetimeCount,
                                                     l_revisedMaxKeepAlive);

            StatusCode_service := e_sc_ok
        ELSE
            StatusCode_service := e_sc_bad_subscription_id_invalid
        END
    END
    ;

    StatusCode_service <-- treat_delete_subscriptions_request (p_session, p_req_msg, p_resp_msg) =
    VAR
        l_session_has_subscription,
        l_session_sub,
        l_nb_reqs,
        l_bres
    IN
        l_nb_reqs <-- getall_msg_delete_subscriptions_req_params (p_req_msg);
        IF l_nb_reqs > 0 & l_nb_reqs <= k_n_genericOperationPerReq_max
        THEN
            l_session_has_subscription, l_session_sub <-- getall_subscription (p_session);
            l_bres <-- allocate_msg_delete_subscriptions_resp_results_array (p_resp_msg, l_nb_reqs);
            IF l_bres = TRUE
            THEN
                fill_delete_subscriptions_response
                  (p_req_msg, p_resp_msg, l_session_has_subscription, l_session_sub, l_nb_reqs);
                StatusCode_service := e_sc_ok
            ELSE
                StatusCode_service := e_sc_bad_out_of_memory
            END
        ELSIF l_nb_reqs <= 0
        THEN
            StatusCode_service := e_sc_bad_nothing_to_do
        ELSE
            StatusCode_service := e_sc_bad_too_many_ops
        END
    END
    ;

    StatusCode_service <-- treat_publishing_mode_request (p_session, p_req_msg, p_resp_msg) =
    VAR
        l_session_has_subscription,
        l_session_sub,
        l_nb_reqs,
        l_pub_enabled,
        l_bres
    IN
        l_nb_reqs, l_pub_enabled <-- getall_msg_subscription_set_publishing_mode_params (p_req_msg);
        IF l_nb_reqs > 0 & l_nb_reqs <= k_n_genericOperationPerReq_max
        THEN
            l_session_has_subscription, l_session_sub <-- getall_subscription (p_session);
            l_bres <-- allocate_msg_subscription_set_publishing_mode_resp_results_array (p_resp_msg, l_nb_reqs);
            IF l_bres = TRUE
            THEN
                fill_set_publishing_mode_response
                  (p_req_msg, p_resp_msg, l_session_has_subscription, l_session_sub, l_pub_enabled, l_nb_reqs);
                StatusCode_service := e_sc_ok
            ELSE
                StatusCode_service := e_sc_bad_out_of_memory
            END
        ELSIF l_nb_reqs <= 0
        THEN
            StatusCode_service := e_sc_bad_nothing_to_do
        ELSE
            StatusCode_service := e_sc_bad_too_many_ops
        END
    END
    ;

    StatusCode_service, async_resp_msg
      <-- treat_subscription_publish_request (p_session, p_req_header, p_req_msg, p_req_handle, p_req_ctx, p_resp_msg) =
    VAR
        l_session_has_subscription,
        l_sub,
        l_req_exp_time,
        l_nb_subscriptionAcks,
        /* l_nb_avail_seq_nums, */
        l_subscription,
        l_moreNotifs,
        l_bres
    IN
        l_subscription := c_subscription_indet;
        l_moreNotifs := FALSE;
        async_resp_msg := FALSE;
        l_session_has_subscription, l_sub <-- getall_subscription (p_session);
        IF l_session_has_subscription = TRUE
        THEN
            /* Extract values from header: expiration time for Publish Request */
            l_req_exp_time <-- get_msg_header_expiration_time (p_req_header);

            /* TODO: remove when used */
            l_nb_subscriptionAcks <-- get_msg_publish_request_ack_params (p_req_msg);
            IF l_nb_subscriptionAcks > 0 & l_nb_subscriptionAcks <= k_n_genericOperationPerReq_max
            THEN
                l_bres <-- allocate_subscription_ack_results (p_resp_msg, l_nb_subscriptionAcks);
                IF l_bres = TRUE
                THEN
                    fill_publish_response_msg_ack_results (p_session, p_req_msg, p_resp_msg, l_nb_subscriptionAcks);
                    StatusCode_service := e_sc_ok
                ELSE
                    StatusCode_service := e_sc_bad_out_of_memory
                END
            ELSIF l_nb_subscriptionAcks > k_n_genericOperationPerReq_max
            THEN
                StatusCode_service := e_sc_bad_too_many_ops
            ELSE
                StatusCode_service := e_sc_ok
            END
            ;

            IF StatusCode_service = e_sc_ok
            THEN

                StatusCode_service, async_resp_msg, l_subscription, l_moreNotifs
                  <-- receive_publish_request (p_session, l_req_exp_time, p_req_handle, p_req_ctx, p_resp_msg)
            END
            ;
            IF StatusCode_service = e_sc_ok &
                async_resp_msg = FALSE
            THEN
                fill_publish_response_msg (p_resp_msg, l_subscription, l_moreNotifs)
            END
        ELSE
            StatusCode_service := e_sc_bad_no_subscription
        END
    END
    ;

    StatusCode_service <-- treat_subscription_republish_request (p_session, p_req_msg, p_resp_msg) =
    VAR
        l_session_has_subscription,
        l_session_sub,
        l_sub,
        l_seq_num,
        l_republishQueue,
        l_bres,
        l_notifMsg
    IN
        l_sub, l_seq_num <-- getall_msg_republish_request (p_req_msg);
        l_session_has_subscription, l_session_sub <-- getall_subscription (p_session);
        IF l_session_has_subscription = TRUE & l_session_sub = l_sub
        THEN
            l_republishQueue <-- get_subscription_notifRepublishQueue (l_session_sub);
            l_bres, l_notifMsg <-- get_republish_notif_from_queue (l_republishQueue, l_seq_num);
            IF l_bres = TRUE
            THEN
                StatusCode_service <-- setall_msg_republish_response (p_resp_msg, l_notifMsg)
            ELSE
                StatusCode_service := e_sc_bad_message_not_available
            END
        ELSE
            StatusCode_service := e_sc_bad_subscription_id_invalid
        END
    END
    ;


    StatusCode_service <-- treat_subscription_create_monitored_items_req (p_session, p_user, p_req_msg, p_resp_msg) =
    VAR
        l_sc,
        l_subscription,
        l_valid_subscription,
        l_timestampToRet,
        l_nb_monitored_items,
        l_locales,
        l_bres
    IN
        l_sc, l_subscription, l_timestampToRet, l_nb_monitored_items <-- getall_msg_create_monitored_items_req_params (p_req_msg);
        IF l_sc = e_sc_ok
        THEN
            l_valid_subscription <-- is_valid_subscription_on_session (p_session, l_subscription);
            IF l_valid_subscription = TRUE
            THEN
                l_bres <-- alloc_msg_create_monitored_items_resp_results (p_resp_msg, l_nb_monitored_items);
                IF l_bres = TRUE
                THEN
                    l_locales <-- get_server_session_preferred_locales(p_session);
                    fill_response_subscription_create_monitored_items
                      (p_session, l_subscription, l_timestampToRet, p_user, l_locales, p_req_msg, p_resp_msg, l_nb_monitored_items);
                    StatusCode_service := e_sc_ok
                ELSE
                    StatusCode_service := e_sc_bad_out_of_memory
                END
            ELSE
                StatusCode_service := e_sc_bad_subscription_id_invalid
            END
        ELSE
            StatusCode_service := l_sc
        END
    END
    ;

    server_subscription_data_changed (p_old_write_value_pointer, p_new_write_value_pointer) =
    VAR
        l_nid,
        l_aid,
        l_nid_valid,
        l_node,
        l_monitoredItemQueue,
        l_bres
    IN
        l_nid, l_aid <-- get_write_value_pointer_NodeId_AttributeId (p_new_write_value_pointer);
        l_nid_valid, l_node <-- readall_AddressSpace_Node (l_nid);
        IF l_nid_valid = TRUE
        THEN
            l_bres, l_monitoredItemQueue <-- get_nodeToMonitoredItemQueue (l_nid);
            IF l_bres = TRUE
            THEN
                create_notification_on_monitored_items_if_data_changed
                (l_monitoredItemQueue, p_old_write_value_pointer, p_new_write_value_pointer)
            END // TODO: log error
        END;
        free_write_value_pointer (p_old_write_value_pointer);
        free_write_value_pointer (p_new_write_value_pointer)
    END
    ;

    server_subscription_publish_timeout (p_subscription) =
    VAR
        l_closeSubscription,
        l_msg_to_send,
        l_msg_sc,
        l_session,
        l_publish_resp_msg,
        l_req_handle,
        l_req_context,
        l_moreNotifs,
        l_validPublishingReqQueued
    IN
        l_closeSubscription, l_msg_to_send, l_session, l_publish_resp_msg,
        l_req_handle, l_req_context, l_validPublishingReqQueued
          <-- server_subscription_core_publish_timeout_check_lifetime (p_subscription);

        IF l_closeSubscription = FALSE
        THEN
            l_msg_to_send, l_msg_sc, l_session, l_publish_resp_msg,
            l_req_handle, l_req_context, l_moreNotifs
              <-- server_subscription_core_publish_timeout (p_subscription, l_validPublishingReqQueued);

            IF l_msg_to_send = TRUE
            THEN
                fill_publish_response_msg (l_publish_resp_msg, p_subscription, l_moreNotifs);
                generate_internal_send_publish_response_event (l_session,
                                                               l_publish_resp_msg,
                                                               l_req_handle,
                                                               l_req_context,
                                                               l_msg_sc);
                IF l_moreNotifs = TRUE
                THEN
                    /* TODO: move in a LOCAL operation and specify variables changes */
                    l_validPublishingReqQueued <-- server_subscription_core_check_valid_publish_req_queue (p_subscription);
                    WHILE l_moreNotifs = TRUE & l_validPublishingReqQueued = TRUE DO
                        l_msg_to_send, l_msg_sc, l_session, l_publish_resp_msg,
                        l_req_handle, l_req_context, l_moreNotifs <-- server_subscription_core_publish_timeout_return_moreNotifs (p_subscription);
                        fill_publish_response_msg (l_publish_resp_msg, p_subscription, l_moreNotifs);
                        generate_internal_send_publish_response_event (l_session,
                            l_publish_resp_msg,
                            l_req_handle,
                            l_req_context,
                            l_msg_sc);
                        IF l_moreNotifs = TRUE
                        THEN
                            l_validPublishingReqQueued <-- server_subscription_core_check_valid_publish_req_queue (p_subscription)
                        END
                    INVARIANT
                        l_validPublishingReqQueued = validPublishReqQueued &
                        l_moreNotifs = bool(a_monitored_item_notifications[{a_pendingNotificationQueue(p_subscription)}] /= {})
                    VARIANT
                        card(a_monitored_item_notifications[{a_pendingNotificationQueue(p_subscription)}]) +
                        /* necessary in case allocation failed: notification queue will not decrease */
                        card(a_publish_responses~[{a_publishRequestQueue (p_subscription)}])
                    END
                END
            END
        ELSE
            close_subscription (p_subscription);
            IF l_msg_to_send = TRUE /* Seems to be impossible: see server_subscription_core_publish_timeout_check_lifetime */
            THEN
                /* Fill IssueStatusChangedNotification message */
                fill_publish_response_msg (l_publish_resp_msg, p_subscription, FALSE);
                generate_internal_send_publish_response_event (l_session,
                                                               l_publish_resp_msg,
                                                               l_req_handle,
                                                               l_req_context,
                                                               e_sc_ok)
            END
        END
    END
    ;

    server_subscription_session_inactive (p_session, p_newSessionState) =
    VAR
        l_has_sub,
        l_sub
    IN
        l_has_sub, l_sub <-- getall_subscription (p_session);
        IF l_has_sub = TRUE
        THEN
            IF p_newSessionState = e_session_scOrphaned or
               p_newSessionState = e_session_scActivating or
               p_newSessionState = e_session_closed
            THEN
                /* SC is not valid anymore for the session
                   => publish requests are not valid anymore on another SC */
                empty_session_publish_requests (l_sub);
                IF p_newSessionState = e_session_closed
                THEN
                    /* A session transfer is only possible with same user,
                       which means the previous session still exist.
                       Only other option is to keep the user waiting for
                       potential new session for transfer (but OPC UA spec does not state that)
                     */
                    close_subscription (l_sub)
                END
            END
        END
    END
    ;

    subscription_mgr_UNINITIALISATION =
    BEGIN
        subscription_core_UNINITIALISATION
    END

END
