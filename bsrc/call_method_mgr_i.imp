/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    call_method_mgr_i
REFINES
    call_method_mgr
    
SEES
    address_space,
    constants,
    constants_statuscodes_bs,
    channel_mgr,
    message_in_bs,
    message_out_bs,
    request_handle_bs,
    session_mgr
    
DEFINITIONS
    "definitions.def"
    
IMPORTS
    call_method_bs,
    call_method_it,
    call_method_result_it,
    msg_call_method_bs
    
LOCAL_OPERATIONS
    
    StatusCode <-- treat_one_method_call (p_session, p_req_msg, p_res_msg, p_callMethod, p_endpoint_config_idx) =
    PRE
        p_session : t_session_i &
        p_session : t_session &
        p_req_msg : t_msg_i &
        p_req_msg : t_msg &
        p_req_msg = CallMethod_Msg &
        p_res_msg : t_msg_i &
        p_res_msg : t_msg &
        p_res_msg = CallMethodRes_Msg &
        p_callMethod : t_CallMethod_i &
        p_callMethod : CallMethods &
        p_endpoint_config_idx : t_endpoint_config_idx_i &
        p_endpoint_config_idx : t_endpoint_config_idx

    THEN
        StatusCode,
        CallMethodRes_status,
        CallMethodRes_AllocatedInputArgumentResult,
        CallMethodRes_InputArgumentResult,
        CallMethodRes_AllocatedOutputArgument,
        CallMethodRes_OutputArgument
        :(
            StatusCode : t_StatusCode_i &
            StatusCode : {e_sc_bad_arguments_missing,
                e_sc_bad_too_many_arguments,
                e_sc_bad_invalid_argument,
                e_sc_bad_method_invalid,
                e_sc_bad_not_executable} &
            
            CallMethodRes_Msg                    : t_msg_i &
            CallMethodRes_status                 : t_CallMethod --> t_StatusCode_i      &
            CallMethodRes_AllocatedInputArgumentResult : t_CallMethod --> NAT1          &
            CallMethodRes_InputArgumentResult    : t_CallMethod --> seq(t_StatusCode_i) &
            CallMethodRes_AllocatedOutputArgument      : t_CallMethod --> NAT1          &
            CallMethodRes_OutputArgument         : t_CallMethod --> seq(t_Variant_i)    &
            dom(CallMethodRes_status) = dom(CallMethodRes_InputArgumentResult)          &
            dom(CallMethodRes_status) = dom(CallMethodRes_OutputArgument) &
            
            {p_callMethod} <<| CallMethodRes_status = {p_callMethod} <<| CallMethodRes_status$0 &
            CallMethodRes_status(p_callMethod) = StatusCode &
            {p_callMethod} <<| CallMethodRes_AllocatedInputArgumentResult =
            {p_callMethod} <<| CallMethodRes_AllocatedInputArgumentResult$0 &
            {p_callMethod} <<| CallMethodRes_InputArgumentResult =
            {p_callMethod} <<| CallMethodRes_InputArgumentResult$0 &
            {p_callMethod} <<| CallMethodRes_AllocatedOutputArgument =
            {p_callMethod} <<| CallMethodRes_AllocatedOutputArgument$0 &
            {p_callMethod} <<| CallMethodRes_OutputArgument = {p_callMethod} <<| CallMethodRes_OutputArgument$0 &
            
            ( StatusCode /= e_sc_bad_invalid_argument
                =>
                CallMethodRes_AllocatedInputArgumentResult(p_callMethod) = 0 &
                size(CallMethodRes_InputArgumentResult(p_callMethod)) = 0
            ) &
            ( StatusCode = e_sc_bad_invalid_argument
                =>
                CallMethodRes_AllocatedInputArgumentResult(p_callMethod) = size(CallMethod_InputArguments(p_callMethod)) &
                size(CallMethodRes_InputArgumentResult(p_callMethod)) = size(CallMethod_InputArguments(p_callMethod)) 
            )
            
        )
        
    END
    ;
    
    /*
    Check object, method and inputArgument
    */
    StatusCode <-- check_method_call_inputs (p_session, p_req_msg, p_callMethod)=
    PRE
        p_session : t_session_i &
        p_session : t_session &
        p_req_msg : t_msg_i &
        p_req_msg : t_msg &
        p_req_msg = CallMethod_Msg &
        p_callMethod : t_CallMethod_i &
        p_callMethod : CallMethods
        
    THEN
        StatusCode
        :(
            StatusCode : t_StatusCode_i &
            StatusCode :
            {
                e_sc_bad_arguments_missing,
                e_sc_bad_too_many_arguments,
                e_sc_bad_invalid_argument,
                e_sc_bad_method_invalid,
                e_sc_bad_not_executable
            }
        )
    END
    ;
    
    StatusCode <-- check_exec_result (p_req_msg, p_callMethod)=
    PRE
        p_req_msg : t_msg_i &
        p_req_msg : t_msg &
        p_req_msg = CallMethod_Msg &
        p_callMethod : t_CallMethod_i &
        p_callMethod : CallMethods
        
    THEN
        StatusCode :: t_StatusCode_i /* TODO */
    END
    ;
    
    StatusCode <-- copy_exec_result (p_res_msg, p_callMethod)=
    PRE
        p_res_msg : t_msg_i &
        p_res_msg : t_msg &
        p_res_msg = CallMethodRes_Msg &
        p_callMethod : t_CallMethod_i &
        p_callMethod : CallMethods    &
        p_callMethod : dom(CallMethodRes_OutputArgument)
    THEN
        StatusCode,
        CallMethodRes_AllocatedOutputArgument,
        CallMethodRes_OutputArgument
        :(
            StatusCode : t_StatusCode_i  &
            StatusCode : {e_sc_ok, e_sc_bad_out_of_memory} &
            {p_callMethod} <<| CallMethodRes_AllocatedOutputArgument =
            {p_callMethod} <<| CallMethodRes_AllocatedOutputArgument$0 &
            {p_callMethod} <<| CallMethodRes_OutputArgument = {p_callMethod} <<| CallMethodRes_OutputArgument$0 &
            (StatusCode = e_sc_ok
                =>
                CallMethodRes_AllocatedOutputArgument(p_callMethod) = size(exec_result) &
                CallMethodRes_OutputArgument(p_callMethod) = exec_result 
            ) &
            (StatusCode = e_sc_bad_out_of_memory
                =>
                CallMethodRes_AllocatedOutputArgument(p_callMethod) = 0 &
                CallMethodRes_OutputArgument(p_callMethod) = {}
            )
        )
    END
    ;
    
    statusCode, node <-- check_nodeId(nodeid)=
    PRE
        nodeid : t_NodeId_i &
        nodeid : t_NodeId
    THEN
        IF nodeid = c_NodeId_indet
        THEN
            statusCode := e_sc_bad_node_id_invalid ||
            node := c_Node_indet
        ELSIF nodeid /: dom(a_NodeId~)
        THEN
            statusCode := e_sc_bad_node_id_unknown ||
            node := c_Node_indet
        ELSE
            statusCode := e_sc_ok ||
            node := a_NodeId~(nodeid)
        END
    END
    ;
    
    endpoint_config_idx <-- session_get_endpoint_config(p_session) =
    PRE
        p_session : t_session_i &
        p_session : t_session
    THEN
        endpoint_config_idx :: t_endpoint_config_idx_i
    END
    
OPERATIONS
    
    
    StatusCode_service <-- treat_method_call_request (p_session, p_req_msg, p_resp_msg) =
    VAR
        
        l_endpoint_config_idx ,
        l_continue,
        l_nb,
        l_status_op,
        l_callMethod
    IN
        l_endpoint_config_idx <-- session_get_endpoint_config(p_session);
        IF l_endpoint_config_idx  /= c_endpoint_config_idx_indet THEN
            StatusCode_service, l_nb <-- read_call_method_request (p_req_msg);
            IF StatusCode_service = e_sc_ok THEN
                l_continue <-- init_iter_callMethods (p_req_msg);
                IF l_continue = FALSE THEN
                    StatusCode_service := e_sc_bad_nothing_to_do
                ELSIF l_nb > k_n_genericOperationPerReq_max THEN
                    StatusCode_service := e_sc_bad_too_many_ops
                ELSE
                    StatusCode_service <-- alloc_CallMethod_Result(p_resp_msg, l_nb);
                    l_continue := bool(StatusCode_service = e_sc_ok);
                    WHILE l_continue = TRUE
                    DO
                        l_continue, l_callMethod <-- continue_iter_callMethod;
                        l_status_op <-- treat_one_method_call (p_session, p_req_msg, p_resp_msg, l_callMethod, l_endpoint_config_idx);
                        IF l_status_op = e_sc_bad_out_of_memory THEN
                            l_continue := FALSE;
                            StatusCode_service := e_sc_bad_out_of_memory
                        END
                    INVARIANT
                        0 = 1
                    VARIANT
                        0
                    END
                END
            END
        ELSE
            StatusCode_service := e_sc_bad_session_id_invalid
        END
    END
    ;
    
    
    /* LOCAL OPERATIONS */
    
    StatusCode <-- treat_one_method_call (p_session, p_req_msg, p_res_msg, p_callMethod, p_endpoint_config_idx) =
    BEGIN
        StatusCode <-- check_method_call_inputs (p_session, p_req_msg, p_callMethod);
        IF StatusCode  = e_sc_ok THEN
            
            StatusCode <-- exec_callMethod(p_req_msg, p_callMethod, p_endpoint_config_idx);
            IF StatusCode  = e_sc_ok THEN
                StatusCode <-- check_exec_result (p_req_msg, p_callMethod);
                IF StatusCode = e_sc_ok THEN
                    StatusCode <-- copy_exec_result (p_res_msg, p_callMethod)
                END
            END
            ;
            free_exec_result
        END
        ;
        write_CallMethod_Res_Status(p_res_msg, p_callMethod, StatusCode)
    END
    ;
            
    StatusCode <-- check_method_call_inputs (p_session, p_req_msg, p_callMethod)=
    VAR
        l_object,
        l_objectid,
        l_method,
        l_methodid,
        l_user,
        l_valid_executable,
        l_valid_user_executable
    IN
        
        l_objectid <-- read_CallMethod_Objectid (p_req_msg, p_callMethod);
        /* Treat e_sc_bad_node_id_invalid and e_sc_bad_node_id_unknown */
        StatusCode, l_object <-- check_nodeId(l_objectid);
        IF StatusCode = e_sc_ok THEN
            l_methodid <-- read_CallMethod_MethodId (p_req_msg, p_callMethod);
            StatusCode, l_method <-- check_nodeId(l_methodid);
            IF StatusCode = e_sc_ok THEN
                /* TODO check method belong to object
                StatusCode := e_sc_bad_method_invalid; */
                l_user <-- get_session_user_server(p_session);
                l_valid_executable <-- get_Executable(l_method);  /* TODO change by e_sc_bad_not_executable when update to Spec 1.04 */
                l_valid_user_executable <-- get_user_authorization (e_operation_type_executable, l_methodid, e_aid_UserExecutable, l_user);
                IF l_valid_executable = TRUE &
                    l_valid_user_executable = TRUE
                THEN
                    StatusCode := e_sc_bad_user_access_denied
                ELSE
                    StatusCode := e_sc_ok
                END
            ELSE
                /* Since invalid and unknown are reserved for objectId, use method invalid */
	            StatusCode := e_sc_bad_method_invalid
			END            
        END
        /* Check object */
        
         /* Check Argument {e_sc_bad_argument_missing, e_sc_bad_too_many_argument, e_sc_bad_invalid_argument}*/
        
    END
    ;
    
    StatusCode <-- check_exec_result (p_req_msg, p_callMethod)=
    BEGIN
        IF p_req_msg /= c_msg_indet &
            p_callMethod /= c_CallMethod_indet THEN
            StatusCode := e_sc_ok /* TODO return BAD if error */
        ELSE
            StatusCode := e_sc_bad_method_invalid
        END
    END
    ;
    
    StatusCode <-- copy_exec_result (p_res_msg, p_callMethod) =
    VAR
        l_continue,
        l_nb,
        l_value,
        l_index
    IN
        l_nb <-- read_nb_exec_result;
        l_continue <-- init_iter_callMethodResultIdx(l_nb);
        IF l_continue = FALSE THEN
            /* no output argument */
            StatusCode := e_sc_ok
        ELSE
            StatusCode <-- alloc_CallMethod_Res_OutputArgument(p_res_msg, p_callMethod, l_nb);
            l_continue := bool(StatusCode = e_sc_ok); 
            WHILE l_continue = TRUE
            DO
                l_continue, l_index <-- continue_iter_callMethodResultIdx;
                l_value <-- read_exec_result(l_index);
                StatusCode <-- write_CallMethod_Res_OutputArgument(p_res_msg, p_callMethod, l_index, l_value);
                l_continue := bool(l_continue = TRUE & StatusCode = e_sc_ok)
            INVARIANT
                1 = 0
            VARIANT
                0
            END
            ;
            IF StatusCode = e_sc_bad_out_of_memory THEN
                free_CallMethod_Res_OutputArgument(p_res_msg, p_callMethod)
            END
        END
    END
    ;
    
    statusCode, node <-- check_nodeId(nodeid) =
    VAR
        l_isvalid
    IN
        statusCode := e_sc_ok;
        node := c_Node_indet;
        IF nodeid = c_NodeId_indet
        THEN
            statusCode := e_sc_bad_node_id_invalid
        ELSE
            l_isvalid, node <-- readall_AddressSpace_Node(nodeid);
            IF l_isvalid = FALSE
            THEN
                statusCode := e_sc_bad_node_id_unknown
            END
        END
    END
    ;  
    
    /* Get access to server configuration */
    endpoint_config_idx <-- session_get_endpoint_config(p_session) =
    VAR
        l_channel,
        l_continue
    IN        
        endpoint_config_idx := c_endpoint_config_idx_indet;
        l_continue, l_channel <-- getall_valid_session_channel (p_session);
        IF l_continue = TRUE THEN
            endpoint_config_idx <-- server_get_endpoint_config (l_channel)
        END
    END	
END
