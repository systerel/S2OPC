/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    service_browse_i

REFINES
    service_browse_r

SEES
    constants,
    constants_statuscodes_bs,
    address_space

IMPORTS
    msg_browse_response_bs

PROMOTES
    write_BrowseResponse_msg_out,
    free_browse_result,
    set_ResponseBrowse_BrowseStatus

OPERATIONS

    p_isvalid, p_nb_ref, p_src_node <-- getall_SourceNode_NbRef(p_src_nodeid) =
    VAR
        l_ref_index_begin,
        l_ref_index_end
    IN
        p_isvalid, p_src_node <-- readall_AddressSpace_Node(p_src_nodeid);
        IF  p_isvalid = TRUE THEN
            l_ref_index_begin := 0;
            l_ref_index_end   <-- get_Node_RefIndexEnd  (p_src_node);
            p_nb_ref := l_ref_index_end - l_ref_index_begin + 1;
            IF  p_nb_ref < 0 THEN
                p_nb_ref := 0
            END
        ELSE
            p_nb_ref := 0
        END
    END
    ;

    p_isallocated <-- alloc_browse_response(p_nb_bvi) =
    BEGIN
        p_isallocated <-- malloc_browse_response(p_nb_bvi)
    END
    ;

    p_isallocated, p_nb_bri <-- alloc_browse_result(p_bvi, p_nb_target_max, p_nb_target) =
    BEGIN
        IF  0 < p_nb_target_max &
            p_nb_target_max < p_nb_target
        THEN
            p_nb_bri := p_nb_target_max
        ELSE
            p_nb_bri := p_nb_target
        END;
        p_isallocated <-- malloc_browse_result(p_bvi, p_nb_bri)
    END
    ;

    p_ref_types_compat <-- Is_RefTypes_Compatible(p_is_ref_type1, p_ref_type1, p_inc_subtypes, p_ref_type2) =
    VAR
        l_node_ids_equal
    IN
        IF  p_is_ref_type1 = TRUE THEN
            l_node_ids_equal <-- is_NodeId_equal(p_ref_type1, p_ref_type2);
            IF  l_node_ids_equal = TRUE THEN
                p_ref_types_compat := TRUE
            ELSIF p_inc_subtypes = TRUE THEN
                p_ref_types_compat <-- is_transitive_subtype(p_ref_type2, p_ref_type1)
            ELSE
                p_ref_types_compat := FALSE
            END
        ELSE
            p_ref_types_compat := TRUE
        END
    END
    ;

    p_res <-- copy_target_node_browse_result(p_bvi, p_bri, p_RefType, p_NodeId, p_IsForward) =
    VAR
        l_isvalid,
        l_NodeId,
        l_node,
        l_BrowseName,
        l_DisplayName,
        l_NodeClass,
        l_TypeDefinition
    IN
        p_res := TRUE;
        set_ResponseBrowse_Res_ReferenceTypeId(p_bvi, p_bri, p_RefType);
        set_ResponseBrowse_Res_NodeId(p_bvi, p_bri, p_NodeId);
        set_ResponseBrowse_Res_Forwards(p_bvi, p_bri, p_IsForward);
        l_NodeId <-- getall_conv_ExpandedNodeId_NodeId(p_NodeId);
        l_isvalid, l_node <-- readall_AddressSpace_Node(l_NodeId);
        IF  l_isvalid = TRUE THEN
            l_BrowseName <-- get_BrowseName(l_node);
            set_ResponseBrowse_Res_BrowseName (p_bvi, p_bri, l_BrowseName);
            l_DisplayName <-- get_DisplayName(l_node);
            set_ResponseBrowse_Res_DisplayName(p_bvi, p_bri, l_DisplayName);
            l_NodeClass <-- get_NodeClass(l_node);
            set_ResponseBrowse_Res_NodeClass(p_bvi, p_bri, l_NodeClass);
            l_TypeDefinition <-- get_TypeDefinition(l_node);
            set_ResponseBrowse_Res_TypeDefinition(p_bvi, p_bri, l_TypeDefinition)
        ELSE
            reset_ResponseBrowse_Res_BrowseName    (p_bvi, p_bri);
            reset_ResponseBrowse_Res_DisplayName   (p_bvi, p_bri);
            reset_ResponseBrowse_Res_NodeClass     (p_bvi, p_bri);
            reset_ResponseBrowse_Res_TypeDefinition(p_bvi, p_bri)
        END
    END
    ;

    fill_continuation_point(p_bvi, p_continue_ref, p_ref) =
    BEGIN
        /* Spec specifies "Good" when there is a continuation point,
         * but the existing servers say that a valid "Good" is STATUS_OK... */
        set_ResponseBrowse_BrowseStatus(p_bvi, e_sc_ok);
        IF  p_continue_ref = TRUE THEN
            set_ResponseBrowse_ContinuationPoint(p_bvi, p_ref)
        ELSE
            reset_ResponseBrowse_ContinuationPoint(p_bvi)
        END
    END

END
