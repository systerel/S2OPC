/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    subscription_core_i
REFINES
    subscription_core

SEES
    address_space_itf,
    constants,
    constants_statuscodes_bs,
    message_in_bs,
    message_out_bs,
    request_handle_bs

IMPORTS
    subscription_core_1,
    subscription_core_bs,
    subscription_core_it,
    monitored_item_notification_queue_bs,
    monitored_item_queue_bs,
    monitored_item_pointer_bs,
    publish_request_queue_bs,
    notification_republish_queue_bs,
    msg_subscription_publish_bs,
    monitored_item_filter_treatment

EXTENDS
    notification_republish_queue_it_bs,
    monitored_item_queue_it_bs

PROMOTES
    /* subscription_core_1 */
    is_valid_subscription_on_session,
    is_valid_subscription,
    getall_session,
    get_card_session_seq_subscription,
    reset_subscription_LifetimeCounter,
    set_subscription_PublishingEnabled,
    get_subscription_notifRepublishQueue,
    /* subscription_core_bs */
    compute_create_subscription_revised_params,
    get_nodeToMonitoredItemQueue,
    /* monitored_item_pointer_bs*/
    is_notification_triggered,
    getall_monitoredItemPointer,
    /* msg_subscription_publish_bs */
    set_msg_publish_resp_subscription,
    set_msg_publish_resp_notificationMsg,
    generate_internal_send_publish_response_event,
    generate_internal_multi_send_publish_response_event,
    flush_internal_multi_send_publish_response_events,
    /* notif republish queue */
    get_republish_notif_from_queue,
    /* monitored_item_filter_treatment */
    get_event_user_authorization

DEFINITIONS

    d_send_notification_msg (p_subscription, p_resp_msg, p_repubQueue, p_nb_avail_data_notifs, p_nb_avail_event_notifs, p_moreNotifs, p_msg_sc) ==
    l_nb_data_notifs, l_nb_event_notifs, p_moreNotifs
          <-- local_compute_msg_nb_notifs (l_max_configured_notifications, p_nb_avail_data_notifs, p_nb_avail_event_notifs);
    /* allocate and fill notification "message" */
    l_bres, l_notifMsg <-- alloc_notification_message_items (p_resp_msg, l_nb_data_notifs, l_nb_event_notifs);
    IF l_bres = TRUE
    THEN
        /* Manage sequence number */
        l_seq_num <-- get_subscription_SeqNum (p_subscription);
        set_notification_message_sequence_number (l_notifMsg, l_seq_num);
        l_next_seq_num <-- get_next_subscription_sequence_number (l_seq_num);
        set_subscription_SeqNum (p_subscription, l_next_seq_num);

        /* Fill notification message */
        local_fill_data_notification_message (p_subscription, l_notifMsg, l_nb_data_notifs);
        local_fill_event_notification_message (p_subscription, l_notifMsg, l_nb_event_notifs);
        /* Add notification message to republish queue */
        /* + Discard oldest if maximum reached */
        l_nb_repub_notifs <-- get_nb_republish_notifs (p_repubQueue);
        IF l_nb_repub_notifs = k_n_republishNotifPerSub_max
        THEN
            discard_oldest_republish_notif (p_repubQueue)
        END
        ;
        l_bres <-- add_republish_notif_to_queue (p_repubQueue, l_seq_num, l_notifMsg);
        // Note: if it failed we will still try to send the the publish response. It has been logged as error.
        p_msg_sc := e_sc_ok
    ELSE
        p_moreNotifs := TRUE;
        p_msg_sc := e_sc_bad_out_of_memory
    END;
    set_subscription_MoreNotifications (p_subscription, p_moreNotifs);
    set_subscription_MessageSent (p_subscription)
    ;

    d_send_keepalive_msg (p_subscription, p_resp_msg, p_sc) ==
    /* prepare a keep alive message content */
    p_sc := e_sc_ok;
    /* get and fill notification "message" */
    l_notifMsg <-- get_notification_message_no_items (p_resp_msg);
    /* Get sequence number of next message to be sent (do not increment it for keep alive) */
    l_seq_num <-- get_subscription_SeqNum (p_subscription);
    set_notification_message_sequence_number (l_notifMsg, l_seq_num);
    set_subscription_MessageSent (p_subscription)

CONCRETE_VARIABLES
    next_idx_iter_prio,
    continue_iter_prio,
    session_iter_prio,
    prio_idx_iter_prio,

    nb_subs_iter_sub,
    min_idx_iter_sub,
    next_idx_iter_sub,
    idx_iter_sub

INVARIANT
    // iterator variables to iterate on the priorities of session subscriptions in decreasing order
    next_idx_iter_prio      : t_prio_idx_i &
    continue_iter_prio : BOOL &
    session_iter_prio  : t_session_i &
    prio_idx_iter_prio : t_prio_idx_i &

    // iterator variables to iterate on the subscriptions with a given priority in a round-robin order
    nb_subs_iter_sub   : t_sub_idx_i &
    min_idx_iter_sub   : t_sub_idx_i &
    next_idx_iter_sub  : t_sub_idx_i &
    idx_iter_sub       : t_sub_idx_i

INITIALISATION
    next_idx_iter_prio      := 0;
    continue_iter_prio := FALSE;
    session_iter_prio  := c_session_indet;
    prio_idx_iter_prio := 0;
    nb_subs_iter_sub   := 1;
    min_idx_iter_sub   := 1;
    next_idx_iter_sub  := 1;
    idx_iter_sub       := 1

LOCAL_OPERATIONS

    revisedSamplingItv, revisedQueueSize <-- local_compute_create_monitored_item_revised_params (p_aid, p_reqQueueSize) =
    PRE
        p_aid : t_AttributeId_i &
        p_aid : t_AttributeId &
        p_reqQueueSize : t_counter
    THEN
        revisedSamplingItv :: t_opcua_duration_i ||
        revisedQueueSize :(revisedQueueSize : t_counter & revisedQueueSize > 0)
    END
    ;

    nb_data_notifs, nb_event_notifs, moreNotifs <-- local_compute_msg_nb_notifs (p_max_notifs, p_avail_data_notifs, p_avail_event_notifs) =
    PRE
        p_max_notifs : NAT &
        p_avail_data_notifs : NAT &
        p_avail_event_notifs : NAT
    THEN
        nb_data_notifs, nb_event_notifs, moreNotifs
        :(nb_data_notifs : NAT &
          nb_event_notifs : NAT &
          moreNotifs : BOOL &
               (p_avail_data_notifs + p_avail_event_notifs <= k_n_monitoredItemNotif_max &
                p_avail_data_notifs + p_avail_event_notifs <= p_max_notifs =>
                nb_data_notifs = p_avail_data_notifs &
                nb_event_notifs = p_avail_event_notifs &
                moreNotifs = FALSE
          ) &
          (not (p_avail_data_notifs + p_avail_event_notifs <= k_n_monitoredItemNotif_max &
                p_avail_data_notifs + p_avail_event_notifs <= p_max_notifs) =>
                nb_data_notifs <= p_avail_data_notifs &
                nb_event_notifs <= p_avail_event_notifs &
                nb_data_notifs + nb_event_notifs <= k_n_monitoredItemNotif_max &
                nb_data_notifs + nb_event_notifs <= p_max_notifs &
                moreNotifs = TRUE
            )
        )
    END
    ;

    bres, p_subscription <-- get_fresh_subscription =
    BEGIN
        IF t_subscription = s_subscription
        THEN
            bres := FALSE ||
            p_subscription := c_subscription_indet
        ELSE
            ANY l_subscription WHERE
                l_subscription : t_subscription - s_subscription
            THEN
                bres := TRUE ||
                p_subscription := l_subscription
            END
        END
    END
    ;

    /* - Pop the expired publish requests and generate an event to send a Bad_Timeout response
    - Check if a valid (non expired) publish request is available
    */
    p_validPubReqQueued <-- pop_invalid_and_check_valid_publishReqQueued (p_session) =
    PRE
        p_session : t_session_i &
        p_session : ran(a_subscription_session)
    THEN
        LET l_pubReqQueue BE
            l_pubReqQueue = a_publishRequestQueue (p_session)
        IN
            IF #msg.(msg : a_publish_responses~[{l_pubReqQueue}] & a_publish_expiration_time (msg) /: s_expired_time_ref)
            THEN
                /* If a non expired publish request exists:
                   - a valid publish request is enqueued
                   - we may have popped expired publish requests from the queue (and generated timeout response event)
                */
                validPublishReqQueued := TRUE ||
                p_validPubReqQueued := TRUE ||
                a_publish_responses
                :(a_publish_responses : t_msg +-> t_publishReqQueue &
                  a_publish_responses |>> {l_pubReqQueue} = a_publish_responses$0 |>> {l_pubReqQueue} &
                  card((a_publish_responses$0 |> {l_pubReqQueue}) - (a_publish_responses |> {l_pubReqQueue})) >= 0
                 )
            ELSE
                validPublishReqQueued := FALSE ||
                p_validPubReqQueued := FALSE
            END
        END
    END
    ;

    p_next_index <-- local_fill_notification_message_for_data_monitored_item
                       (p_monitoredItemPointer, p_notif_msg, p_cur_index, nb_notif_to_dequeue) =
    PRE
        p_monitoredItemPointer : t_monitoredItemPointer_i &
        p_monitoredItemPointer : t_monitoredItemPointer &
        p_notif_msg : t_notif_msg_i &
        p_notif_msg : t_notif_msg &
        notification_message = p_notif_msg &
        nb_notif_to_dequeue : NAT &
        nb_notif_to_dequeue : t_monitoredItemNotifIndex &
        nb_notif_to_dequeue = nb_data_notifications &
        nb_notif_to_dequeue <= card({a_notification_queue_notifications
                                      (a_monitored_item_notification_queue
                                          (p_monitoredItemPointer))}) &
        p_cur_index : NAT &
        p_cur_index : t_monitoredItemNotifIndex &
        p_cur_index <= nb_notif_to_dequeue
    THEN
        ANY l_a_monitored_item_notifications_dequeued WHERE
            l_a_monitored_item_notifications_dequeued <: {a_notification_queue_notifications
                                                           (a_monitored_item_notification_queue
                                                             (p_monitoredItemPointer))} & /* Set of dequeued notifications */
            card(l_a_monitored_item_notifications_dequeued) <= nb_data_notifications /* Expected number of notification dequeued*/
        THEN
            p_next_index,
            DataNotification_MonitoredItemId,
            DataNotification_MonitoredItemNotif
            :(p_next_index : NAT &
              p_next_index : t_monitoredItemNotifIndex &
              p_next_index = p_cur_index + card(l_a_monitored_item_notifications_dequeued) &
              DataNotification_MonitoredItemId : t_monitoredItemNotifIndex +-> t_monitoredItemId &
              DataNotification_MonitoredItemNotif : t_monitoredItemNotifIndex +-> t_WriteValuePointer &
                dom(DataNotification_MonitoredItemId) = 1..nb_data_notifications &
                /* Range is the monitored item ids for which notifications are present */
                ran(DataNotification_MonitoredItemId) =
                 a_monitoredItemId[a_monitored_item_notification_queue~[a_notification_queue_notifications~[l_a_monitored_item_notifications_dequeued]]] &
                dom(DataNotification_MonitoredItemNotif) = 1..nb_data_notifications &
                a_notif_conv_data~[ran(DataNotification_MonitoredItemNotif)] = l_a_monitored_item_notifications_dequeued) ||
            a_notification_queue_notifications := a_notification_queue_notifications |>> l_a_monitored_item_notifications_dequeued
        END
    END
    ;

    local_fill_data_notification_message (p_subscription, p_notif_msg, p_nb_data_notifs) =
    PRE
        p_subscription : t_subscription_i &
        p_subscription : s_subscription &
        p_notif_msg : t_notif_msg_i &
        p_notif_msg : t_notif_msg &
        notification_message = p_notif_msg &
        p_nb_data_notifs : NAT &
        p_nb_data_notifs : t_monitoredItemNotifIndex &
        p_nb_data_notifs = nb_data_notifications &
        p_nb_data_notifs <= card((s_event_notification_queue <<| a_notification_queue_notifications)[a_monitored_item_notification_queue
                [a_monitoredItemSubs~[{p_subscription}]]])
    THEN
        LET a_notification_queue_data_notifications BE
            a_notification_queue_data_notifications = s_event_notification_queue <<| a_notification_queue_notifications
        IN
            ANY l_a_monitored_item_notifications_dequeued WHERE
                l_a_monitored_item_notifications_dequeued <: a_notification_queue_data_notifications
                [a_monitored_item_notification_queue
                    [dom(a_monitoredItemMonitMode |> {e_monitoringMode_reporting}) /\
                        a_monitoredItemSubs~[{p_subscription}]]] & /* Set of dequeued notifications */
                card(l_a_monitored_item_notifications_dequeued) = nb_data_notifications /* Expected number of notification dequeued */
            THEN
                DataNotification_MonitoredItemId,
                DataNotification_MonitoredItemNotif
                :(DataNotification_MonitoredItemId : t_monitoredItemNotifIndex +-> t_monitoredItemId &
                    DataNotification_MonitoredItemNotif : t_monitoredItemNotifIndex +-> t_WriteValuePointer &
                    dom(DataNotification_MonitoredItemId) = 1..nb_data_notifications &
                    /* Range is the monitored item ids for which notifications are present */
                    ran(DataNotification_MonitoredItemId) =
                    a_monitoredItemId[a_monitored_item_notification_queue~[
                            a_notification_queue_data_notifications~[l_a_monitored_item_notifications_dequeued]]] &
                    dom(DataNotification_MonitoredItemNotif) = 1..nb_data_notifications &
                    a_notif_conv_data~[ran(DataNotification_MonitoredItemNotif)] = l_a_monitored_item_notifications_dequeued) ||
                a_notification_queue_notifications := a_notification_queue_notifications |>> l_a_monitored_item_notifications_dequeued
            END
        END
    END
    ;

    p_next_index <-- local_fill_notification_message_for_event_monitored_item
                       (p_monitoredItemPointer, p_notif_msg, p_cur_index, nb_notif_to_dequeue) =
    PRE
        p_monitoredItemPointer : t_monitoredItemPointer_i &
        p_monitoredItemPointer : t_monitoredItemPointer &
        p_notif_msg : t_notif_msg_i &
        p_notif_msg : t_notif_msg &
        notification_message = p_notif_msg &
        nb_notif_to_dequeue : NAT &
        nb_notif_to_dequeue : t_monitoredItemNotifIndex &
        nb_notif_to_dequeue = nb_event_notifications &
        nb_notif_to_dequeue <= card({a_notification_queue_notifications
                                      (a_monitored_item_notification_queue
                                          (p_monitoredItemPointer))}) &
        p_cur_index : NAT &
        p_cur_index : t_monitoredItemNotifIndex &
        p_cur_index <= nb_notif_to_dequeue
    THEN
        ANY l_a_monitored_item_notifications_dequeued WHERE
            l_a_monitored_item_notifications_dequeued <: {a_notification_queue_notifications
                                                           (a_monitored_item_notification_queue
                                                             (p_monitoredItemPointer))} & /* Set of dequeued notifications */
            card(l_a_monitored_item_notifications_dequeued) <= nb_event_notifications /* Expected number of notification dequeued*/
        THEN
            p_next_index,
            EventNotification_MonitoredItemId,
            EventNotification_MonitoredItemNotif
            :(p_next_index : NAT &
              p_next_index : t_monitoredItemNotifIndex &
              p_next_index = p_cur_index + card(l_a_monitored_item_notifications_dequeued) &
              EventNotification_MonitoredItemId : t_monitoredItemNotifIndex +-> t_monitoredItemId &
              EventNotification_MonitoredItemNotif : t_monitoredItemNotifIndex +-> t_eventFieldList &
                dom(EventNotification_MonitoredItemId) = 1..nb_event_notifications &
                /* Range is the monitored item ids for which notifications are present */
                ran(EventNotification_MonitoredItemId) =
                 a_monitoredItemId[a_monitored_item_notification_queue~[a_notification_queue_notifications~[l_a_monitored_item_notifications_dequeued]]] &
                dom(EventNotification_MonitoredItemNotif) = 1..nb_event_notifications &
                a_notif_conv_event~[ran(EventNotification_MonitoredItemNotif)] = l_a_monitored_item_notifications_dequeued) ||
            a_notification_queue_notifications := a_notification_queue_notifications |>> l_a_monitored_item_notifications_dequeued
        END
    END
    ;

    local_fill_event_notification_message (p_subscription, p_notif_msg, p_nb_event_notifs) =
    PRE
        p_subscription : t_subscription_i &
        p_subscription : s_subscription &
        p_notif_msg : t_notif_msg_i &
        p_notif_msg : t_notif_msg &
        notification_message = p_notif_msg &
        p_nb_event_notifs : NAT &
        p_nb_event_notifs : t_monitoredItemNotifIndex &
        p_nb_event_notifs = nb_event_notifications &
        p_nb_event_notifs <= card((s_event_notification_queue <| a_notification_queue_notifications)[a_monitored_item_notification_queue
                [a_monitoredItemSubs~[{p_subscription}]]])
    THEN
        LET a_notification_queue_event_notifications BE
            a_notification_queue_event_notifications = s_event_notification_queue <| a_notification_queue_notifications
        IN
            ANY l_a_monitored_item_notifications_dequeued WHERE
                l_a_monitored_item_notifications_dequeued <: a_notification_queue_event_notifications
                [a_monitored_item_notification_queue
                    [dom(a_monitoredItemMonitMode |> {e_monitoringMode_reporting}) /\
                        a_monitoredItemSubs~[{p_subscription}]]] & /* Set of dequeued notifications */
                card(l_a_monitored_item_notifications_dequeued) = nb_event_notifications /* Expected number of notification dequeued */
            THEN
                EventNotification_MonitoredItemId,
                EventNotification_MonitoredItemNotif
                :(EventNotification_MonitoredItemId : t_monitoredItemNotifIndex +-> t_monitoredItemId &
                    EventNotification_MonitoredItemNotif : t_monitoredItemNotifIndex +-> t_eventFieldList &
                    dom(EventNotification_MonitoredItemId) = 1..nb_event_notifications &
                    /* Range is the monitored item ids for which notifications are present */
                    ran(EventNotification_MonitoredItemId) =
                    a_monitoredItemId[a_monitored_item_notification_queue~[
                            a_notification_queue_event_notifications~[l_a_monitored_item_notifications_dequeued]]] &
                    dom(EventNotification_MonitoredItemNotif) = 1..nb_event_notifications &
                    a_notif_conv_event~[ran(EventNotification_MonitoredItemNotif)] = l_a_monitored_item_notifications_dequeued) ||
                a_notification_queue_notifications := a_notification_queue_notifications |>> l_a_monitored_item_notifications_dequeued
            END
        END
    END
    ;

    local_close_subscription (p_subscription) =
    PRE
        p_subscription : t_subscription_i &
        p_subscription : s_subscription
    THEN
        s_subscription := s_subscription - {p_subscription} ||

        a_subscription_session := {p_subscription} <<| a_subscription_session ||
        a_publishInterval := {p_subscription} <<| a_publishInterval ||
        a_lifetimeExpCount := {p_subscription} <<| a_lifetimeExpCount  ||
        a_keepAliveExpCount := {p_subscription} <<| a_keepAliveExpCount ||
        a_maxNotifsPerPublish := {p_subscription} <<| a_maxNotifsPerPublish ||

        a_subscription_state := {p_subscription} <<| a_subscription_state ||
        a_MoreNotifications := a_MoreNotifications - {p_subscription} ||
        a_LifetimeCounter := {p_subscription} <<| a_LifetimeCounter ||
        a_KeepAliveCounter := {p_subscription} <<| a_KeepAliveCounter ||
        a_MessageSent := a_MessageSent - {p_subscription}               ||
        a_PublishingEnabled := a_PublishingEnabled - {p_subscription}   ||
        a_SeqNum := {p_subscription} <<| a_SeqNum ||

        /* Queues deleted */
        a_monitored_item_notification_queue := a_monitoredItemSubs~[{p_subscription}] <<| a_monitored_item_notification_queue ||
        a_notification_queue_notifications := a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <<|a_notification_queue_notifications ||

        /* Republish queue deleted */
        a_republish_notification := a_republish_notification |>> {a_notifRepublishQueue(p_subscription)} ||
        a_notification_seq_num :=
          dom(a_republish_notification |> {a_notifRepublishQueue(p_subscription)}) <<| a_notification_seq_num ||

        s_republishQueue := s_republishQueue - {a_notifRepublishQueue(p_subscription)} ||
        a_notifRepublishQueue := {p_subscription} <<| a_notifRepublishQueue ||

        /* Remove monitoredItems */
        LET s_removedMonitoredItemPointer BE
            s_removedMonitoredItemPointer = a_defined_monitored_items[{a_monitoredItemQueue (p_subscription)}]
        IN
            s_monitoredItemPointer := s_monitoredItemPointer - s_removedMonitoredItemPointer ||
            s_monitoredItemId := s_monitoredItemId - a_monitoredItemId[s_removedMonitoredItemPointer] ||
            a_monitoredItemId := a_monitoredItemId - (s_removedMonitoredItemPointer <| a_monitoredItemId) ||
            a_monitoredItemSubs := s_removedMonitoredItemPointer <<| a_monitoredItemSubs ||
            a_monitoredItemNodeId := s_removedMonitoredItemPointer <<| a_monitoredItemNodeId ||

            s_monitoredItemQueue := s_monitoredItemQueue - {a_monitoredItemQueue(p_subscription)} ||
            a_monitoredItemQueue := {p_subscription} <<| a_monitoredItemQueue ||

            /* Remove subscription monitoredItem queue and all removed monitored items from other queues (i.e.:nodeId to mi queues) */
            a_defined_monitored_items :=
             {a_monitoredItemQueue (p_subscription)}
              <<| a_defined_monitored_items |>>
             s_removedMonitoredItemPointer
        END ||
        a_publishTimer := {p_subscription} <<| a_publishTimer
    END
    ;

    p_nb_available_data_notifs, p_nb_available_event_notifs <-- local_subscription_nb_available_notifications (p_subscription) =
    PRE
        p_subscription : t_subscription_i &
        p_subscription : s_subscription
    THEN
        p_nb_available_data_notifs :=
        card((s_event_notification_queue <<| a_notification_queue_notifications)[
                a_monitored_item_notification_queue[
                    dom(a_monitoredItemMonitMode |> {e_monitoringMode_reporting}) /\ a_defined_monitored_items[a_monitoredItemQueue[{p_subscription}]]]]) ||
        p_nb_available_event_notifs :=
        card((s_event_notification_queue <| a_notification_queue_notifications)[
                a_monitored_item_notification_queue[
                    dom(a_monitoredItemMonitMode |> {e_monitoringMode_reporting}) /\ a_defined_monitored_items[a_monitoredItemQueue[{p_subscription}]]]])
    END
    ;

    p_nb_available_notifs, p_isEvent <-- local_monitored_item_nb_available_notifications (p_monitoredItemPointer) =
    PRE
        p_monitoredItemPointer : t_monitoredItemPointer_i &
        p_monitoredItemPointer : t_monitoredItemPointer
    THEN
        p_nb_available_notifs :=
        card(a_notification_queue_notifications[{a_monitored_item_notification_queue(p_monitoredItemPointer)}]) ||
        p_isEvent := bool(a_monitored_item_notification_queue(p_monitoredItemPointer) : s_event_notification_queue)
    END
    ;

    p_continue <-- local_init_iter_session_seq_priority (p_session) =
    PRE
        p_session : t_session_i &
        p_session : t_session
    THEN
        session_iter_prio  := p_session ||
        p_continue         := bool(card(a_session_seq_priority(p_session)) /= 0) ||
        next_idx_iter_prio := card(a_session_seq_priority(p_session))
    END
    ;

    p_continue, p_prio_idx <-- local_continue_iter_session_seq_priority =
    PRE
        next_idx_iter_prio /= 0
    THEN
         p_continue,
         p_prio_idx
         :(p_continue : BOOL &
            p_prio_idx : t_prio_idx_i &
            (p_continue = TRUE =>
                p_prio_idx : t_prio_idx)
          )
    END
    ;

    local_init_iter_subscription_priority(p_prio_idx) =
    PRE
        p_prio_idx : t_prio_idx_i &
        p_prio_idx : t_prio_idx
    THEN
        nb_subs_iter_sub   := a_session_priority_nb_subs     (session_iter_prio)(p_prio_idx) ||
        min_idx_iter_sub   := a_session_priority_min_sub_idx (session_iter_prio)(p_prio_idx) ||
        next_idx_iter_sub  := a_session_priority_next_sub_idx(session_iter_prio)(p_prio_idx) ||
        idx_iter_sub       := a_session_priority_next_sub_idx(session_iter_prio)(p_prio_idx)
    END
    ;

    p_continue, p_subscription <-- local_continue_iter_subscription_priority =
    PRE
        idx_iter_sub : t_sub_idx &
        a_session_priority_next_sub_idx : t_session --> (t_prio_idx +-> t_sub_idx)
    THEN
         p_continue,
         p_subscription,
         idx_iter_sub,
         a_session_priority_next_sub_idx
         :(p_continue : BOOL &
           p_subscription : t_subscription_i &
           p_subscription : t_subscription   &
           idx_iter_sub   : t_sub_idx        &
           a_session_priority_next_sub_idx : t_session --> (t_priority +-> t_sub_idx) &

           idx_iter_sub = min_idx_iter_sub + ( (idx_iter_sub$0 - min_idx_iter_sub + 1) mod nb_subs_iter_sub ) &
           p_continue   = bool(idx_iter_sub /= next_idx_iter_sub) &
           (p_continue = TRUE
            =>
            a_session_priority_next_sub_idx = a_session_priority_next_sub_idx$0) &
           (p_continue = FALSE
            =>
            a_session_priority_next_sub_idx = a_session_priority_next_sub_idx$0 <+
              {session_iter_prio |-> (a_session_priority_next_sub_idx$0(session_iter_prio) <+
                {prio_idx_iter_prio |-> min_idx_iter_sub + ( (next_idx_iter_sub - min_idx_iter_sub + 1) mod nb_subs_iter_sub )})})
          )
    END

OPERATIONS
    /* LOCAL OPERATIONS */

    revisedSamplingItv, revisedQueueSize <-- local_compute_create_monitored_item_revised_params (p_aid, p_reqQueueSize) =
    BEGIN
        /* Note: if it changes in the future, NaN shall be considered for requested value (cf. sessionTimeout and publishingInterval) */
        revisedSamplingItv := c_opcua_duration_zero;
        /* Note: we use attribute to differentiate event notif queue from notif data queue.
        *       It is correct criteria for now but it might change if we accept data MI on this attribute in the future.
        */
        IF p_aid /= e_aid_EventNotifier
        THEN
            /* Data notification queue */
            IF p_reqQueueSize <= 1 THEN
                /* 0 or 1 the Server returns the default queue size which shall be 1 */
                revisedQueueSize := 1
            ELSIF p_reqQueueSize > k_n_notifQueueSize_max
            THEN
                revisedQueueSize := k_n_notifQueueSize_max
            ELSE
                revisedQueueSize := p_reqQueueSize
            END
        ELSE
            /* Event notification queue */
            IF p_reqQueueSize = 0 THEN
                /* Default value */
                revisedQueueSize := k_n_notifEventQueueSize_default
            ELSIF p_reqQueueSize = 1
            THEN
                /* Minimum value */
                revisedQueueSize := k_n_notifEventQueueSize_min
            ELSIF p_reqQueueSize > k_n_notifQueueSize_max
            THEN
                /* Maximum value */
                revisedQueueSize := k_n_notifQueueSize_max
            ELSE
                revisedQueueSize := p_reqQueueSize
            END
        END
    END
    ;

    nb_data_notifs, nb_event_notifs, moreNotifs <-- local_compute_msg_nb_notifs (p_max_notifs, p_avail_data_notifs, p_avail_event_notifs) =
    VAR
        l_max_nb_notifications,
        l_avail_notifs,
        l_overflow_notifs,
        l_abs_diff_notifs
    IN
        moreNotifs := FALSE;
        nb_data_notifs := p_avail_data_notifs;
        nb_event_notifs := p_avail_event_notifs;
        /* compute minimum of the maxima of notifications per message */
        IF p_max_notifs > 0 & p_max_notifs < k_n_monitoredItemNotif_max
        THEN
            l_max_nb_notifications := p_max_notifs
        ELSE
            l_max_nb_notifications := k_n_monitoredItemNotif_max
        END
        ;
        /* retrieve final notification number in message */
        l_avail_notifs := p_avail_data_notifs + p_avail_event_notifs;
        /* When too many notifications for 1 notification message,
           equilibrate the number of notifications between event / data categories if both are available */
        IF l_avail_notifs > l_max_nb_notifications
        THEN
            IF p_avail_event_notifs <= 0
            THEN
                nb_data_notifs := l_max_nb_notifications
            ELSIF p_avail_data_notifs <= 0
            THEN
                nb_event_notifs := l_max_nb_notifications
            ELSE
                l_overflow_notifs := l_avail_notifs - l_max_nb_notifications;
                /* 1. Equilibrate number of event and data notifs */
                IF p_avail_event_notifs > p_avail_data_notifs
                THEN
                    l_abs_diff_notifs := p_avail_event_notifs - p_avail_data_notifs
                ELSIF p_avail_event_notifs < p_avail_data_notifs
                THEN
                    l_abs_diff_notifs := p_avail_data_notifs - p_avail_event_notifs
                ELSE
                    l_abs_diff_notifs := 0
                END
                ;
                /* Compute min(l_abs_diff_notifs, l_overflow_notifs) to remove from category with more notifs */
                IF l_abs_diff_notifs > l_overflow_notifs
                THEN
                    l_abs_diff_notifs := l_overflow_notifs
                END
                ;
                IF p_avail_event_notifs > p_avail_data_notifs
                THEN
                    nb_event_notifs := nb_event_notifs - l_abs_diff_notifs
                ELSIF p_avail_event_notifs < p_avail_data_notifs
                THEN
                    nb_data_notifs := nb_data_notifs - l_abs_diff_notifs
                END
                ;
                l_overflow_notifs := l_overflow_notifs - l_abs_diff_notifs;
                /* 2. If overflow > 0, remove equally between the two categories of notifs */
                IF l_overflow_notifs > 0
                THEN
                    nb_data_notifs := nb_data_notifs - (l_overflow_notifs / 2);
                    nb_event_notifs := nb_event_notifs - (l_overflow_notifs - (l_overflow_notifs / 2))
                END
            END
            ;
            moreNotifs := TRUE
        END
    END
    ;

    bres, p_subscription <-- get_fresh_subscription =
    VAR
        l_subscription,
        l_is_subscription,
        l_continue
    IN
        bres := FALSE;
        p_subscription := c_subscription_indet;
        l_subscription := c_subscription_indet;
        l_is_subscription := TRUE;
        l_continue <-- init_iter_subscription;
        IF  l_continue = TRUE  /* Only for the proof */
        THEN
            WHILE
                l_continue   = TRUE &
                l_is_subscription = TRUE
            DO
                l_continue, l_subscription <-- continue_iter_subscription;
                l_is_subscription <-- is_valid_subscription(l_subscription)
            INVARIANT
                l_continue = bool(subscriptions_to_iterate /= {}) &
                subscriptions_to_iterate /\ subscriptions_iterated = {} &
                subscriptions_to_iterate \/ subscriptions_iterated = t_subscription &
                (   l_is_subscription = TRUE
                    =>
                    subscriptions_iterated <: s_subscription) &
                (   l_is_subscription = FALSE
                    =>
                    l_subscription  : t_subscription &
                    l_subscription /: s_subscription)
            VARIANT
                card(subscriptions_to_iterate)
            END
        END;
        IF l_is_subscription = FALSE
        THEN
            bres := TRUE;
            p_subscription := l_subscription
        END
    END
    ;

    p_validPubReqQueued <-- pop_invalid_and_check_valid_publishReqQueued (p_session) =
    VAR
        l_pubReqQueue,
        l_continue,
        l_req_exp_time,
        l_req_handle,
        l_req_ctx,
        l_resp_msg,
        l_is_expired
    IN
        p_validPubReqQueued := FALSE;
        l_pubReqQueue <-- get_session_publishRequestQueue (p_session);
        l_continue <-- init_iter_publish_request (l_pubReqQueue);
        l_is_expired := TRUE;
        WHILE l_continue = TRUE & l_is_expired = TRUE DO
            l_continue, l_req_exp_time, l_req_handle, l_req_ctx, l_resp_msg
              <-- continue_pop_head_iter_publish_request (l_pubReqQueue);
            l_is_expired <-- is_request_expired (l_req_exp_time);
            IF l_is_expired = TRUE
            THEN
                generate_internal_send_publish_response_event (p_session, l_resp_msg, l_req_handle, l_req_ctx, e_sc_bad_timeout)
            ELSE
                /* Next publish request is a valid (non expired) one, prepend it for next pop on queue */
                p_validPubReqQueued <-- prepend_publish_request_to_queue
                  (l_pubReqQueue, p_session, l_req_exp_time, l_req_handle, l_req_ctx, l_resp_msg)
            END
        INVARIANT
            l_continue = bool(a_publish_responses~[{l_pubReqQueue}] /= {})

        VARIANT
            card(a_publish_responses~[{l_pubReqQueue}])
        END
    END
    ;

    p_next_index <-- local_fill_notification_message_for_data_monitored_item
                       (p_monitoredItemPointer , p_notif_msg, p_cur_index, nb_notif_to_dequeue) =
    VAR
        l_notifQueue,
        l_continue,
        l_isEvent,
        l_writeValuePointer,

        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_indexRange,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle
    IN
        l_isEvent := TRUE;
        p_next_index := p_cur_index;
        l_continue, l_notifQueue <-- get_monitored_item_notification_queue (p_monitoredItemPointer);
        IF l_continue = TRUE
        THEN
            l_continue, l_isEvent <-- init_iter_monitored_item_notification (p_monitoredItemPointer, l_notifQueue)
        END
        ;
        WHILE l_continue = TRUE & l_isEvent = FALSE & p_next_index <= nb_notif_to_dequeue DO
            l_continue, l_writeValuePointer <-- continue_pop_iter_monitor_item_data_notification (p_monitoredItemPointer, l_notifQueue);
            /* Retrieve monitoredItem Id + client handle */
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_indexRange,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle
            <--getall_monitoredItemPointer (p_monitoredItemPointer);

            setall_notification_msg_monitored_item_data_notif (p_notif_msg, p_next_index, l_monitoredItemId, l_clientHandle, l_writeValuePointer);
            p_next_index := p_next_index + 1
        INVARIANT
            dom(DataNotification_MonitoredItemId) = 1..p_next_index &
            a_notification_queue_notifications[{l_notifQueue}] <<: a_notification_queue_notifications$0[{l_notifQueue}] &
            card(a_notification_queue_notifications[{l_notifQueue}]) = card(a_notification_queue_notifications$0[{l_notifQueue}]) - 1
        VARIANT
            card(a_notification_queue_notifications[{l_notifQueue}])
        END
    END
    ;

    local_fill_data_notification_message (p_subscription, p_notif_msg, p_nb_data_notifs) =
    VAR
        l_monitored_item_queue,
        l_continue_mi,
        l_iterator,
        l_monitoredItemPointer,
        l_isEvent,
        l_index,
        l_new_index,
        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_indexRange,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle
    IN
        l_index := 1;
        l_monitored_item_queue <-- get_subscription_monitoredItemQueue (p_subscription);
        l_continue_mi, l_iterator <-- init_iter_monitored_item (l_monitored_item_queue);
        WHILE l_continue_mi = TRUE  & l_index <= p_nb_data_notifs DO
            l_continue_mi, l_monitoredItemPointer <-- continue_iter_monitored_item (l_iterator, l_monitored_item_queue);
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_indexRange,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle
              <-- getall_monitoredItemPointer (l_monitoredItemPointer);
            l_isEvent <--is_event_monitoredItem (l_monitoredItemPointer);
            IF l_monitoringMode = e_monitoringMode_reporting & l_isEvent = FALSE
            THEN
                l_new_index <-- local_fill_notification_message_for_data_monitored_item
                                  (l_monitoredItemPointer, p_notif_msg, l_index, p_nb_data_notifs);
                l_index := l_new_index
            END
        INVARIANT
            s_mi_to_iterate_it <: t_monitoredItemPointer &
            s_mi_iterated_it   <: t_monitoredItemPointer &

            s_mi_to_iterate_it /\ s_mi_iterated_it = {} &
            card(s_mi_to_iterate_it \/ s_mi_iterated_it) = nb_monitored_items_it &
            l_continue_mi = bool(s_mi_to_iterate_it /= {}) &
            s_mi_iterated_it /\ a_defined_monitored_items[ran(a_nodeToMonitoredItemQueue)] = {} &
            s_mi_to_iterate_it /\ a_defined_monitored_items[ran(a_nodeToMonitoredItemQueue)] = s_mi_to_iterate_it &

            dom(DataNotification_MonitoredItemId) = 1..l_index &
            a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <<| a_notification_queue_notifications =
            a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <<| a_notification_queue_notifications$0 &
            a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <| a_notification_queue_notifications <<:
            a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <| a_notification_queue_notifications$0 &
            card(a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <| a_notification_queue_notifications) =
            card(a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <| a_notification_queue_notifications$0) - l_index
        VARIANT
            card(s_mi_to_iterate_it)
        END;
        clear_iter_monitored_item (l_iterator)
    END
    ;

    p_next_index <-- local_fill_notification_message_for_event_monitored_item
                       (p_monitoredItemPointer, p_notif_msg, p_cur_index, nb_notif_to_dequeue) =
    VAR
        l_notifQueue,
        l_continue,
        l_isEvent,
        l_eventFieldList,

        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_indexRange,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle
    IN
        l_isEvent := FALSE;
        p_next_index := p_cur_index;
        l_continue, l_notifQueue <-- get_monitored_item_notification_queue (p_monitoredItemPointer);
        IF l_continue = TRUE
        THEN
            l_continue, l_isEvent <-- init_iter_monitored_item_notification (p_monitoredItemPointer, l_notifQueue)
        END
        ;
        WHILE l_continue = TRUE & l_isEvent = TRUE & p_next_index <= nb_notif_to_dequeue DO
            l_continue, l_eventFieldList <-- continue_pop_iter_monitor_item_event_notification (p_monitoredItemPointer, l_notifQueue);
            /* Retrieve monitoredItem Id + client handle */
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_indexRange,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle
            <--getall_monitoredItemPointer (p_monitoredItemPointer);

            setall_notification_msg_monitored_item_event_notif
              (p_notif_msg, p_next_index, l_monitoredItemId, l_eventFieldList);
            p_next_index := p_next_index + 1
        INVARIANT
            dom(DataNotification_MonitoredItemId) = 1..p_next_index &
            a_notification_queue_notifications[{l_notifQueue}] <<: a_notification_queue_notifications$0[{l_notifQueue}] &
            card(a_notification_queue_notifications[{l_notifQueue}]) = card(a_notification_queue_notifications$0[{l_notifQueue}]) - 1
        VARIANT
            card(a_notification_queue_notifications[{l_notifQueue}])
        END
    END
    ;

    local_fill_event_notification_message (p_subscription, p_notif_msg, p_nb_event_notifs) =
    VAR
        l_monitored_item_queue,
        l_continue_mi,
        l_iterator,
        l_monitoredItemPointer,
        l_isEvent,
        l_index,
        l_new_index,
        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_indexRange,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle
    IN
        l_index := 1;
        l_monitored_item_queue <-- get_subscription_monitoredItemQueue (p_subscription);
        l_continue_mi, l_iterator <-- init_iter_monitored_item (l_monitored_item_queue);
        WHILE l_continue_mi = TRUE  & l_index <= p_nb_event_notifs DO
            l_continue_mi, l_monitoredItemPointer <-- continue_iter_monitored_item (l_iterator, l_monitored_item_queue);
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_indexRange,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle
              <-- getall_monitoredItemPointer (l_monitoredItemPointer);
            l_isEvent <--is_event_monitoredItem (l_monitoredItemPointer);
            IF l_monitoringMode = e_monitoringMode_reporting & l_isEvent = TRUE
            THEN
                l_new_index <-- local_fill_notification_message_for_event_monitored_item
                                  (l_monitoredItemPointer, p_notif_msg, l_index, p_nb_event_notifs);
                l_index := l_new_index
            END
        INVARIANT
            s_mi_to_iterate_it <: t_monitoredItemPointer &
            s_mi_iterated_it   <: t_monitoredItemPointer &

            s_mi_to_iterate_it /\ s_mi_iterated_it = {} &
            card(s_mi_to_iterate_it \/ s_mi_iterated_it) = nb_monitored_items_it &
            l_continue_mi = bool(s_mi_to_iterate_it /= {}) &
            s_mi_iterated_it /\ a_defined_monitored_items[ran(a_nodeToMonitoredItemQueue)] = {} &
            s_mi_to_iterate_it /\ a_defined_monitored_items[ran(a_nodeToMonitoredItemQueue)] = s_mi_to_iterate_it &

            dom(EventNotification_MonitoredItemId) = 1..l_index &
            a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <<| a_notification_queue_notifications =
            a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <<| a_notification_queue_notifications$0 &
            a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <| a_notification_queue_notifications <<:
            a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <| a_notification_queue_notifications$0 &
            card(a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <| a_notification_queue_notifications) =
            card(a_monitored_item_notification_queue[a_monitoredItemSubs~[{p_subscription}]] <| a_notification_queue_notifications$0) - l_index
        VARIANT
            card(s_mi_to_iterate_it)
        END;
        clear_iter_monitored_item (l_iterator)
    END
    ;

    local_close_subscription (p_subscription) =
    VAR
        l_timer_id,
        l_republish_queue,
        l_monitored_item_queue,
        l_notification_queue,
        l_continue_mi,
        l_iterator,
        l_monitoredItemPointer,
        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_indexRange,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle,
        l_monitored_item_node_queue,
        l_bres
    IN
        l_timer_id <-- get_subscription_timer_id (p_subscription);
        delete_publish_timer (l_timer_id);
        l_republish_queue <-- get_subscription_notifRepublishQueue (p_subscription);
        /* Deallocate republish queue */
        clear_and_deallocate_republish_queue (l_republish_queue);
        l_monitored_item_queue <-- get_subscription_monitoredItemQueue (p_subscription);
        l_continue_mi, l_iterator <-- init_iter_monitored_item (l_monitored_item_queue);
        WHILE l_continue_mi = TRUE DO
            l_continue_mi, l_monitoredItemPointer <-- continue_iter_monitored_item (l_iterator, l_monitored_item_queue);
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_indexRange,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle
              <--getall_monitoredItemPointer (l_monitoredItemPointer);
            l_bres, l_monitored_item_node_queue <-- get_nodeToMonitoredItemQueue (l_nid);
            IF l_bres = TRUE
            THEN
                l_bres <-- remove_monitored_item(l_monitored_item_node_queue, l_monitoredItemPointer)
            END; // TODO: ELSE log error
            l_bres, l_notification_queue <-- get_monitored_item_notification_queue (l_monitoredItemPointer);
            IF l_bres = TRUE
            THEN
                clear_and_deallocate_monitored_item_notification_queue (l_monitoredItemPointer, l_notification_queue)
            END; // TODO: ELSE log error

            // Deallocate monitored item pointer since l_monitored_item_queue will then be cleared
            delete_monitored_item_pointer (l_monitoredItemPointer)
        INVARIANT
            s_mi_to_iterate_it <: t_monitoredItemPointer &
            s_mi_iterated_it   <: t_monitoredItemPointer &

            s_mi_to_iterate_it /\ s_mi_iterated_it = {} &
            card(s_mi_to_iterate_it \/ s_mi_iterated_it) = nb_monitored_items_it &
            l_continue_mi = bool(s_mi_to_iterate_it /= {}) &
            s_mi_iterated_it /\ a_defined_monitored_items[ran(a_nodeToMonitoredItemQueue)] = {} &
            s_mi_to_iterate_it /\ a_defined_monitored_items[ran(a_nodeToMonitoredItemQueue)] = s_mi_to_iterate_it

        VARIANT
            card(s_mi_to_iterate_it)
        END;
        clear_iter_monitored_item (l_iterator);
        clear_and_deallocate_monitored_item_queue (l_monitored_item_queue);
        delete_subscription (p_subscription)
    END
    ;

    p_nb_available_data_notifs, p_nb_available_event_notifs <-- local_subscription_nb_available_notifications (p_subscription) =
    VAR
        l_monitored_item_queue,
        l_continue_mi,
        l_iterator,
        l_monitoredItemPointer,
        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_indexRange,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle,
        l_mi_available_notifs,
        l_isEvent,
        l_offset_from_maxint
    IN
        p_nb_available_data_notifs := 0;
        p_nb_available_event_notifs := 0;
        l_monitored_item_queue <-- get_subscription_monitoredItemQueue (p_subscription);
        l_continue_mi, l_iterator <-- init_iter_monitored_item (l_monitored_item_queue);
        WHILE l_continue_mi = TRUE DO
            l_continue_mi, l_monitoredItemPointer <-- continue_iter_monitored_item (l_iterator, l_monitored_item_queue);
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_indexRange,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle
              <--getall_monitoredItemPointer (l_monitoredItemPointer);
            IF l_monitoringMode = e_monitoringMode_reporting
            THEN
                l_mi_available_notifs, l_isEvent <-- local_monitored_item_nb_available_notifications (l_monitoredItemPointer);

                IF l_isEvent = TRUE
                THEN
                    l_offset_from_maxint := MAXINT - p_nb_available_event_notifs;
                    IF l_mi_available_notifs <= l_offset_from_maxint
                    THEN
                        p_nb_available_event_notifs := p_nb_available_event_notifs + l_mi_available_notifs
                    ELSE
                        p_nb_available_event_notifs := MAXINT
                    END
                ELSE
                    l_offset_from_maxint := MAXINT - p_nb_available_data_notifs;
                    IF l_mi_available_notifs <= l_offset_from_maxint
                    THEN
                        p_nb_available_data_notifs := p_nb_available_data_notifs + l_mi_available_notifs
                    ELSE
                        p_nb_available_data_notifs := MAXINT
                    END
                END
            END
        INVARIANT
            s_mi_to_iterate_it <: t_monitoredItemPointer &
            s_mi_iterated_it   <: t_monitoredItemPointer &

            s_mi_to_iterate_it /\ s_mi_iterated_it = {} &
            card(s_mi_to_iterate_it \/ s_mi_iterated_it) = nb_monitored_items_it &
            l_continue_mi = bool(s_mi_to_iterate_it /= {}) &
            s_mi_iterated_it /\ a_defined_monitored_items[ran(a_nodeToMonitoredItemQueue)] = {} &
            s_mi_to_iterate_it /\ a_defined_monitored_items[ran(a_nodeToMonitoredItemQueue)] = s_mi_to_iterate_it

        VARIANT
            card(s_mi_to_iterate_it)
        END;
        clear_iter_monitored_item (l_iterator)
    END
    ;

    p_nb_available_notifs, p_isEvent <-- local_monitored_item_nb_available_notifications (p_monitoredItemPointer) =
    VAR
        l_bres,
        l_mi_notif_queue
    IN
        p_isEvent := FALSE;
        p_nb_available_notifs := 0;
        l_bres, l_mi_notif_queue <-- get_monitored_item_notification_queue (p_monitoredItemPointer);
        IF l_bres = TRUE
        THEN
            p_nb_available_notifs <-- get_length_monitored_item_notification_queue (l_mi_notif_queue);
            p_isEvent <-- is_event_monitored_item_notification_queue (p_monitoredItemPointer, l_mi_notif_queue)
        END
    END
    ;

    p_continue <-- local_init_iter_session_seq_priority (p_session) =
    BEGIN
        session_iter_prio := p_session;
        next_idx_iter_prio <-- get_card_session_seq_priority(p_session);
        p_continue := bool(next_idx_iter_prio /= 0)
    END
    ;

    p_continue, p_prio_idx <-- local_continue_iter_session_seq_priority =
    BEGIN
         p_prio_idx := next_idx_iter_prio;
         next_idx_iter_prio := next_idx_iter_prio - 1;
         p_continue := bool(next_idx_iter_prio /= 0)
    END
    ;

    local_init_iter_subscription_priority(p_prio_idx) =
    BEGIN
        prio_idx_iter_prio := p_prio_idx;
        nb_subs_iter_sub   <-- get_session_priority_nb_subs     (session_iter_prio, p_prio_idx);
        min_idx_iter_sub   <-- get_session_priority_min_sub_idx (session_iter_prio, p_prio_idx);
        next_idx_iter_sub  <-- get_session_priority_next_sub_idx(session_iter_prio, p_prio_idx);
        idx_iter_sub       := next_idx_iter_sub
    END
    ;

    p_continue, p_subscription <-- local_continue_iter_subscription_priority =
    BEGIN
        p_subscription <-- get_session_seq_subscription(session_iter_prio, idx_iter_sub);
        idx_iter_sub   := min_idx_iter_sub + ( (idx_iter_sub - min_idx_iter_sub + 1) mod nb_subs_iter_sub );
        p_continue     := bool(idx_iter_sub /= next_idx_iter_sub);
        IF p_continue = FALSE
        THEN
            set_session_priority_next_sub_idx
             (session_iter_prio,
              prio_idx_iter_prio,
              min_idx_iter_sub + ( (next_idx_iter_sub - min_idx_iter_sub + 1) mod nb_subs_iter_sub ))
        END
    END
    ;

    /* END OF LOCAL OPERATIONS */

    StatusCode_service, subscription <-- create_subscription (p_session,
                                                              p_revPublishInterval,
                                                              p_revLifetimeCount,
                                                              p_revMaxKeepAlive,
                                                              p_maxNotificationsPerPublish,
                                                              p_publishEnabled,
                                                              p_priority) =
    VAR
        l_bres,
        l_newPublishQueue,
        l_bres_repub,
        l_newRepublishQueue,
        l_bres_monitored,
        l_newMonitoredItemQueue,
        l_bres_timer,
        l_timerId
    IN
        StatusCode_service := c_StatusCode_indet;
        l_bres, subscription <-- get_fresh_subscription;

        IF l_bres = TRUE
        THEN
            l_bres_repub, l_newRepublishQueue <-- allocate_new_republish_queue;
            l_bres_monitored, l_newMonitoredItemQueue <-- allocate_new_monitored_item_queue;
            l_bres_timer, l_timerId <-- create_periodic_publish_timer (subscription, p_revPublishInterval);
            IF l_bres_repub = TRUE & l_bres_monitored = TRUE & l_bres_timer = TRUE
            THEN
                StatusCode_service <--
                add_subscription (subscription,
                                  p_session,
                                  e_subscriptionState_normal,
                                  FALSE,
                                  p_priority,
                                  p_revPublishInterval,
                                  p_revLifetimeCount,
                                  p_revMaxKeepAlive,
                                  p_maxNotificationsPerPublish,
                                  p_publishEnabled,
                                  c_sub_seq_num_init, /* => next SeqNum == 1 */
                                  l_newRepublishQueue,
                                  l_newMonitoredItemQueue,
                                  l_timerId)
            ELSE
                StatusCode_service := e_sc_bad_out_of_memory;
                IF l_bres_repub = TRUE
                THEN
                    clear_and_deallocate_republish_queue (l_newRepublishQueue)
                END;
                IF l_bres_monitored = TRUE
                THEN
                    clear_and_deallocate_monitored_item_queue (l_newMonitoredItemQueue)
                END
                ;
                IF l_bres_timer = TRUE
                THEN
                    delete_publish_timer (l_timerId)
                END
            END
        ELSE
            StatusCode_service := e_sc_bad_too_many_subscriptions
        END
    END
    ;

    modify_subscription (p_subscription,
                         p_revPublishInterval,
                         p_revLifetimeCount,
                         p_revMaxKeepAlive,
                         p_revMaxNotifPerPublish,
                         p_priority) =
    VAR
        l_old_priority,
        l_timerId,
        l_session,
        l_publishEnabled,
        l_republishQueue,
        l_monitoredItemQueue,
        l_seqNum,
        l_state,
        l_firstMsgSent,
        l_statusCode
    IN
        l_state := c_subscriptionState_indet; /* Necessary for an issue in B to c translator (undeclared) */
        l_old_priority <-- get_subscription_priority(p_subscription);
        l_timerId <-- get_subscription_timer_id (p_subscription);
        IF l_old_priority = p_priority
        THEN
            /* Same priority, we only need modify subscription parameters */
            set_subscription_publishInterval (p_subscription, p_revPublishInterval);
            set_subscription_MaxLifetimeAndKeepAliveCount (p_subscription, p_revLifetimeCount, p_revMaxKeepAlive);
            reset_subscription_LifetimeCounter (p_subscription);
            set_subscription_MaxNotifsPerPublish (p_subscription, p_revMaxNotifPerPublish);
            modify_publish_timer_period (l_timerId, p_revPublishInterval)
        ELSE
            /* Priority changed, we need to reorder the subscription indexes by using delete/add subscription operations */
            l_session <-- getall_session (p_subscription);
            l_publishEnabled <-- get_subscription_PublishingEnabled (p_subscription);
            l_republishQueue <-- get_subscription_notifRepublishQueue (p_subscription);
            l_monitoredItemQueue <-- get_subscription_monitoredItemQueue (p_subscription);
            l_seqNum <-- get_subscription_SeqNum (p_subscription);
            l_state <-- get_subscription_state (p_subscription);
            l_firstMsgSent <-- get_subscription_MessageSent (p_subscription);
            delete_subscription (p_subscription);
            l_statusCode <--
                add_subscription (p_subscription,
                                  l_session,
                                  l_state,
                                  l_firstMsgSent,
                                  p_priority,
                                  p_revPublishInterval,
                                  p_revLifetimeCount,
                                  p_revMaxKeepAlive,
                                  p_revMaxNotifPerPublish,
                                  l_publishEnabled,
                                  l_seqNum,
                                  l_republishQueue,
                                  l_monitoredItemQueue,
                                  l_timerId)
            // note: l_statusCode is always Good as maximum number of subscriptions cannot be reached
        END
    END
    ;

    close_subscription (p_subscription) =
    BEGIN
        local_close_subscription (p_subscription)
    END
    ;

    is_valid_seq_num <-- subscription_ack_notif_msg (p_sub, p_seq_num) =
    VAR
        l_republishQueue
    IN
        l_republishQueue <-- get_subscription_notifRepublishQueue (p_sub);
        is_valid_seq_num <-- remove_republish_notif_from_queue (l_republishQueue, p_seq_num)
    END
    ;

    StatusCode_service, async_resp_msg, moreNotifs
      <-- receive_publish_request (p_subscription, p_resp_msg) =
    VAR
        l_subscriptionState,
        l_PublishingEnabled,
        l_nb_avail_data_notifs,
        l_nb_avail_event_notifs,
        l_nb_data_notifs,
        l_nb_event_notifs,
        l_max_configured_notifications,
        l_NotificationAvailable,
        l_MoreNotifications,
        l_notifRepublishQueue,

        l_bres,
        l_nb_repub_notifs,
        l_notifMsg,
        l_seq_num,
        l_next_seq_num
    IN
        l_subscriptionState <-- get_subscription_state (p_subscription);
        l_PublishingEnabled <-- get_subscription_PublishingEnabled (p_subscription);
        l_MoreNotifications <-- get_subscription_MoreNotifications (p_subscription);
        l_nb_avail_data_notifs, l_nb_avail_event_notifs <-- local_subscription_nb_available_notifications (p_subscription);
        l_max_configured_notifications <-- get_subscription_MaxNotifsPerPublish (p_subscription);
        l_NotificationAvailable := bool(l_nb_avail_data_notifs > 0 or l_nb_avail_event_notifs > 0);
        l_notifRepublishQueue <-- get_subscription_notifRepublishQueue (p_subscription);
        async_resp_msg := FALSE;
        moreNotifs := FALSE;

        /* #4 transition and #13 transition */
        IF l_subscriptionState = e_subscriptionState_normal &
           (l_PublishingEnabled = FALSE
            or
            (l_PublishingEnabled = TRUE &
             l_MoreNotifications = FALSE)
           )
           or
           l_subscriptionState = e_subscriptionState_keepAlive
        THEN
            async_resp_msg := TRUE;
            StatusCode_service := e_sc_ok
        /* #5 transition */
        ELSIF l_subscriptionState = e_subscriptionState_normal &
              l_PublishingEnabled = TRUE & l_MoreNotifications = TRUE
        THEN
            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (p_subscription);

            d_send_notification_msg (p_subscription, p_resp_msg, l_notifRepublishQueue,
                                     l_nb_avail_data_notifs, l_nb_avail_event_notifs, moreNotifs,
                                     StatusCode_service)

        /* #10 transition */
        ELSIF l_subscriptionState = e_subscriptionState_late &
              l_PublishingEnabled = TRUE &
              (l_MoreNotifications = TRUE or l_NotificationAvailable = TRUE)
        THEN
            set_subscription_state (p_subscription, e_subscriptionState_normal);

            /* Note: Idem previous transition below: */

            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (p_subscription);

            d_send_notification_msg (p_subscription, p_resp_msg, l_notifRepublishQueue,
                                     l_nb_avail_data_notifs, l_nb_avail_event_notifs, moreNotifs,
                                     StatusCode_service)

        /* #11 transition */
        ELSIF l_subscriptionState = e_subscriptionState_late &
             (l_PublishingEnabled = FALSE
              or
              (l_PublishingEnabled = TRUE &
               l_NotificationAvailable = FALSE &
               l_MoreNotifications = FALSE)
             )
        THEN
            set_subscription_state (p_subscription, e_subscriptionState_keepAlive);

            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (p_subscription);

            d_send_keepalive_msg (p_subscription, p_resp_msg, StatusCode_service)
        ELSE
            StatusCode_service := e_sc_bad_invalid_state
        END
    END
    ;

    StatusCode_service, async_resp_msg
      <-- enqueue_publish_request (p_session, p_req_exp_time, p_req_handle, p_req_ctx, p_resp_msg) =
    VAR
        l_PublishingReqQueue,
        l_bres,
        l_nb_pub_reqs,
        l_old_session,
        l_old_req_handle,
        l_old_req_ctx,
        l_old_resp_msg
    IN
        StatusCode_service := e_sc_ok;
        async_resp_msg := TRUE;
        l_PublishingReqQueue <-- get_session_publishRequestQueue (p_session);
        l_nb_pub_reqs <-- get_nb_publish_requests (l_PublishingReqQueue);
        IF l_nb_pub_reqs = k_n_publishRequestPerSession_max
        THEN
            l_old_session,
            l_old_resp_msg,
            l_old_req_handle,
            l_old_req_ctx <-- discard_oldest_publish_request (l_PublishingReqQueue);
            generate_internal_send_publish_response_event
            (l_old_session, l_old_resp_msg, l_old_req_handle, l_old_req_ctx, e_sc_bad_too_many_publish_requests)
        END;
        l_bres <-- append_publish_request_to_queue
        (l_PublishingReqQueue, p_session, p_req_exp_time, p_req_handle, p_req_ctx, p_resp_msg);
        IF l_bres = FALSE
        THEN
            StatusCode_service := e_sc_bad_too_many_publish_requests;
            async_resp_msg := FALSE
        END
    END
    ;

    revisedSamplingItv, revisedQueueSize <-- compute_create_monitored_item_revised_params (p_aid, p_reqQueueSize) =
    BEGIN
        revisedSamplingItv, revisedQueueSize <-- local_compute_create_monitored_item_revised_params (p_aid, p_reqQueueSize)
    END
    ;

    StatusCode_service, monitoredItemPointer, monitoredItemId, filterResult <-- create_monitored_item
       (p_endpoint_idx,
        p_subscription,
        p_nid,
        p_aid,
        p_indexRange,
        p_value,
        p_valueSc,
        p_val_ts_src,
        p_val_ts_srv,
        p_timestampToReturn,
        p_monitoringMode,
        p_clientHandle,
        p_filter,
        p_discardOldest,
        p_queueSize) =
    VAR
        l_filterCtx,
        l_isEvent,
        l_bres,
        l_sub_monitIt_queue,
        l_node_monitIt_queue,
        l_sub_notif_queue,
        l_ts_src,
        l_ts_srv
    IN
        monitoredItemPointer := c_monitoredItemPointer_indet;
        monitoredItemId := c_monitoredItemId_indet;
        /* Check constraints on node for MI filter */
        StatusCode_service, l_filterCtx, filterResult, l_isEvent <-- check_monitored_item_filter_valid_and_fill_result (p_endpoint_idx, p_nid, p_aid, p_filter, p_value);
        /* Create monitored item */
        IF StatusCode_service = e_sc_ok
        THEN
            StatusCode_service, monitoredItemPointer, monitoredItemId
              <-- create_monitored_item_pointer(p_subscription,
                                                p_nid,
                                                p_aid,
                                                p_indexRange,
                                                p_timestampToReturn,
                                                p_monitoringMode,
                                                p_clientHandle,
                                                l_filterCtx,
                                                p_discardOldest,
                                                p_queueSize)
        END;
        IF StatusCode_service = e_sc_ok
        THEN
            l_bres, l_node_monitIt_queue <-- get_nodeToMonitoredItemQueue (p_nid);

            IF l_bres = TRUE
            THEN
                l_sub_monitIt_queue <-- get_subscription_monitoredItemQueue (p_subscription);
                l_bres <-- add_monitored_item_to_queue (l_node_monitIt_queue, monitoredItemPointer);
                IF l_bres = TRUE
                THEN
                    /* Add monitored item to subscription and node queues */
                    l_bres <-- add_monitored_item_to_queue (l_sub_monitIt_queue, monitoredItemPointer);
                    IF l_bres = FALSE
                    THEN
                        l_bres <-- remove_monitored_item (l_node_monitIt_queue, monitoredItemPointer);
                        l_bres := FALSE
                    END
                END
                ;
                IF l_bres = TRUE
                THEN
                    l_bres, l_sub_notif_queue <-- allocate_new_monitored_item_notification_queue (monitoredItemPointer, l_isEvent);
                    IF l_bres = TRUE
                    THEN
                        IF p_monitoringMode /= e_monitoringMode_disabled & p_aid /= e_aid_EventNotifier
                        THEN
                            CASE p_timestampToReturn OF
                                EITHER e_ttr_source THEN
                                    l_ts_src := p_val_ts_src;
                                    l_ts_srv := c_Timestamp_null
                                OR e_ttr_server THEN
                                    l_ts_src := c_Timestamp_null;
                                    l_ts_srv := p_val_ts_srv
                                OR e_ttr_neither THEN
                                    l_ts_src := c_Timestamp_null;
                                    l_ts_srv := c_Timestamp_null
                                ELSE    /* keep both timestamps retrieved */
                                    l_ts_src := p_val_ts_src;
                                    l_ts_srv := p_val_ts_srv
                                END
                            END
                            ;
                            /* Generate a notification for new monitored item */
                            l_bres <-- add_first_monitored_item_notification_to_queue (monitoredItemPointer,
                                l_sub_notif_queue,
                                p_nid,
                                p_aid,
                                p_value,
                                p_valueSc,
                                l_ts_src,
                                l_ts_srv)
                        END
                    END
                    ;
                    IF l_bres = FALSE
                    THEN
                        l_bres <-- remove_monitored_item (l_node_monitIt_queue, monitoredItemPointer);
                        l_bres <-- remove_monitored_item (l_sub_monitIt_queue, monitoredItemPointer);
                        l_bres := FALSE
                    END
                END
            END;
            IF l_bres = FALSE
            THEN
                StatusCode_service := e_sc_bad_out_of_memory;
                delete_monitored_item_pointer(monitoredItemPointer)
            END
        ELSE
            delete_event_filter_context (l_filterCtx)
        END
    END
    ;

    p_sc, p_filterResult, p_revSamplingItv, p_revQueueSize
      <-- modify_monitored_item (p_endpoint_idx, p_subscription, p_mi_id, p_timestampToReturn, p_clientHandle, p_filter, p_discardOldest, p_queueSize) =
    VAR
        bres,
        l_monitoredItemPointer,
        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_indexRange,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle,
        l_filterCtx,
        l_isEvent,
        l_isExpectedSubId
    IN
        bres, l_monitoredItemPointer <--getall_monitoredItemId (p_mi_id);
        p_sc := e_sc_bad_monitored_item_id_invalid;
        l_filterCtx := c_monitoringFilterCtx_indet;
        p_filterResult := c_filterResult_indet;
        p_revSamplingItv := c_opcua_duration_zero;
        p_revQueueSize := 0;
        IF bres = TRUE
        THEN
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_indexRange,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle
              <--getall_monitoredItemPointer (l_monitoredItemPointer);
            p_revSamplingItv, p_revQueueSize <-- local_compute_create_monitored_item_revised_params(l_aid, p_queueSize);
            /* Check monitored item subscription matches the given subscription */
            l_isExpectedSubId := bool(p_subscription = l_subscription);
            IF l_isExpectedSubId = TRUE
            THEN
                /* Check constraints on node for MI filter */
                p_sc, l_filterCtx, p_filterResult, l_isEvent  <-- check_monitored_item_filter_valid_and_fill_result (p_endpoint_idx, l_nid, l_aid, p_filter, c_Variant_indet)
            END
            ;
            IF l_isExpectedSubId = TRUE & p_sc = e_sc_ok
            THEN
                p_sc <-- modify_monitored_item_pointer(l_monitoredItemPointer,
                                                       p_timestampToReturn,
                                                       p_clientHandle,
                                                       l_filterCtx,
                                                       p_discardOldest,
                                                       p_revQueueSize);
                IF p_sc = e_sc_ok
                THEN
                    resize_monitored_item_notification_queue(l_monitoredItemPointer)
                END
            END
        END
    END
    ;

    p_sc <-- delete_monitored_item (p_subscription, p_mi_id) =
    VAR
        l_subscription_queue,
        l_monitoredItemPointer,
        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_indexRange,
        l_timestampToReturn,
        l_monitoringMode,
        l_clientHandle,
        l_isMonitoredItemFound,
        l_monitored_item_queue,
        l_bres,
        l_notificationQueue
    IN
        p_sc := e_sc_bad_monitored_item_id_invalid;
        l_isMonitoredItemFound := FALSE;
        l_monitoredItemPointer := c_monitoredItemPointer_indet;
        l_monitored_item_queue := c_monitoredItemQueue_indet;
        l_nid := c_NodeId_indet;
        l_isMonitoredItemFound, l_monitoredItemPointer <-- getall_monitoredItemId (p_mi_id);
        IF l_isMonitoredItemFound = TRUE THEN
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_indexRange,
            l_timestampToReturn,
            l_monitoringMode,
            l_clientHandle <-- getall_monitoredItemPointer (l_monitoredItemPointer);
            l_subscription_queue <-- get_subscription_monitoredItemQueue (p_subscription);
            /* Check monitored item subscription matches the given subscription */
            l_isMonitoredItemFound := bool(p_subscription = l_subscription);
            IF l_isMonitoredItemFound = TRUE
            THEN
                p_sc := e_sc_ok;
                l_bres <-- remove_monitored_item (l_subscription_queue, l_monitoredItemPointer);
                IF l_bres = TRUE
                THEN
                    l_bres, l_monitored_item_queue <-- get_nodeToMonitoredItemQueue (l_nid)
                END
                ;
                IF l_bres = TRUE
                THEN
                    l_bres <-- remove_monitored_item (l_monitored_item_queue, l_monitoredItemPointer)
                END
                ;
                l_bres, l_notificationQueue <-- get_monitored_item_notification_queue (l_monitoredItemPointer);
                IF l_bres = TRUE
                THEN
                    clear_and_deallocate_monitored_item_notification_queue (l_monitoredItemPointer, l_notificationQueue)
                END
                ;
                delete_monitored_item_pointer (l_monitoredItemPointer)
            END
        END
    END
    ;

    p_sc, p_mi_pointer, p_prevMonitMode <-- set_monit_mode_monitored_item (p_subscription, p_mi_id, p_monitoring_mode) =
    VAR
        l_isMonitoredItemFound,
        l_monitoredItemPointer,
        l_monitoredItemId,
        l_subscription,
        l_nid,
        l_aid,
        l_indexRange,
        l_timestampToReturn,
        l_clientHandle
    IN
        p_sc := e_sc_bad_monitored_item_id_invalid;
        p_mi_pointer := c_monitoredItemPointer_indet;
        p_prevMonitMode := c_monitoringMode_indet;
        l_monitoredItemPointer := c_monitoredItemPointer_indet;
        l_isMonitoredItemFound, l_monitoredItemPointer <-- getall_monitoredItemId (p_mi_id);
        IF l_isMonitoredItemFound = TRUE THEN
            p_mi_pointer := l_monitoredItemPointer;
            l_monitoredItemId,
            l_subscription,
            l_nid,
            l_aid,
            l_indexRange,
            l_timestampToReturn,
            p_prevMonitMode,
            l_clientHandle
                 <--getall_monitoredItemPointer (l_monitoredItemPointer);
            /* Check monitored item subscription matches the given subscription */
            l_isMonitoredItemFound := bool(p_subscription = l_subscription);
            IF l_isMonitoredItemFound = TRUE
            THEN
                set_monit_mode_monitored_item_pointer (l_monitoredItemPointer, p_monitoring_mode);
                p_sc := e_sc_ok
            END
        END
    END
    ;

    clear_monitored_item_notifications (p_monitoredItemPointer) =
    VAR
        l_bres,
        l_notifQueue
    IN
        l_bres, l_notifQueue <-- get_monitored_item_notification_queue (p_monitoredItemPointer);
        IF l_bres = TRUE
        THEN
            clear_monitored_item_notification_queue (p_monitoredItemPointer, l_notifQueue)
        END
    END
    ;

    p_validPublishingReqQueued <-- server_subscription_core_check_valid_publish_req_queue (p_session) =
    BEGIN
        p_validPublishingReqQueued <-- pop_invalid_and_check_valid_publishReqQueued (p_session)
    END
    ;

    p_close_sub, p_msg_to_send, p_publish_resp_msg, p_req_handle, p_req_context, p_validPubReqQueued
      <-- server_subscription_core_publish_timeout_check_lifetime (p_session, p_subscription) =
    VAR
        l_lifetimeCounter
    IN
        /* #27 transition evaluation */
        p_close_sub := FALSE;
        p_msg_to_send := FALSE;
        p_publish_resp_msg := c_msg_indet;
        p_req_handle := c_server_request_handle_any;
        p_req_context := c_request_context_indet;

        p_validPubReqQueued <-- pop_invalid_and_check_valid_publishReqQueued (p_session);
        IF p_validPubReqQueued = FALSE
        THEN
            l_lifetimeCounter <-- get_subscription_LifetimeCounter (p_subscription);
            IF l_lifetimeCounter <= 1
            THEN
                p_close_sub := TRUE
            ELSE
                decrement_subscription_LifetimeCounter (p_subscription)
            END
     /* ELSE: Since some valid publishing requests are available nothing to do */
        END
    END
    ;

    p_msg_to_send, p_msg_sc, p_publish_resp_msg, p_req_handle, p_req_context, p_moreNotifs
      <-- server_subscription_core_publish_timeout (p_session, p_subscription, p_validPublishReqQueued) =
    VAR
        l_bres,
        l_State,
        l_PublishingReqQueue,
        l_PublishingEnabled,
        l_nb_avail_data_notifs,
        l_nb_avail_event_notifs,
        l_nb_data_notifs,
        l_nb_event_notifs,
        l_max_configured_notifications,
        l_NotificationAvailable,
        l_MessageSent,
        l_KeepAliveCounter,
        l_notifRepublishQueue,

        l_nb_repub_notifs,
        l_notifMsg,
        l_req_exp_time,
        l_seq_num,
        l_next_seq_num
    IN
        p_msg_to_send := FALSE;
        p_publish_resp_msg := c_msg_indet;
        p_req_handle := c_server_request_handle_any;
        p_req_context := c_request_context_indet;
        p_moreNotifs := FALSE;
        p_msg_sc := c_StatusCode_indet;

        /* Retrieve state variables */
        l_State <-- get_subscription_state (p_subscription);
        l_PublishingReqQueue <-- get_session_publishRequestQueue (p_session);
        l_PublishingEnabled <-- get_subscription_PublishingEnabled (p_subscription);
        l_nb_avail_data_notifs, l_nb_avail_event_notifs <-- local_subscription_nb_available_notifications (p_subscription);
        l_max_configured_notifications <-- get_subscription_MaxNotifsPerPublish (p_subscription);
        l_NotificationAvailable := bool(l_nb_avail_data_notifs > 0 or l_nb_avail_event_notifs > 0);
        l_MessageSent <-- get_subscription_MessageSent (p_subscription);
        l_KeepAliveCounter <-- get_subscription_KeepAliveCounter (p_subscription);
        l_notifRepublishQueue <-- get_subscription_notifRepublishQueue (p_subscription);

        /* #6 transition */
        IF l_State = e_subscriptionState_normal &
            p_validPublishReqQueued = TRUE &
            l_PublishingEnabled = TRUE &
            l_NotificationAvailable = TRUE
        THEN
            /* Note: same treatment as #14 below ! */

            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (p_subscription);
            /* retrieve a valid publish response */
            l_req_exp_time, p_req_handle, p_req_context, p_publish_resp_msg
              <-- pop_valid_publish_request_queue (l_PublishingReqQueue);

            p_msg_to_send := TRUE;
            d_send_notification_msg (p_subscription, p_publish_resp_msg, l_notifRepublishQueue,
                                     l_nb_avail_data_notifs, l_nb_avail_event_notifs, p_moreNotifs,
                                     p_msg_sc)

        /* #7 transition */
        ELSIF l_State = e_subscriptionState_normal &
              p_validPublishReqQueued = TRUE &
              l_MessageSent = FALSE &
              (l_PublishingEnabled = FALSE or
                (l_PublishingEnabled = TRUE &
                 l_NotificationAvailable = FALSE)
              )
        THEN
            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (p_subscription);
            /* retrieve a valid publish response */
            l_req_exp_time, p_req_handle, p_req_context, p_publish_resp_msg
              <-- pop_valid_publish_request_queue (l_PublishingReqQueue);
            set_publish_response_msg (p_publish_resp_msg);

            p_msg_to_send := TRUE;
            d_send_keepalive_msg (p_subscription, p_publish_resp_msg, p_msg_sc)

        /* #8 transition */
        ELSIF l_State = e_subscriptionState_normal &
              p_validPublishReqQueued = FALSE &
              (l_MessageSent = FALSE
               or
               (l_PublishingEnabled = TRUE &
                l_NotificationAvailable = TRUE)
              )
        THEN
            set_subscription_state (p_subscription, e_subscriptionState_late)

        /* #9 transition */
        ELSIF l_State = e_subscriptionState_normal &
              l_MessageSent = TRUE &
              (l_PublishingEnabled = FALSE
               or
               (l_PublishingEnabled = TRUE &
                l_NotificationAvailable = FALSE)
              )
        THEN
            set_subscription_state (p_subscription, e_subscriptionState_keepAlive);
            reset_subscription_KeepAliveCounter (p_subscription);
            decrement_subscription_KeepAliveCounter (p_subscription)

        /* #12 transition */
        ELSIF l_State = e_subscriptionState_late
        THEN
            skip /* Nothing to do: lifetime already checked */
        /* #14 transition */
        ELSIF l_State = e_subscriptionState_keepAlive &
              l_PublishingEnabled = TRUE &
              l_NotificationAvailable = TRUE &
              p_validPublishReqQueued = TRUE
        THEN
            set_subscription_state (p_subscription, e_subscriptionState_normal);

            /* Note: same treatment as #7 below ! */
            /* reset lifetime counter */
            reset_subscription_LifetimeCounter (p_subscription);

            /* retrieve a valid publish response */
            l_req_exp_time, p_req_handle, p_req_context, p_publish_resp_msg
              <-- pop_valid_publish_request_queue (l_PublishingReqQueue);

            p_msg_to_send := TRUE;
            d_send_notification_msg (p_subscription, p_publish_resp_msg, l_notifRepublishQueue,
                                     l_nb_avail_data_notifs, l_nb_avail_event_notifs, p_moreNotifs,
                                     p_msg_sc)

        /* #15 transition */
        ELSIF l_State = e_subscriptionState_keepAlive &
              p_validPublishReqQueued = TRUE &
              l_KeepAliveCounter <= 1 &
              (l_PublishingEnabled = FALSE
               or
               (l_PublishingEnabled = TRUE &
                l_NotificationAvailable = FALSE)
              )
        THEN
            reset_subscription_KeepAliveCounter (p_subscription);

            /* Note: same treatment as #7 below ! */
            /* retrieve a valid publish response */
            l_req_exp_time, p_req_handle, p_req_context, p_publish_resp_msg
              <-- pop_valid_publish_request_queue (l_PublishingReqQueue);
            set_publish_response_msg (p_publish_resp_msg);

            p_msg_to_send := TRUE;
            d_send_keepalive_msg (p_subscription, p_publish_resp_msg, p_msg_sc)

        /* #16 transition */
        ELSIF l_State = e_subscriptionState_keepAlive &
              l_KeepAliveCounter > 1 &
              (l_PublishingEnabled = FALSE
               or
               (l_PublishingEnabled = TRUE &
                l_NotificationAvailable = FALSE)
              )
        THEN
            decrement_subscription_KeepAliveCounter (p_subscription)

        /* #17 transition */
        ELSIF l_State = e_subscriptionState_keepAlive &
              p_validPublishReqQueued = FALSE &
              (l_KeepAliveCounter <= 1
               or
               (l_KeepAliveCounter > 1 &
                l_PublishingEnabled = TRUE &
                l_NotificationAvailable = TRUE)
              )
        THEN
            set_subscription_state (p_subscription, e_subscriptionState_late)
        ELSE
            skip
            /* TODO: invalid state evaluation: generate log error trace */
        END
    END
    ;

    p_msg_to_send, p_msg_sc, p_publish_resp_msg, p_req_handle, p_req_context, p_moreNotifs
      <-- server_subscription_core_publish_timeout_return_moreNotifs (p_session, p_subscription) =
    VAR
        l_req_exp_time,
        l_PublishingReqQueue,
        l_nb_avail_data_notifs,
        l_nb_avail_event_notifs,
        l_nb_data_notifs,
        l_nb_event_notifs,
        l_max_configured_notifications,
        l_nb_repub_notifs,
        l_bres,
        l_notifMsg,
        l_seq_num,
        l_next_seq_num,
        l_notifRepublishQueue
    IN
        p_moreNotifs := FALSE;
        p_msg_to_send := TRUE;
        l_PublishingReqQueue <-- get_session_publishRequestQueue (p_session);
        l_nb_avail_data_notifs, l_nb_avail_event_notifs <-- local_subscription_nb_available_notifications (p_subscription);
        l_max_configured_notifications <-- get_subscription_MaxNotifsPerPublish (p_subscription);
        l_notifRepublishQueue <-- get_subscription_notifRepublishQueue (p_subscription);

        /* retrieve a valid publish response */
        l_req_exp_time, p_req_handle, p_req_context, p_publish_resp_msg
          <-- pop_valid_publish_request_queue (l_PublishingReqQueue);

        d_send_notification_msg (p_subscription, p_publish_resp_msg, l_notifRepublishQueue,
                                 l_nb_avail_data_notifs, l_nb_avail_event_notifs, p_moreNotifs,
                                 p_msg_sc)
    END
    ;

    server_subscription_add_notification_on_event_if_triggered
      (p_userAccessGranted, p_localeIds, p_monitoredItemPointer, p_clientHandle, p_timestampToReturn, p_event) =
    VAR
        l_filterCtx,
        l_triggered,
        l_event_notif,
        l_bres,
        l_notif_queue
    IN
        l_filterCtx <-- get_monitoredItemFilter(p_monitoredItemPointer);
        l_triggered, l_event_notif
        <-- server_subscription_get_notification_on_event (p_clientHandle,
                                                           p_localeIds, p_timestampToReturn, p_userAccessGranted,
                                                           l_filterCtx, p_event);
        l_bres, l_notif_queue <-- get_monitored_item_notification_queue (p_monitoredItemPointer);
        IF l_triggered = TRUE & l_bres = TRUE
        THEN
            l_bres <-- add_monitored_item_event_notification_to_queue (p_monitoredItemPointer,
                                                                       l_notif_queue,
                                                                       l_event_notif)
        END
    END
    ;

    server_subscription_add_notification_on_value_change (p_localeIds, p_monitoredItemPointer, p_timestampToReturn, p_writeValuePointer) =
    VAR
        l_bres,
        l_notif_queue,
        l_is_event
    IN
        l_bres, l_notif_queue <-- get_monitored_item_notification_queue (p_monitoredItemPointer);
        IF l_bres = TRUE
        THEN
            l_is_event <-- is_event_monitored_item_notification_queue (p_monitoredItemPointer, l_notif_queue);
            IF l_is_event = FALSE
            THEN
                /* Note: indexRange and locales filtering on value done in C implementation */
                l_bres <-- add_monitored_item_data_notification_to_queue
                             (p_localeIds, p_monitoredItemPointer, l_notif_queue, p_timestampToReturn, p_writeValuePointer)
            END
        END

    END
    ;

    bres <-- server_subscription_add_notification_on_node_or_monitMode_change
       (p_monitoredItemPointer,
        p_nid,
        p_aid,
        p_VariantValuePointer,
        p_ValueSc,
        p_val_ts_src,
        p_val_ts_srv) =
    VAR
        l_notif_queue
    IN
        bres, l_notif_queue <-- get_monitored_item_notification_queue (p_monitoredItemPointer);
        IF bres = TRUE
        THEN
            /* Generate a notification for monitored item concerned by the added / removed node */
            bres <-- add_first_monitored_item_notification_to_queue
            (p_monitoredItemPointer,
                l_notif_queue,
                p_nid,
                p_aid,
                p_VariantValuePointer,
                p_ValueSc,
                p_val_ts_src,
                p_val_ts_srv)
        END
    END
    ;

    subscription_core_UNINITIALISATION =
    VAR
        l_subscription,
        l_is_subscription,
        l_continue
    IN
        l_continue <-- init_iter_subscription;
        WHILE
            l_continue   = TRUE
        DO
            l_continue, l_subscription <-- continue_iter_subscription;
            l_is_subscription <-- is_valid_subscription(l_subscription);
            IF l_is_subscription = TRUE
            THEN
                local_close_subscription (l_subscription)
            END
        INVARIANT
            l_continue = bool(subscriptions_to_iterate /= {}) &
            subscriptions_to_iterate /\ subscriptions_iterated = {} &
            subscriptions_to_iterate \/ subscriptions_iterated = t_subscription &
            subscriptions_iterated /\ s_subscription = {} &
            subscriptions_to_iterate = s_subscription
        VARIANT
            card(subscriptions_to_iterate)
        END;
        subscription_core_bs_UNINITIALISATION;
        monitored_item_pointer_bs_UNINITIALISATION;
        msg_subscription_publish_bs_UNINITIALISATION
    END
    ;

    bres <-- allocate_new_session_publish_queue (p_session) =
    VAR
        l_publishReqQueue
    IN
        bres, l_publishReqQueue <-- allocate_new_publish_queue;
        IF bres = TRUE
        THEN
            set_session_publishRequestQueue (p_session, l_publishReqQueue)
        END
    END
    ;

    deallocate_publish_queue_and_gen_no_sub_responses (p_session, p_send_no_sub_resp) =
    VAR
        l_publish_queue,
        l_req_exp_time,
        l_req_handle,
        l_req_ctx,
        l_resp_msg,
        l_continue_pub

    IN
        l_publish_queue <-- get_session_publishRequestQueue (p_session);
        IF p_send_no_sub_resp = TRUE
        THEN
            /* Clearing queue create asynchronous publish response sending indicating Bad_NoSubscription */
            l_continue_pub <-- init_iter_publish_request (l_publish_queue);
            WHILE l_continue_pub = TRUE DO
                l_continue_pub, l_req_exp_time, l_req_handle, l_req_ctx, l_resp_msg
                <-- continue_pop_head_iter_publish_request (l_publish_queue);
                /* Generates BadNoSubscription since only 1 subscription per session (no other subscription possibly opened) */
                generate_internal_send_publish_response_event (p_session, l_resp_msg, l_req_handle, l_req_ctx, e_sc_bad_no_subscription)
            INVARIANT
                l_continue_pub = bool(a_publish_responses~[{l_publish_queue}] /= {})

            VARIANT
                card(a_publish_responses~[{l_publish_queue}])
            END
        END
        ;
        /* Deallocate publish queue */
        clear_and_deallocate_publish_queue (l_publish_queue);
        reset_session_publishRequestQueue (p_session)
    END
    ;

    p_continue <-- init_iter_subscription_session (p_session) =
    VAR
        l_prio_idx
    IN
        p_continue <-- local_init_iter_session_seq_priority(p_session);
        IF p_continue = TRUE
        THEN
            continue_iter_prio, l_prio_idx <-- local_continue_iter_session_seq_priority;
            local_init_iter_subscription_priority(l_prio_idx)
        END
    END
    ;

    p_continue, p_subscription <-- continue_iter_subscription_session =
    VAR
        l_prio_idx
    IN
        l_prio_idx := 0;
        p_continue, p_subscription <-- local_continue_iter_subscription_priority;
        IF p_continue = FALSE
        THEN
            p_continue := continue_iter_prio;
            IF p_continue = TRUE
            THEN
                continue_iter_prio, l_prio_idx <-- local_continue_iter_session_seq_priority;
                local_init_iter_subscription_priority(l_prio_idx)
            END
        END
    END

END
