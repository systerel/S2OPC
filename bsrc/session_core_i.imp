/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    session_core_i
REFINES
    session_core

DEFINITIONS
    d_active_sessions   == ( sessions_iterated /\ a_channel~[{p_lost_channel}] /\ a_state~[{e_session_userActivated}]);
    d_inactive_sessions == ((sessions_iterated /\ a_channel~[{p_lost_channel}]) - a_state~[{e_session_userActivated}])

SEES
    constants,
    constants_statuscodes_bs,
    message_in_bs,
    message_out_bs,
    channel_mgr,
    request_handle_bs,
    time_reference_bs

IMPORTS
    session_roles,
    session_core_1,
    session_core_it,
    session_channel_it,
    msg_session_bs,
    user_authentication,
    session_audit_bs

PROMOTES
    server_get_session_from_token,
    client_get_token_from_session,
    get_session_channel,
    get_channel_nb_sessions,
    set_session_to_create,
    set_session_app_context,
    getall_to_create,
    getall_orphaned,
    reset_session_to_create,
    is_valid_session,
    client_gen_create_session_internal_event,
    client_gen_activate_orphaned_session_internal_event,
    client_gen_activate_user_session_internal_event,
    server_session_timeout_start_timer,
    server_session_timeout_evaluation,
    server_session_timeout_msg_received,
    set_session_user_client,
    get_session_user_client,
    get_session_user_server,
    session_has_user_server,
    get_server_session_preferred_locales,
    get_server_session_client_app_desc,
    get_server_session_client_cert_tb,
    deallocate_user,
    get_local_user,
    has_user_token_policy_available,
    allocate_x509_token_from_user,
    is_valid_user_x509_authentication,
    deallocate_x509_token,
    compute_user_roles,
    get_session_roles,
    /* session_audit_bs */
    set_request_audit_info,
    clear_audit_info,
    server_notify_session_create,
    server_notify_session_activate,
    server_notify_session_closed

LOCAL_OPERATIONS
    nsession, p_service_ret <-- l_server_create_session_req_and_resp_sm (p_session, p_channel, create_req_msg, create_resp_msg) =
    PRE
        p_session  : t_session_i                   &
        p_session  : t_session                     &
        p_session  : s_session                     &
        p_session /: s_client_session              &
        s_session  = dom(a_state)                  &
        a_state(p_session) = e_session_init        &
        p_session /: ran(a_server_token)           &
        p_channel  : t_channel_i                   &
        p_channel  : s_channel_connected           &
        p_channel  : dom(a_endpoint)               &
        create_req_msg : t_msg_i                   &
        create_req_msg = c_msg_in                  &
        c_msg_in : t_msg                           &
        a_msg_in_type = e_msg_session_create_req   &
        create_resp_msg : t_msg_i                  &
        create_resp_msg = c_msg_out                &
        c_msg_out : t_msg                          &
        a_msg_out_type = e_msg_session_create_resp &
        dom(a_NonceServer) <: dom(a_state |>> {e_session_init, e_session_creating})
    THEN
        CHOICE
            ANY l_nsession_token WHERE
                l_nsession_token : t_session_token_i &
                l_nsession_token : t_session_token - dom(a_server_token)
            THEN
                nsession := p_session                                  ||
                a_server_user_auth_attempts(p_session) := 0            ||
                a_channel(p_session) := p_channel                      || // associate current channel
                a_server_token := a_server_token <+ {l_nsession_token |-> p_session} ||
                p_service_ret, a_state, a_NonceServer :(
                    p_service_ret : t_StatusCode_i &
                    a_state = a_state$0 <+ {p_session |-> e_session_created} &
                    a_NonceServer : t_session +-> t_Nonce &
                    dom(a_NonceServer) <: dom(a_state |>> {e_session_init, e_session_creating}) &

                    p_service_ret : {e_sc_bad_unexpected_error, e_sc_bad_nonce_invalid, e_sc_bad_certificate_uri_invalid,
                                     e_sc_bad_invalid_argument, e_sc_ok, e_sc_bad_out_of_memory} &
                    (p_service_ret = e_sc_ok =>
                        {p_session} <<| a_NonceServer = {p_session} <<| a_NonceServer$0 &
                        p_session : dom(a_NonceServer)) &
                    (p_service_ret /= e_sc_ok =>
                        a_NonceServer = a_NonceServer$0)
                )
            END
        OR
            nsession := c_session_indet ||
            p_service_ret :: {e_sc_bad_too_many_sessions, e_sc_bad_security_checks_failed} ||

            s_session                   := s_session - {p_session}                     ||
            a_state                     := {p_session} <<| a_state                     ||
            a_channel                   := {p_session} <<| a_channel                   ||
            a_NonceServer               := {p_session} <<| a_NonceServer               ||
            a_client_orphaned           := {p_session} <<| a_client_orphaned           ||
            a_user_server               := {p_session} <<| a_user_server               ||
            a_user_server_cert          := {p_session} <<| a_user_server_cert          ||
            a_server_token              := a_server_token |>> {p_session}              ||
            a_server_user_auth_attempts := {p_session} <<| a_server_user_auth_attempts ||
            a_server_client_locales     := {p_session} <<| a_server_client_locales     ||
            a_session_roles             := {p_session} <<| a_session_roles             ||
            a_user_client               := {p_session} <<| a_user_client               ||
            a_user_secu_client          := {p_session} <<| a_user_secu_client          ||
            a_client_token              := {p_session} <<| a_client_token              ||
            a_NonceClient               := {p_session} <<| a_NonceClient               ||
            a_client_to_create          := {p_session} <<| a_client_to_create          ||
            a_client_app_context        := {p_session} <<| a_client_app_context
        END
    END
    ;

    p_service_ret <-- l_server_write_create_session_resp (p_session, p_channel, p_session_token, create_req_msg, create_resp_msg) =
    PRE
        p_session  : t_session_i                    &
        p_session  : t_session                      &
        p_session  : s_session                      &
        p_session /: s_client_session               &
        p_session  : dom(a_state)                   &
        a_state(p_session) = e_session_created      &
        p_session  : ran(a_server_token)            &
        p_channel  : t_channel_i                    &
        p_channel  : s_channel_connected            &
        p_channel  : dom(a_endpoint)                &
        p_session_token : t_session_token_i         &
        p_session_token : t_session_token           &
        p_session_token : dom(a_server_token)       &
        a_server_token(p_session_token) = p_session &
        create_req_msg : t_msg_i                    &
        create_req_msg = c_msg_in                   &
        c_msg_in : t_msg                            &
        a_msg_in_type = e_msg_session_create_req    &
        create_resp_msg : t_msg_i                   &
        create_resp_msg = c_msg_out                 &
        c_msg_out : t_msg                           &
        a_msg_out_type = e_msg_session_create_resp  &
        dom(a_NonceServer) <: dom(a_state |>> {e_session_init, e_session_creating})
    THEN
        CHOICE
            p_service_ret := e_sc_ok  ||
            a_NonceServer :(
                a_NonceServer : t_session +-> t_Nonce &
                dom(a_NonceServer) <: dom(a_state |>> {e_session_init, e_session_creating}) &
                {p_session} <<| a_NonceServer = {p_session} <<| a_NonceServer$0 &
                p_session : dom(a_NonceServer))
            // sends response
        OR
            // TODO: could return at least all result codes from table 15
            p_service_ret :(p_service_ret : t_StatusCode_i &
                            p_service_ret : {e_sc_bad_unexpected_error, e_sc_bad_nonce_invalid, e_sc_bad_certificate_uri_invalid,
                                             e_sc_bad_invalid_argument, e_sc_bad_out_of_memory})
        END
    END
    ;

    p_ret, p_session_token <-- l_client_user_activate_session_req_sm (p_session, p_channel, p_user_token, activate_req_msg) =
    PRE
        p_session : t_session_i &
        p_session : s_session &
        p_session : s_client_session &
        dom(a_state) = s_session &
        a_state(p_session) : {e_session_created, e_session_userActivated} &
        p_session : dom(a_client_token) &
        p_session : dom(a_NonceServer) &
        p_session: dom(a_user_secu_client) &
        p_session: dom(a_user_server_cert) &
        p_channel : t_channel_i &
        p_channel : t_channel &
        p_channel : s_channel_connected &
        p_user_token : t_user_token_i &
        p_user_token : t_user_token &
        activate_req_msg : t_msg_i &
        activate_req_msg = c_msg_out &
        c_msg_out : t_msg &
        a_msg_out_type = e_msg_session_activate_req
    THEN
        p_ret :: {e_sc_ok, e_sc_bad_security_checks_failed, e_sc_bad_unexpected_error} ||
        p_session_token :(p_session_token : t_session_token_i & p_session_token = a_client_token(p_session))
    END
    ;

    res_activated <-- server_internal_activate_req_and_resp (channel, session, p_user, activate_req_msg, activate_resp_msg) =
    PRE
        channel       : t_channel_i &
        channel       : s_channel_connected &
        channel       : dom(a_endpoint) &
        session       : t_session_i &
        session       : s_session &
        session      /: s_client_session &
        p_user          : t_user_i &
        p_user          : t_user &
        dom(a_state) = s_session &
        a_state(session) : {e_session_created, e_session_userActivated, e_session_scOrphaned} &
        activate_req_msg : t_msg_i &
        activate_req_msg = c_msg_in &
        c_msg_in : t_msg &
        a_msg_in_type = e_msg_session_activate_req &
        activate_resp_msg : t_msg_i &
        activate_resp_msg = c_msg_out &
        c_msg_out : t_msg &
        a_msg_out_type = e_msg_session_activate_resp
    THEN
        CHOICE
            a_state(session) := e_session_userActivated ||
            a_channel(session) := channel ||
            a_user_server(session) := p_user ||
            res_activated := TRUE ||
            a_NonceServer :(
                a_NonceServer : t_session +-> t_Nonce &
                {session} <<| a_NonceServer = {session} <<| a_NonceServer$0 &
                session : dom(a_NonceServer)) ||
            a_server_client_locales :(
                a_server_client_locales : s_session --> t_LocaleIds &
                {session} <<| a_server_client_locales = {session} <<| a_server_client_locales$0)
        OR
            res_activated := FALSE
        END
    END
    ;

    ret <-- l_server_activate_session_req_and_resp_sm (channel, session, user, activate_req_msg, activate_resp_msg) =
    PRE
        channel : t_channel_i &
        channel : s_channel_connected &
        channel : dom(a_endpoint) &
        session : t_session_i &
        session : s_session &
        session /: s_client_session &
        a_state : s_session --> t_sessionState &
        a_state(session) : {e_session_created, e_session_userActivated,
                            e_session_scOrphaned} &
        ((a_state(session) :  {e_session_userActivated, e_session_scOrphaned}) => (session : dom(a_user_server))) &
        user : t_user_i &
        user : t_user &
        activate_req_msg : t_msg_i &
        activate_req_msg = c_msg_in &
        c_msg_in : t_msg &
        a_msg_in_type = e_msg_session_activate_req &
        activate_resp_msg : t_msg_i &
        activate_resp_msg = c_msg_out &
        c_msg_out : t_msg &
        a_msg_out_type = e_msg_session_activate_resp &
        dom(a_channel) = dom(a_state |>> {e_session_init, e_session_scOrphaned})
    THEN
        IF a_state(session) = e_session_created
        THEN
            IF session : dom(a_channel) &
               a_channel(session) = channel // current channel is the channel associated to the current session
            THEN
                CHOICE
                    a_state(session) := e_session_userActivated ||
                    a_user_server(session) := user ||
                    a_server_client_locales :(
                        a_server_client_locales : s_session --> t_LocaleIds &
                        {session} <<| a_server_client_locales = {session} <<| a_server_client_locales$0) ||
                    a_NonceServer :(
                        a_NonceServer : t_session +-> t_Nonce &
                        {session} <<| a_NonceServer = {session} <<| a_NonceServer$0 &
                        session : dom(a_NonceServer)) ||
                    ret := e_sc_ok
                OR
                    ret := e_sc_bad_application_signature_invalid
                END
            ELSE
                ret := e_sc_bad_invalid_argument
            END
        ELSIF a_state(session) = e_session_userActivated
        THEN
            IF session : dom(a_channel) &
               a_channel(session) = channel // current channel is the channel associated to the current session
            THEN
                CHOICE
                    a_state(session) := e_session_userActivated ||
                    a_user_server(session) := user ||
                    a_server_client_locales :(
                        a_server_client_locales : s_session --> t_LocaleIds &
                        {session} <<| a_server_client_locales = {session} <<| a_server_client_locales$0) ||
                    a_NonceServer :(
                        a_NonceServer : t_session +-> t_Nonce &
                        {session} <<| a_NonceServer = {session} <<| a_NonceServer$0 &
                        session : dom(a_NonceServer)) ||
                    ret := e_sc_ok
                OR
                    ret := e_sc_bad_application_signature_invalid
                END
            ELSIF session : dom(a_user_server) &
                  a_user_server(session) = user // user provided in activate request is the user associated to the current session
            THEN
                    CHOICE
                        a_channel(session) := channel         ||
                        a_state(session) := e_session_userActivated ||
                        a_user_server :(
                            a_user_server : t_session +-> t_user &
                            {session} <<| a_user_server = {session} <<| a_user_server$0 &
                            session : dom(a_user_server))||
                        a_server_client_locales :(
                            a_server_client_locales : s_session --> t_LocaleIds &
                            {session} <<| a_server_client_locales = {session} <<| a_server_client_locales$0) ||
                        a_NonceServer :(
                            a_NonceServer : t_session +-> t_Nonce &
                            {session} <<| a_NonceServer = {session} <<| a_NonceServer$0 &
                            session : dom(a_NonceServer)) ||
                        ret := e_sc_ok
                    OR
                        ret := e_sc_bad_application_signature_invalid
                        // sends response with error
                    END
            ELSE
                ret := e_sc_bad_invalid_state
            END
        ELSIF a_state(session) = e_session_scOrphaned
        THEN
            IF session : dom(a_user_server) &
               a_user_server(session) = user
            THEN
                /* ScActivateReq */
                CHOICE
                    a_channel(session) := channel         ||
                    a_state(session) := e_session_userActivated ||
                    a_user_server :(
                        a_user_server : t_session +-> t_user &
                        {session} <<| a_user_server = {session} <<| a_user_server$0 &
                        session : dom(a_user_server))||
                    a_server_client_locales :(
                        a_server_client_locales : s_session --> t_LocaleIds &
                        {session} <<| a_server_client_locales = {session} <<| a_server_client_locales$0) ||
                    a_NonceServer :(
                        a_NonceServer : t_session +-> t_Nonce &
                        {session} <<| a_NonceServer = {session} <<| a_NonceServer$0 &
                        session : dom(a_NonceServer)) ||
                    ret := e_sc_ok
                OR
                    ret := e_sc_bad_application_signature_invalid
                    // sends response with error
                END
            ELSE
                ret := e_sc_bad_invalid_state
            END
        ELSE
            ret := e_sc_bad_invalid_state
        END
    END
    ;

    l_client_secure_channel_lost_session_sm(p_channel, p_lost_channel, p_session, p_channel_config_idx) =
    PRE
        p_channel            : t_channel_i            &
        p_session            : t_session_i            &
        p_lost_channel       : t_channel_i            &
        p_session            : t_session_i            &
        p_session            : s_client_session       &
        p_channel_config_idx : t_channel_config_idx_i &
        p_channel_config_idx : t_channel_config_idx   &
        p_session            : dom(a_state)           &
        p_session            : dom(a_channel)         &
        p_channel            = a_channel(p_session)
    THEN
        s_session,
        s_client_session,
        a_state,
        a_channel,
        a_client_to_create,
        a_client_app_context,
        a_client_orphaned,
        a_user_server,
        a_user_client,
        a_server_token,
        a_client_token,
        a_NonceServer,
        a_NonceClient,
        a_session_roles,
        a_user_server_cert,
        a_server_user_auth_attempts,
        a_server_client_locales,
        a_user_secu_client
        :(
            s_session                   <: t_session                             &
            s_client_session            <: t_session                             &
            a_state                      : t_session +-> t_sessionState          &
            a_channel                    : t_session +-> t_channel               &
            a_client_to_create           : t_session +-> t_channel_config_idx_i  &
            a_client_app_context         : t_session +-> t_session_application_context_i &
            a_client_orphaned            : t_session +-> t_channel_config_idx_i  &
            a_client_token               : t_session +-> t_session_token         &
            a_server_token               : t_session_token +-> t_session         &
            a_user_server                : t_session +-> t_user                  &
            a_user_client                : t_session +-> t_user_token            &
            a_NonceServer                : t_session +-> t_Nonce                 &
            a_NonceClient                : t_session +-> t_Nonce                 &
            a_session_roles              : t_session +-> t_sessionRoles          &
            a_user_server_cert           : t_session +-> t_byte_buffer           &
            a_server_user_auth_attempts  : t_session +-> NAT                     &
            a_server_client_locales      : s_session --> t_LocaleIds             &
            a_user_secu_client           : t_session +-> t_SecurityPolicy        &

            (p_channel = p_lost_channel
                =>
                (   a_state$0(p_session) = e_session_userActivated
                    =>
                    a_channel                    = {p_session} <<| a_channel$0 &
                    a_state                      = a_state$0 <+ {p_session |-> e_session_scOrphaned} &
                    s_session                    = s_session$0 &
                    a_client_to_create           = a_client_to_create$0 &
                    a_client_app_context         = a_client_app_context$0 &
                    a_user_server                = a_user_server$0 &
                    a_user_client                = a_user_client$0 &
                    a_server_token               = a_server_token$0 &
                    a_client_token               = a_client_token$0 &
                    a_NonceServer                = a_NonceServer$0 &
                    a_NonceClient                = a_NonceClient$0 &
                    a_session_roles              = a_session_roles$0 &
                    a_client_orphaned = a_client_orphaned$0 <+ {p_session |-> p_channel_config_idx}
                ) &
                (   a_state$0(p_session) /= e_session_userActivated
                    =>
                    s_session                    = s_session$0 - {p_session} &
                    a_state                      = {p_session} <<| a_state$0 &
                    a_channel                    = {p_session} <<| a_channel$0 &
                    a_client_to_create           = {p_session} <<| a_client_to_create$0 &
                    a_client_app_context         = {p_session} <<| a_client_app_context$0 &
                    a_client_orphaned            = {p_session} <<| a_client_orphaned$0 &
                    a_user_server                = {p_session} <<| a_user_server$0 &
                    a_user_client                = {p_session} <<| a_user_client$0 &
                    a_server_token               = a_server_token$0 |>> {p_session} &
                    a_client_token               = {p_session} <<| a_client_token$0 &
                    a_NonceServer                = {p_session} <<| a_NonceServer$0 &
                    a_NonceClient                = {p_session} <<| a_NonceClient$0 &
                    a_session_roles              = {p_session} <<| a_session_roles$0
                )
            )
        )
    END
    ;

    l_server_secure_channel_lost_session_sm(p_channel, p_lost_channel, p_session) =
    PRE
        p_channel      : t_channel_i      &
        p_session      : t_session_i      &
        p_lost_channel : t_channel_i      &
        p_session      : t_session_i      &
        p_session     /: s_client_session &
        p_session      : dom(a_channel)   &
        p_session      : dom(a_state)     &
        p_channel      = a_channel(p_session)
    THEN
        s_session,
        a_state,
        a_channel,
        a_client_to_create,
        a_client_app_context,
        a_client_orphaned,
        a_user_server,
        a_user_client,
        a_server_token,
        a_client_token,
        a_NonceServer,
        a_NonceClient,
        a_session_roles,
        a_user_server_cert,
        a_server_user_auth_attempts,
        a_server_client_locales,
        a_user_secu_client
        :(
            s_session                   <: t_session                             &
            a_state                      : t_session +-> t_sessionState          &
            a_channel                    : t_session +-> t_channel               &
            a_client_to_create           : t_session +-> t_channel_config_idx_i  &
            a_client_app_context         : t_session +-> t_session_application_context_i &
            a_client_orphaned            : t_session +-> t_channel_config_idx_i  &
            a_client_token               : t_session +-> t_session_token         &
            a_server_token               : t_session_token +-> t_session         &
            a_user_server                : t_session +-> t_user                  &
            a_user_client                : t_session +-> t_user_token            &
            a_NonceServer                : t_session +-> t_Nonce                 &
            a_NonceClient                : t_session +-> t_Nonce                 &
            a_session_roles              : t_session +-> t_sessionRoles          &
            a_user_server_cert           : t_session +-> t_byte_buffer           &
            a_server_user_auth_attempts  : t_session +-> NAT                     &
            a_server_client_locales      : s_session --> t_LocaleIds             &
            a_user_secu_client           : t_session +-> t_SecurityPolicy        &

            (p_channel = p_lost_channel
            =>
                (   a_state$0(p_session) = e_session_userActivated
                    =>
                    a_channel                    = {p_session} <<| a_channel$0 &
                    a_state                      = a_state$0 <+ {p_session |-> e_session_scOrphaned} &
                    s_session                    = s_session$0 &
                    a_client_to_create           = a_client_to_create$0 &
                    a_client_app_context         = a_client_app_context$0 &
                    a_user_server                = a_user_server$0 &
                    a_user_client                = a_user_client$0 &
                    a_server_token               = a_server_token$0 &
                    a_client_token               = a_client_token$0 &
                    a_NonceServer                = a_NonceServer$0 &
                    a_NonceClient                = a_NonceClient$0 &
                    a_client_orphaned            = a_client_orphaned$0 &
                    a_session_roles              = a_session_roles$0
                ) &
                (   a_state$0(p_session) /= e_session_userActivated
                    =>
                    s_session                    = s_session$0 - {p_session} &
                    a_state                      = {p_session} <<| a_state$0 &
                    a_channel                    = {p_session} <<| a_channel$0 &
                    a_client_to_create           = {p_session} <<| a_client_to_create$0 &
                    a_client_app_context         = {p_session} <<| a_client_app_context$0 &
                    a_client_orphaned            = {p_session} <<| a_client_orphaned$0 &
                    a_user_server                = {p_session} <<| a_user_server$0 &
                    a_user_client                = {p_session} <<| a_user_client$0 &
                    a_server_token               = a_server_token$0 |>> {p_session} &
                    a_client_token               = {p_session} <<| a_client_token$0 &
                    a_NonceServer                = {p_session} <<| a_NonceServer$0 &
                    a_NonceClient                = {p_session} <<| a_NonceClient$0 &
                    a_session_roles              = {p_session} <<| a_session_roles$0
                )
            )
        )
    END

OPERATIONS

    res_activated <-- server_internal_activate_req_and_resp (channel, session, p_user, activate_req_msg, activate_resp_msg) =
    VAR
        l_channel_config_idx,
        l_secpol,
        l_endpoint_config_idx,
        l_nonce,
        l_localeIds
    IN
        l_channel_config_idx <-- get_channel_info (channel);
        l_secpol <-- get_SecurityPolicy(channel);
        l_endpoint_config_idx <-- server_get_endpoint_config (channel);
        IF l_secpol /= e_secpol_None THEN
            res_activated <-- server_activate_session_check_crypto(l_endpoint_config_idx, session, channel, l_channel_config_idx, activate_req_msg)
        ELSE
            res_activated := TRUE
        END
        ;
        IF res_activated = TRUE THEN
            res_activated, l_nonce <-- server_set_fresh_nonce(session, l_channel_config_idx);
            IF res_activated = TRUE THEN
                write_activate_session_resp_nonce(activate_resp_msg, l_nonce)
            END
        END
        ;
        /* Note: results[] and diagnosticInfos[] info fields should not be filled
           since it concerns SoftwareCertificate from request which is reserved for a future use */
        IF res_activated = TRUE THEN
            drop_user_server (session); // In case a previous user was set, drop it
            set_session_user_server (session, p_user);
            set_session_channel (session, channel);
            l_localeIds <-- read_activate_req_msg_locales (activate_req_msg);
            set_server_session_preferred_locales_or_indet (session, l_localeIds);
            set_session_state (session, e_session_userActivated)
        END
    END
    ;

    ret <-- l_server_activate_session_req_and_resp_sm (channel, session, user, activate_req_msg, activate_resp_msg) =
    VAR
        l_channel,
        l_state,
        l_user,
        l_is_same_user,
        l_valid,
        l_ret
    IN
        l_channel <-- get_session_channel (session);
        l_state <-- get_session_state (session);
        IF l_state = e_session_created
        THEN
            /* Channel must be the same and user must be set */
            IF l_channel = channel
            THEN
                l_valid <-- server_internal_activate_req_and_resp (channel,
                                                                   session,
                                                                   user,
                                                                   activate_req_msg,
                                                                   activate_resp_msg);
                IF l_valid = TRUE THEN
                    l_ret := e_sc_ok
                ELSE
                    /* Note: it also might be an unexpected internal error */
                    l_ret := e_sc_bad_application_signature_invalid
                END
            ELSE
                l_ret := e_sc_bad_invalid_argument
            END
        ELSIF l_state = e_session_userActivated
        THEN
            l_user <-- get_session_user_server (session);
            /* User changed XOR channel changed */
            IF l_channel = channel
            THEN
                l_valid <-- server_internal_activate_req_and_resp (channel,
                                                                   session,
                                                                   user,
                                                                   activate_req_msg,
                                                                   activate_resp_msg);
                IF l_valid = TRUE THEN
                    l_ret := e_sc_ok
                ELSE
                    /* Note: it also might be an unexpected internal error */
                    l_ret := e_sc_bad_application_signature_invalid
                END
            ELSIF l_channel /= channel
            THEN
                l_is_same_user <-- is_same_user_server (l_user, user);
                /* User shall remain the same if channel is different */
                IF l_is_same_user = TRUE
                THEN
                    l_valid <-- server_internal_activate_req_and_resp (channel,
                        session,
                        user,
                        activate_req_msg,
                        activate_resp_msg);
                    IF l_valid = TRUE THEN
                        l_ret := e_sc_ok
                    ELSE
                        /* Note: it also might be an unexpected internal error */
                        l_ret := e_sc_bad_application_signature_invalid
                    END
                ELSE
                    l_ret := e_sc_bad_invalid_state
                END
            ELSE
                l_ret := e_sc_bad_invalid_state
            END
        ELSIF l_state = e_session_scOrphaned
        THEN
            l_user <-- get_session_user_server (session);
            l_is_same_user <-- is_same_user_server (l_user, user);
            /* Channel changed */
            IF l_is_same_user = TRUE
            THEN
                l_valid <-- server_internal_activate_req_and_resp (channel,
                                                                   session,
                                                                   user,
                                                                   activate_req_msg,
                                                                   activate_resp_msg);
                IF l_valid = TRUE THEN
                    l_ret := e_sc_ok
                ELSE
                    /* Note: it also might be an unexpected internal error */
                    l_ret := e_sc_bad_application_signature_invalid
                END
            ELSE
                l_ret := e_sc_bad_invalid_state
            END
        ELSE
            l_ret := e_sc_bad_invalid_state
        END;
        ret := l_ret
    END
    ;

    /* END OF LOCAL OPERATIONS */
    nsession <-- client_init_session_sm(p_user_token, p_app_context) =
    BEGIN
        nsession <-- init_new_session (TRUE);
        IF nsession /= c_session_indet THEN
            set_session_user_client(nsession, p_user_token);
            set_session_app_context(nsession, p_app_context)
        END
    END;

    valid <-- client_create_session_req_sm (session, channel, create_req_msg) =
    VAR
        l_channel_config_idx,
        l_nonce_needed,
        l_nonce,
        l_app_context
    IN
        create_session (session, channel, e_session_creating);
        l_channel_config_idx <-- get_channel_info (channel);
        valid, l_nonce_needed <-- client_create_session_req_do_crypto(session, channel, l_channel_config_idx);
        IF valid = TRUE THEN
            write_create_session_req_msg_clientDescription (create_req_msg, l_channel_config_idx);
            write_create_session_req_msg_serverUri (create_req_msg, l_channel_config_idx);
            write_create_session_req_msg_endpointUrl (create_req_msg, l_channel_config_idx);
            l_app_context <-- get_session_app_context(session);
            write_create_session_req_msg_sessionName (create_req_msg, l_app_context);
            IF l_nonce_needed = TRUE THEN
                l_nonce <-- get_NonceClient(session);

                valid <-- write_create_session_req_msg_crypto(create_req_msg, l_channel_config_idx, l_nonce)
            END;
            write_create_session_req_msg_sessionTimeout (create_req_msg);
            write_create_session_req_msg_maxResponseMessageSize (create_req_msg)
        END
    END
    ;

    p_service_ret <-- l_server_write_create_session_resp (p_session, p_channel, p_session_token, create_req_msg, create_resp_msg) =
    VAR
        l_channel_config_idx,
        l_endpoint_config_idx,
        l_crypto_status,
        l_signature,
        l_nonce,
        l_secpol,
        l_set_cert,
        l_cli_app_desc,
        l_cli_cert_tb,
        l_bret
    IN
        l_set_cert := FALSE;
        l_channel_config_idx <-- get_channel_info (p_channel);
        l_endpoint_config_idx <-- server_get_endpoint_config (p_channel);

        write_create_session_msg_session_token (create_resp_msg, p_session, p_session_token);
        /* Set revised timeout to : MIN <= requested timeout <= MAX */
        write_create_session_msg_session_revised_timeout (create_req_msg, create_resp_msg);
        write_create_session_resp_msg_maxRequestMessageSize (create_resp_msg);

        p_service_ret <-- write_create_session_msg_server_endpoints (create_req_msg, create_resp_msg, l_endpoint_config_idx);
        IF p_service_ret = e_sc_ok THEN
            l_secpol <-- get_SecurityPolicy(p_channel);
            IF l_secpol /= e_secpol_None THEN
                /* If the security policy is not none, the nonce and server certificate are needed */
                l_set_cert := TRUE;
                /* Do the cryptographic challenge which may fail because of mallocs */
                l_crypto_status, l_signature <-- server_create_session_req_do_crypto(create_req_msg, l_endpoint_config_idx, l_channel_config_idx);
                IF  l_crypto_status = e_sc_ok THEN
                    /* Write server signature */
                    l_bret <-- write_create_session_resp_signature(create_resp_msg, l_signature);
                    clear_Signature(l_signature);
                    IF l_bret = FALSE THEN
                        p_service_ret := e_sc_bad_unexpected_error
                    END
                ELSE
                    p_service_ret := l_crypto_status
                END
            END
            ;
            IF p_service_ret = e_sc_ok THEN
                IF l_set_cert = FALSE THEN
                    /* In case the security policy is None we might still need the nonce for password encryption */
                    l_endpoint_config_idx <-- server_get_endpoint_config (p_channel);
                    l_set_cert <-- server_may_need_user_token_encryption(l_endpoint_config_idx, l_channel_config_idx)
                END
                ;
                IF l_set_cert = TRUE THEN
                    /* Write server certificate */
                    l_bret <-- write_create_session_resp_cert(create_resp_msg, l_endpoint_config_idx)
                ELSE
                    l_bret := TRUE
                END
                ;
                IF l_bret = TRUE THEN
                    l_bret, l_nonce <-- server_set_fresh_nonce(p_session, l_channel_config_idx);
                    IF l_bret = TRUE THEN
                        /* Write server nonce */
                        write_create_session_resp_nonce(create_resp_msg, l_nonce)
                    END
                END
                ;
                IF l_bret = TRUE THEN
                    l_cli_app_desc <-- get_create_session_req_client_desc_copy(create_req_msg);
                    l_cli_cert_tb <-- get_create_session_req_client_certificate_tb(create_req_msg);
                    set_server_client_create_session_info (p_session, l_cli_app_desc, l_cli_cert_tb)
                END
                ;
                IF l_bret = FALSE THEN
                    p_service_ret := e_sc_bad_unexpected_error
                END
            END
        END
        ;
        IF p_service_ret = e_sc_ok THEN
            /* Minimize the encoding OPC UA message body maximum size with the maxResponseMessageSize requested by client.
               Initial value is defined with SC sendMaxMessageSize.*/
            create_session_req_export_maxResponseMessageSize (l_channel_config_idx, create_req_msg)
        END
    END
    ;

    nsession, p_service_ret <-- l_server_create_session_req_and_resp_sm (p_session, p_channel, create_req_msg, create_resp_msg) =
    VAR
        l_channel_config_idx,
        l_nsession_token,
        l_valid_session_token,
        l_valid_server_cert
    IN
        create_session(p_session, p_channel, e_session_created);
        l_channel_config_idx <-- get_channel_info (p_channel);
        l_valid_server_cert <-- create_session_req_check_client_certificate (create_req_msg, l_channel_config_idx);
        l_nsession_token <-- server_get_fresh_session_token (l_channel_config_idx, p_session);
        l_valid_session_token <-- server_is_valid_session_token (l_nsession_token);
        IF  l_valid_session_token = TRUE & l_valid_server_cert = TRUE
        THEN
            nsession := p_session;
            p_service_ret <-- l_server_write_create_session_resp (p_session, p_channel, l_nsession_token, create_req_msg, create_resp_msg)
        ELSE
            IF l_valid_server_cert = TRUE
            THEN
                p_service_ret := e_sc_bad_too_many_sessions
            ELSE
                p_service_ret := e_sc_bad_security_checks_failed
            END;
            nsession := c_session_indet;
            set_session_state_closed (p_session, e_sc_bad_session_id_invalid)
        END
    END
    ;

    nsession, service_ret <-- server_create_session_req_and_resp_sm (channel, create_req_msg, create_resp_msg) =
    VAR
        l_nsession,
        l_valid_session
    IN
        service_ret := e_sc_bad_out_of_memory;
        l_nsession <-- init_new_session (FALSE);
        l_valid_session <-- is_valid_session (l_nsession);
        IF l_valid_session = TRUE THEN
            nsession, service_ret <-- l_server_create_session_req_and_resp_sm (l_nsession, channel, create_req_msg, create_resp_msg)
        ELSE
            nsession := c_session_indet;
            service_ret := e_sc_bad_too_many_sessions
        END
    END
    ;

    bret <-- client_create_session_resp_sm (channel, session, session_token, create_resp_msg) =
    VAR
        l_valid_user_secu_properties,
        l_endpoints_bres,
        l_valid_server_cert,
        l_valid_session_token,
        l_channel_config_idx,
        l_secpol
    IN
        /* TODO: check Request:handle == Response:handle */
        /* TODO? check Response:serverEndpoints */
        /* Check server signature */
        l_secpol <-- get_SecurityPolicy(channel);
        l_channel_config_idx <-- get_channel_info (channel);
        /* Note: only check the certificate is the same than SC,
           if certificate validation needed (SC secu = None and User secu != None) it is done during ActivateSession */
        l_valid_server_cert <-- create_session_resp_check_server_certificate (create_resp_msg, l_channel_config_idx);
        l_endpoints_bres <-- create_session_resp_check_server_endpoints (create_resp_msg, l_channel_config_idx);
        l_valid_user_secu_properties <-- client_create_session_set_user_token_secu_properties(session, l_channel_config_idx, create_resp_msg);
        l_valid_session_token <-- client_is_valid_session_token(session_token);
        bret := bool(l_valid_server_cert = TRUE & l_endpoints_bres = TRUE & l_valid_user_secu_properties = TRUE & l_valid_session_token = TRUE);
        IF bret = TRUE THEN
            IF l_secpol /= e_secpol_None THEN
                /* Note: receiving a request implies that we sent it, and Nonce, if needed, was valid, hence get_NonceClient cannot fail. */
                /* TODO: at least validate nonce value. In this case it could also be better to have it as parameter of check_crypto ! */
                bret <-- client_create_session_check_crypto(session, l_channel_config_idx, create_resp_msg);
                IF bret = TRUE THEN
                    drop_NonceClient(session)
                END
            ELSE
                /* We still might need the server nonce in case the user token security policy != None */
                client_set_NonceServer(session, create_resp_msg)
            END
        END;
        IF bret = TRUE THEN
            set_session_state (session, e_session_created);
            client_set_session_token (session, session_token);
            /* Minimize the encoding OPC UA message body maximum size with the maxRequestMessageSize requested by server.
               Initial value is defined with SC sendMaxMessageSize.*/
            create_session_resp_export_maxRequestMessageSize(l_channel_config_idx, create_resp_msg)
        END
    END
    ;

    p_ret, p_session_token <-- l_client_user_activate_session_req_sm (p_session, p_channel, p_user_token, activate_req_msg) =
    VAR
        l_channel_config_idx,
        l_secpol,
        l_valid_crypto,
        l_signature,
        l_server_nonce,
        l_user_secu_policy,
        l_user_server_cert,
        l_encrypted_user_token,
        l_valid_cert,
        l_valid_encrypt,
        l_bret,
        l_valid_user_token_sign,
        l_user_token_type,
        l_user_token_signature,
        l_app_context
    IN
        p_session_token <-- client_get_token_from_session (p_session);
        l_channel_config_idx <-- get_channel_info (p_channel);
        l_server_nonce <-- get_NonceServer(p_session, TRUE);
        l_user_secu_policy <-- get_session_user_secu_client(p_session);
        l_user_server_cert <-- get_session_user_server_certificate(p_session);
        l_user_token_type <-- get_user_token_type_from_token(p_user_token);
        // Initialize booleans
        l_valid_cert := FALSE;
        l_valid_user_token_sign := FALSE;
        l_user_token_signature := c_SignatureData_indet;
        IF l_user_token_type = e_userTokenType_userName THEN
            IF l_user_secu_policy = e_secpol_None THEN
                // No user encryption
                l_valid_cert := TRUE
            ELSE
                // Note: server certificate is validated in case no certificate used by SC and user token needs it for encryption
                l_valid_cert <-- may_validate_server_certificate(p_session, l_channel_config_idx, l_user_server_cert, l_user_secu_policy)
            END
        ELSIF l_user_token_type = e_userTokenType_x509 THEN
            IF l_user_secu_policy /= e_secpol_None THEN
                l_app_context <-- get_session_app_context(p_session);
                l_user_token_signature <-- sign_user_token(l_user_server_cert, l_server_nonce, l_user_secu_policy, l_app_context)
            END
            ;
            IF l_user_token_signature /= c_SignatureData_indet THEN
                l_valid_user_token_sign <-- write_activate_msg_user_token_signature(activate_req_msg, l_user_token_signature);
                clear_Signature(l_user_token_signature)
            END
        ELSIF l_user_token_type = e_userTokenType_anonymous THEN
            l_valid_cert := TRUE
        END
        ;
        IF l_valid_cert = TRUE or l_valid_user_token_sign = TRUE THEN
            l_valid_encrypt, l_encrypted_user_token <-- may_encrypt_user_token(l_channel_config_idx, l_user_server_cert, l_server_nonce, l_user_secu_policy, p_user_token)
        ELSE
            l_encrypted_user_token := c_user_token_indet;
            l_valid_encrypt := FALSE
        END
        ;
        /* TODO: populate msg with parameters */
        IF l_valid_encrypt = TRUE THEN
            write_activate_msg_user(activate_req_msg, l_encrypted_user_token);
            l_secpol <-- get_SecurityPolicy(p_channel);
            IF l_secpol /= e_secpol_None THEN
                // TODO: validate server nonce ? Or guaranteed by session state ?
                l_valid_crypto, l_signature <-- client_activate_session_req_do_crypto(p_session, l_channel_config_idx, l_server_nonce);
                IF l_valid_crypto = TRUE THEN
                    l_bret <-- write_activate_session_req_msg_crypto(activate_req_msg, l_signature);
                    clear_Signature(l_signature);
                    IF l_bret = TRUE THEN
                        write_activate_req_msg_locales(activate_req_msg, l_channel_config_idx);
                        p_ret := e_sc_ok
                    ELSE
                        p_ret := e_sc_bad_unexpected_error
                    END
                ELSE
                    p_ret := e_sc_bad_security_checks_failed
                END
            ELSE
                p_ret := e_sc_ok
            END
        ELSE
            /* The cert is not valid or the user token encryption failed */
            p_ret := e_sc_bad_security_checks_failed
        END
    END
    ;

    ret, channel, session_token <-- client_user_activate_session_req_sm (session, p_user_token, activate_req_msg) =
    VAR
        l_is_connected_channel
    IN
        channel <-- get_session_channel (session);
        l_is_connected_channel <-- is_connected_channel(channel);
        IF l_is_connected_channel = TRUE THEN
            ret, session_token <-- l_client_user_activate_session_req_sm(session, channel, p_user_token, activate_req_msg)
        ELSE
            channel := c_channel_indet;
            session_token := c_session_token_indet;
            ret := e_sc_bad_unexpected_error
        END;
        IF ret = e_sc_ok THEN
            set_session_state(session, e_session_userActivating)
        END
    END
    ;

    session_token <-- client_sc_activate_session_req_sm (session, channel, activate_req_msg) =
    VAR
        l_user_token,
        l_channel_config_idx
    IN
        session_token <-- client_get_token_from_session (session);
        l_user_token <-- get_session_user_client (session);
        l_channel_config_idx <-- get_channel_info (channel);
        write_activate_req_msg_locales(activate_req_msg, l_channel_config_idx);
        write_activate_msg_user(activate_req_msg, l_user_token);
        set_session_channel(session, channel);
        set_session_state(session, e_session_scActivating)
    END
    ;

    p_sc_valid_user, p_max_attempts, p_user <-- allocate_authenticated_user (p_channel, p_session, p_user_token, p_user_token_signature) =
    VAR
        l_channel_config_idx,
        l_endpoint_config_idx,
        l_server_nonce
    IN
        l_channel_config_idx <-- get_channel_info (p_channel);
        l_endpoint_config_idx <-- server_get_endpoint_config (p_channel);
        l_server_nonce <-- get_NonceServer(p_session, FALSE);
        p_sc_valid_user, p_user <-- allocate_valid_and_authenticated_user (p_user_token, l_server_nonce, l_channel_config_idx, l_endpoint_config_idx, p_user_token_signature);
        p_max_attempts <-- check_server_session_user_auth_attempts(p_session, bool(p_sc_valid_user = e_sc_ok))
    END
    ;

    ret <-- server_activate_session_req_and_resp_sm (channel, session, user, activate_req_msg, activate_resp_msg) =
    VAR
        l_userRoles
    IN
        ret <-- l_server_activate_session_req_and_resp_sm(channel, session, user, activate_req_msg, activate_resp_msg);
        IF ret = e_sc_ok
        THEN
            /* If session is activated, assign roles to the session. */
            l_userRoles <-- compute_user_roles(user);
            set_session_roles(session, l_userRoles)
        END
    END
    ;

    bret <-- client_activate_session_resp_sm (channel , session, activate_resp_msg) =
    VAR
        l_channel_config_idx,
        l_valid_response
    IN
        /* PRE checked channel was session channel*/
        l_channel_config_idx <-- get_channel_info (channel);
        /* TODO: check response parameters + nonce param if applicable */
        l_valid_response <-- client_activate_session_resp_check(session, l_channel_config_idx,  activate_resp_msg);
        IF l_valid_response = TRUE
        THEN
            set_session_state (session, e_session_userActivated);
            bret := TRUE
        ELSE
            bret := FALSE
        END
    END
    ;

    l_client_secure_channel_lost_session_sm(p_channel, p_lost_channel, p_session, p_channel_config_idx) =
    VAR
        l_state
    IN
        IF p_channel = p_lost_channel
        THEN
            l_state <-- get_session_state (p_session);
            IF l_state = e_session_userActivated
            THEN
                /* Active sessions set to orphaned and channel config idx associated */
                set_session_orphaned (p_session, p_channel_config_idx);
                set_session_state (p_session, e_session_scOrphaned)
            ELSE
                /* Inactive sessions or all orphaned sessions (if no new channel can be associated) */
                set_session_state_closed (p_session, e_sc_bad_secure_channel_closed)
            END
        END
    END
    ;

    client_secure_channel_lost_session_sm (p_lost_channel, p_channel_config_idx) =
    VAR
        l_continue,
        l_session,
        l_dom,
        l_channel
    IN
        l_continue <-- init_iter_session;
        IF  l_continue = TRUE THEN  /* Only for proving */
            WHILE l_continue = TRUE DO
                l_continue, l_session <-- continue_iter_session;
                l_dom, l_channel <-- getall_session_channel(l_session);
                IF l_dom = TRUE THEN
                    l_client_secure_channel_lost_session_sm(l_channel, p_lost_channel, l_session, p_channel_config_idx)
                END
            INVARIANT
                sessions_to_iterate <: t_session &
                sessions_iterated   <: t_session &
                sessions_to_iterate /\ sessions_iterated = {} &
                sessions_to_iterate \/ sessions_iterated = t_session &
                l_continue = bool(sessions_to_iterate /= {}) &
                dom(a_channel) <: dom(a_state) &
                s_session                    = s_session$0 - d_inactive_sessions                                                         &
                a_state                      = d_inactive_sessions <<| a_state$0 <+ d_active_sessions * {e_session_scOrphaned}           &
                a_channel                    = d_inactive_sessions <<| a_channel$0 |>> {p_lost_channel}                                  &
                a_client_to_create           = d_inactive_sessions <<| a_client_to_create$0                                              &
                a_client_app_context         = d_inactive_sessions <<| a_client_app_context$0                                            &
                a_client_orphaned            = d_inactive_sessions <<| a_client_orphaned$0 <+ d_active_sessions * {p_channel_config_idx} &
                a_user_server                = d_inactive_sessions <<| a_user_server$0                                                   &
                a_user_client                = d_inactive_sessions <<| a_user_client$0                                                   &
                a_server_token               = a_server_token$0 |>> d_inactive_sessions                                                  &
                a_client_token               = d_inactive_sessions <<| a_client_token$0                                                  &
                a_NonceServer                = d_inactive_sessions <<| a_NonceServer$0                                                   &
                a_NonceClient                = d_inactive_sessions <<| a_NonceClient$0
            VARIANT
                card(sessions_to_iterate)
            END
        END
    END
    ;

    l_server_secure_channel_lost_session_sm(p_channel, p_lost_channel, p_session) =
    VAR
        l_state
    IN
        IF p_channel = p_lost_channel
        THEN
            l_state <-- get_session_state (p_session);
            IF l_state = e_session_userActivated
            THEN
                set_session_orphaned (p_session, c_channel_config_idx_indet);
                set_session_state (p_session, e_session_scOrphaned)
            ELSE
                /* may generate audit event */
                server_notify_session_closed(p_session, e_sc_bad_secure_channel_closed);
                set_session_state_closed (p_session, e_sc_bad_secure_channel_closed)
            END
        END
    END
    ;

    server_secure_channel_lost_session_sm (p_lost_channel) =
    VAR
        l_continue,
        l_session,
        l_dom,
        l_channel,
        l_channel_config_idx
    IN
        l_channel_config_idx <-- get_channel_info (p_lost_channel);
        set_no_req_audit_info (l_channel_config_idx); /* Set info for audit event generation */
        l_continue <-- init_iter_session;
        IF  l_continue = TRUE THEN  /* Only for proving */
            WHILE l_continue = TRUE DO
                l_continue, l_session <-- continue_iter_session;
                l_dom, l_channel <-- getall_session_channel(l_session);
                IF l_dom = TRUE THEN
                    l_server_secure_channel_lost_session_sm(l_channel, p_lost_channel, l_session)
                END
            INVARIANT
                sessions_to_iterate <: t_session &
                sessions_iterated   <: t_session &
                sessions_to_iterate /\ sessions_iterated = {} &
                sessions_to_iterate \/ sessions_iterated = t_session&
                l_continue = bool(sessions_to_iterate /= {}) &
                dom(a_channel) <: dom(a_state) &
                s_session                    = s_session$0 - d_inactive_sessions                                               &
                a_state                      = d_inactive_sessions <<| a_state$0 <+ d_active_sessions * {e_session_scOrphaned} &
                a_channel                    = d_inactive_sessions <<| a_channel$0 |>> {p_lost_channel}                        &
                a_client_to_create           = d_inactive_sessions <<| a_client_to_create$0                                    &
                a_client_app_context         = d_inactive_sessions <<| a_client_app_context$0                                  &
                a_client_orphaned            = d_inactive_sessions <<| a_client_orphaned$0                                     &
                a_user_server                = d_inactive_sessions <<| a_user_server$0                                         &
                a_user_client                = d_inactive_sessions <<| a_user_client$0                                         &
                a_server_token               = a_server_token$0 |>> d_inactive_sessions                                        &
                a_client_token               = d_inactive_sessions <<| a_client_token$0                                        &
                a_NonceServer                = d_inactive_sessions <<| a_NonceServer$0                                         &
                a_NonceClient                = d_inactive_sessions <<| a_NonceClient$0
            VARIANT
                card(sessions_to_iterate)
            END
        END
        ;
        clear_audit_info
    END
    ;

    ret, channel, session_token <-- client_close_session_req_sm (session, close_req_msg) =
    VAR
        l_is_connected_channel
    IN
        /* PRE check request msg type expected */
        /* TODO: fulfill delete subscriptions flag (to be provided as param ?) */
        client_close_session_req_msg(close_req_msg); /* Avoid unused variable*/

        channel <-- get_session_channel (session);
        l_is_connected_channel <-- is_connected_channel(channel);
        IF l_is_connected_channel = TRUE
        THEN
            session_token <-- client_get_token_from_session (session);
            /* TODO: populate msg with parameters */
            set_session_state (session, e_session_closing);
            ret := e_sc_ok
        ELSE
            channel := c_channel_indet;
            session_token := c_session_token_indet;
            ret := e_sc_bad_unexpected_error
        END

    END
    ;

    ret <-- server_close_session_req_and_resp_sm (channel, session, close_req_msg, close_resp_msg) =
    BEGIN
        /* PRE guarantee channel is connected */
        channel_do_nothing (channel); /* Avoid unused variable */
        /* TODO: actions on pending requests or current subscriptions to manage (see request) */
        server_close_session_check_req (close_req_msg, close_resp_msg);
        /* may generate audit event */
        server_notify_session_closed(session, e_sc_ok);
        /* No need to store the handle since we will send response in same step */
        set_session_state_closed (session, e_sc_ok);
        ret := e_sc_ok
    END
    ;

    client_close_session_resp_sm (channel, session, close_resp_msg) =
    BEGIN
        /* PRE guarantee channel is connected */
        channel_do_nothing (channel); /* Avoid unused variable */
        client_close_session_resp_msg(close_resp_msg); /* Avoid unused variable*/
        /* In any case we close the session: correct channel or not  */
        set_session_state_closed (session, e_sc_ok)
    END
    ;

    client_close_session_sm (session, sc_reason) =
    BEGIN
        set_session_state_closed (session, sc_reason)
    END
    ;

    server_close_session_sm (session, sc_reason) =
    BEGIN
        /* may generate audit event */
        server_notify_session_closed(session, sc_reason);
        set_session_state_closed (session, sc_reason)
    END
    ;

    ret <-- is_session_valid_for_service (channel, session) =
    BEGIN
        // only for PRE compliance
        channel_do_nothing (channel); /* Avoid unused variable */
        session_do_nothing (session); /* Avoid unused variable */
        ret := TRUE
    END
    ;

    state <-- get_session_state_or_closed (session) =
    VAR
        l_valid_session
    IN
        l_valid_session <-- is_valid_session (session);
        IF l_valid_session = TRUE
        THEN
            state <-- get_session_state (session)
        ELSE
            state := e_session_closed
        END
    END
    ;

    p_has_channel_to_close, p_channel_to_close <-- find_channel_to_close =
    VAR
        l_continue,
        l_channel,
        l_connected,
        l_nb_sessions,
        l_timeref,
        l_is_older_than,
        l_oldest_channel,
        l_oldest_channel_timeref
    IN
        l_oldest_channel := c_channel_indet;
        l_oldest_channel_timeref := c_timeref_indet;
        l_continue <-- init_iter_channel;
        WHILE
            l_continue = TRUE
        DO
            l_continue, l_channel <-- continue_iter_channel;
            l_connected <-- is_connected_channel(l_channel);
            l_nb_sessions <-- get_channel_nb_sessions(l_channel);
            IF l_connected = TRUE & l_nb_sessions = 0
            THEN
                l_timeref <-- get_connection_time(l_channel);
                IF l_oldest_channel_timeref = c_timeref_indet
                THEN
                    /* first secure channel we are allowed to close found */
                    l_oldest_channel_timeref := l_timeref;
                    l_oldest_channel := l_channel
                ELSE
                    l_is_older_than <-- is_less_than_TimeReference(l_timeref, l_oldest_channel_timeref);
                    IF l_is_older_than = TRUE
                    THEN
                        /* older secure channel to close found */
                        l_oldest_channel_timeref := l_timeref;
                        l_oldest_channel := l_channel
                    END
                END
            END // ELSE: we cannot close a channel with a session
        INVARIANT
            l_oldest_channel : t_channel_i &
            l_oldest_channel_timeref : t_timeref_i &

            channels_to_iterate <: t_channel &
            channels_iterated   <: t_channel &
            l_continue = bool(channels_to_iterate /= {}) &
            channels_to_iterate /\ channels_iterated = {} &
            channels_to_iterate \/ channels_iterated = t_channel &

            (l_oldest_channel = c_channel_indet =>
                l_oldest_channel_timeref = c_timeref_indet &
                channels_iterated /\ s_channel_connected - ran(a_channel) = {}) &

            (l_oldest_channel /= c_channel_indet =>
                l_oldest_channel : s_channel_connected - ran(a_channel) &
                l_oldest_channel_timeref : t_timeref &
                l_oldest_channel : a_channel_connected_time~[{l_oldest_channel_timeref}] &
                !(p_channel).(p_channel : channels_iterated /\ s_channel_connected - ran(a_channel) =>
                    /* Oldest timeref is less than any other timeref */
                    (l_oldest_channel_timeref /= a_channel_connected_time(p_channel) =>
                        l_oldest_channel_timeref |-> a_channel_connected_time(p_channel) : TimeReference_IsLessThan)
                )
            )
        VARIANT
            card(channels_to_iterate)
        END;
        IF l_oldest_channel_timeref = c_timeref_indet
        THEN
            p_has_channel_to_close := FALSE;
            p_channel_to_close := c_channel_indet
        ELSE
            p_has_channel_to_close := TRUE;
            p_channel_to_close := l_oldest_channel
        END
    END
    ;

    bres, channel <-- getall_valid_session_channel (session) =
    BEGIN
        bres <-- is_valid_session (session);
        IF bres = TRUE
        THEN
            channel <-- get_session_channel (session)
        ELSE
            bres, channel <-- getall_session_channel (session)
        END
    END
    ;

    may_close_unactivated_session =
    VAR
        l_auto_closed_active,
        l_has_session_to_close,
        l_session_to_close,
        l_is_client
    IN
        l_auto_closed_active <-- is_auto_close_session_active;
        IF l_auto_closed_active = TRUE
        THEN
            l_has_session_to_close, l_session_to_close <-- find_session_to_close;
            IF l_has_session_to_close = TRUE
            THEN
                l_is_client <-- is_client_session (l_session_to_close);
                IF l_is_client = FALSE
                THEN
                    /* may generate audit event */
                    server_notify_session_closed (l_session_to_close, e_sc_bad_session_not_activated)
                END
                ;
                set_session_state_closed (l_session_to_close, e_sc_bad_session_not_activated)
            END
        END
    END
    ;

    session_core_UNINITIALISATION =
    VAR
        l_continue,
        l_session,
        l_valid_session,
        l_is_client
    IN
        l_continue <-- init_iter_session;
        IF  l_continue = TRUE THEN  /* Only for proving */
            WHILE l_continue = TRUE DO
                l_continue, l_session <-- continue_iter_session;
                l_valid_session <-- is_valid_session(l_session);

                IF l_valid_session = TRUE
                THEN
                    set_session_state_closed (l_session, e_sc_ok)
                    // Note: do not trigger audit event with server_notify_session_closed on UNINIT
                    //       (even if expected on server shutdown by specification, it is not possible)
                END
            INVARIANT
                sessions_to_iterate <: t_session &
                sessions_iterated   <: t_session &
                sessions_to_iterate /\ sessions_iterated = {} &
                sessions_to_iterate \/ sessions_iterated = t_session &
                l_continue = bool(sessions_to_iterate /= {}) &
                dom(a_channel) <: dom(a_state) &
                s_session                    = s_session - sessions_iterated &
                a_state                      = sessions_iterated <<| a_state        &
                a_channel                    = sessions_iterated <<| a_channel      &
                a_client_to_create           = sessions_iterated <<| a_client_to_create &
                a_client_app_context         = sessions_iterated <<| a_client_app_context &
                a_client_orphaned            = sessions_iterated <<| a_client_orphaned &
                a_user_server                = sessions_iterated <<| a_user_server &
                a_server_user_auth_attempts  = sessions_iterated <<| a_server_user_auth_attempts &
                a_user_client                = sessions_iterated <<| a_user_client &
                a_server_token               = a_server_token |>> sessions_iterated &
                a_client_token               = sessions_iterated <<| a_client_token &
                a_NonceServer                = sessions_iterated <<| a_NonceServer &
                a_NonceClient                = sessions_iterated <<| a_NonceClient &
                sessions_iterated <| a_server_client_locales = sessions_iterated * {c_LocaleIds_empty}
            VARIANT
                card(sessions_to_iterate)
            END
        END
    END

END
