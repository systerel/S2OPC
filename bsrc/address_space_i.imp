/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    address_space_i

REFINES
    address_space_r

SEES
    constants,
    service_write_decode_bs,
    service_mgr_1,
    service_response_cb_bs,
    write_value_pointer_bs

IMPORTS
    address_space_bs,
    response_write_bs,
    address_space_it,
    gen_subscription_event_bs,
    user_authorization_bs,
    data_value_pointer_bs

PROMOTES
    readall_AddressSpace_Node,
    get_NodeClass,
    get_BrowseName,
    get_DisplayName,
    get_TypeDefinition,
    get_Reference_ReferenceType,
    get_Reference_TargetNode,
    get_Reference_IsForward,
    get_Node_RefIndexEnd,
    get_RefIndex_Reference,
    get_Value_StatusCode,
    read_AddressSpace_clear_value,
    read_AddressSpace_free_variant,
    write_WriteResponse_msg_out,
    get_user_authorization

CONCRETE_VARIABLES
    ResponseWrite_allocated

DEFINITIONS
    /* Relation associating to a node a value which is requested to be written
    in the address space */
    d_a_DataValue_requested ==
        (a_NodeClass~[{e_ncl_Variable}]           <| a_NodeId ;
                                                     WriteValue_NodeId~ ;
         (cast_t_WriteValue[1..nb_WriteValue] /\
          WriteValue_AttributeId~[{e_aid_Value}]) <| WriteValue_DataValue)

INITIALISATION
    ResponseWrite_allocated := FALSE

LOCAL_OPERATIONS
    /* Outer treat operation. Validates isvalid, validates user, records the write. */
    serviceStatusCode, prev_dataValue <-- treat_write_1(isvalid, status, p_user, nid, aid, dataValue, index_range) =
    PRE
        isvalid : BOOL &
        status : t_StatusCode_i &
        p_user : t_user_i &
        p_user : t_user   &
        nid : t_NodeId_i &
        aid : t_AttributeId_i &
        dataValue : t_DataValue_i &
        (isvalid = TRUE
            =>
         status = e_sc_ok & /* TODO: this is redundant with isvalid = TRUE */
         nid : t_NodeId &
         aid : t_AttributeId &
         dataValue : t_DataValue) &
        (isvalid = FALSE
            =>
         status : {e_sc_bad_attribute_id_invalid, e_sc_bad_index_range_invalid}) &
        a_NodeId : t_Node >-> t_NodeId &
        a_Value : t_Node +-> t_Variant &
        index_range : t_IndexRange_i
    THEN
        serviceStatusCode,
        prev_dataValue,
        a_Value,
        a_Value_StatusCode,
        a_Value_SourceTimestamp,
        a_Value_ServerTimestamp
        :(
            serviceStatusCode : t_StatusCode_i &
            serviceStatusCode : t_StatusCode &
            prev_dataValue : t_DataValue_i &
            a_Value : t_Node +-> t_Variant &
            a_Value_StatusCode : t_Node +-> t_StatusCode &
            a_Value_SourceTimestamp : t_Node +-> t_DateTime &
            a_Value_ServerTimestamp : t_Node +-> t_DateTime &

            (isvalid = TRUE &
             nid : ran(a_NodeId) &
             aid = e_aid_Value &
             a_NodeClass(a_NodeId~(nid)) = e_ncl_Variable &
             (local_service_treatment = TRUE
              or
              (conv_AccessLevel_CurrentWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE &
               e_operation_type_write |-> nid |-> aid |-> p_user : s_AuthorizedOperations)
             )
             =>
             serviceStatusCode = e_sc_ok &
             prev_dataValue : t_DataValue &
             DataValue_Variant(prev_dataValue) = a_Value$0(a_NodeId~(nid)) &
             a_Value = a_Value$0 <+ {a_NodeId~(nid) |-> DataValue_Variant(dataValue)} &

             (conv_AccessLevel_StatusWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE =>
                    DataValue_StatusCode(prev_dataValue) = a_Value_StatusCode$0(a_NodeId~(nid)) &
                    a_Value_StatusCode = a_Value_StatusCode$0 <+ {a_NodeId~(nid) |-> DataValue_StatusCode(dataValue)}) &
             (conv_AccessLevel_StatusWrite(a_AccessLevel(a_NodeId~(nid))) = FALSE => a_Value_StatusCode = a_Value_StatusCode$0) &

             (conv_AccessLevel_TimestampWrite (a_AccessLevel(a_NodeId~(nid))) = TRUE =>
                    DataValue_SourceTimestamp(prev_dataValue) = a_Value_SourceTimestamp$0(a_NodeId~(nid)) &
                    a_Value_SourceTimestamp = a_Value_SourceTimestamp$0 <+ {a_NodeId~(nid) |-> DataValue_SourceTimestamp(dataValue)}) &
             (conv_AccessLevel_TimestampWrite (a_AccessLevel(a_NodeId~(nid))) = FALSE => a_Value_SourceTimestamp = a_Value_SourceTimestamp$0) &

             DataValue_ServerTimestamp(prev_dataValue) = a_Value_ServerTimestamp$0(a_NodeId~(nid)) &
             a_Value_ServerTimestamp = a_Value_ServerTimestamp$0 <+ {a_NodeId~(nid) |-> DataValue_ServerTimestamp(dataValue)}) &

            /* TODO: detail all status code values regarding error case !*/
            (not(isvalid = TRUE &
                 status : t_StatusCode_i &
                 status : t_StatusCode &
                 nid : ran(a_NodeId) &
                 aid = e_aid_Value &
                 a_NodeClass(a_NodeId~(nid)) = e_ncl_Variable &
                 local_service_treatment = FALSE &
                 conv_AccessLevel_CurrentWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE &
                 e_operation_type_write |-> nid |-> aid |-> p_user : s_AuthorizedOperations)
             =>
             serviceStatusCode :
               {e_sc_bad_internal_error, e_sc_bad_attribute_id_invalid, e_sc_bad_node_id_unknown, e_sc_bad_not_writable, e_sc_bad_user_access_denied, e_sc_bad_index_range_no_data, e_sc_bad_index_range_invalid} &
             a_Value = a_Value$0 &
             a_Value_StatusCode = a_Value_StatusCode$0 &
             a_Value_SourceTimestamp = a_Value_SourceTimestamp$0 &
             a_Value_ServerTimestamp = a_Value_ServerTimestamp$0
            )
        )
    END

OPERATIONS
    sc, ncl, val <-- read_NodeClass_Attribute(p_user, node, aid, index_range) =
    BEGIN
        ncl <-- get_NodeClass(node);
        sc, val <-- read_AddressSpace_Attribute_value(p_user, node, ncl, aid, index_range)
    END
    ;

    /* --------------------------------------------------------------------- */
    /* Service Write */

    bret <-- alloc_write_request_responses(nb_req) =
    BEGIN
        IF nb_req <= k_n_WriteResponse_max THEN
            ResponseWrite_allocated <-- alloc_write_request_responses_malloc(nb_req)
        ELSE
            ResponseWrite_allocated := FALSE
        END;
        bret := ResponseWrite_allocated
    END
    ;

    StatusCode_service <-- treat_write_request_WriteValues (p_user) =
    VAR
        l_nb_req,
        l_continue,
        l_aid,
        l_nid,
        l_dataValue,
        l_index_range,
        l_wvi,
        l_status1,
        l_status2,
        l_prev_dataValue,
        l_isvalid,
        l_local_treatment,
        l_wv,
        l_bres_wv_copy,
        l_wv_copy
    IN
        StatusCode_service := e_sc_ok;
        l_nb_req <-- get_nb_WriteValue;
        l_continue <-- init_iter_write_request(l_nb_req);
        WHILE l_continue = TRUE DO
            l_continue, l_wvi <-- continue_iter_write_request;
            l_isvalid, l_status1, l_nid, l_aid, l_dataValue, l_index_range <-- getall_WriteValue(l_wvi);
            /* Avoids the IFs with a local operation. */
            l_status2, l_prev_dataValue <-- treat_write_1(l_isvalid, l_status1, p_user, l_nid, l_aid, l_dataValue, l_index_range);
            set_ResponseWrite_StatusCode(l_wvi, l_status2);
            l_wv <-- getall_WriteValuePointer(l_wvi);
            IF l_status2 = e_sc_ok
            THEN
                l_bres_wv_copy, l_wv_copy <-- copy_write_value_pointer_content (l_wv);
                IF l_bres_wv_copy = TRUE THEN
                    gen_data_changed_event (l_prev_dataValue, l_wv_copy)
                ELSE
                    gen_data_changed_event_failed (l_prev_dataValue)
                END
            ELSE
                write_AddressSpace_free_dataValue (l_prev_dataValue)
            END;
            l_local_treatment <-- is_local_service_treatment;
            IF l_local_treatment = FALSE
            THEN
                l_bres_wv_copy, l_wv_copy <-- copy_write_value_pointer_content (l_wv);
                IF l_bres_wv_copy = TRUE THEN
                    srv_write_notification (l_wv_copy, l_status2)
                ELSE
                    /* TODO: Generates an out of memory service result or error trace ? */
                    skip
                END
            END
        INVARIANT
            wreqs_to_iterate <: t_WriteValue &
            wreqs_iterated <: t_WriteValue &
            wreqs_to_iterate /\ wreqs_iterated = {} &
            wreqs_to_iterate \/ wreqs_iterated = cast_t_WriteValue[1..nb_WriteValue] &
            l_continue = bool(wreqs_to_iterate /= {}) &

            a_Value : t_Node +-> t_Variant &

            a_Value <: a_Value$0 <+ (d_a_DataValue_requested;DataValue_Variant) &
            a_Value_StatusCode <: a_Value_StatusCode$0 <+ (d_a_DataValue_requested;DataValue_StatusCode) &
            a_Value_SourceTimestamp <: a_Value_SourceTimestamp$0 <+ (d_a_DataValue_requested;DataValue_SourceTimestamp) &
            a_Value_ServerTimestamp <: a_Value_ServerTimestamp$0 <+ (d_a_DataValue_requested;DataValue_ServerTimestamp) &

            ResponseWrite_StatusCode = %wvi.(
                wvi : t_WriteValue &
                wvi : wreqs_iterated
                |
                {FALSE |-> e_sc_bad_attribute_id_invalid,
                 TRUE  |-> {FALSE |-> e_sc_bad_node_id_unknown,
                            TRUE  |-> {FALSE |-> e_sc_bad_not_writable, /* when attribute is invalid for given node class, should return attribute invalid*/
                                       TRUE  |-> {FALSE |-> e_sc_bad_user_access_denied,
                                                  TRUE |-> {FALSE |-> e_sc_bad_index_range_invalid,
                                                            TRUE |-> {FALSE |-> e_sc_bad_index_range_no_data,
                                                                      TRUE |-> e_sc_ok
                                                                      }(HasRange_VariantIndex(
                                                                         DataValue_Variant(
                                                                          WriteValue_DataValue(wvi)) |-> WriteValue_IndexRange(wvi)))
                                                           }(IsValid_VariantIndex(
                                                              DataValue_Variant(
                                                               WriteValue_DataValue(wvi)) |-> WriteValue_IndexRange(wvi)))
                                                 }(bool(e_operation_type_write |-> WriteValue_NodeId(wvi) |-> WriteValue_AttributeId(wvi) |-> p_user : s_AuthorizedOperations))
                                      }(bool(WriteValue_AttributeId(wvi) = e_aid_Value &
                                             a_NodeClass(a_NodeId~(WriteValue_NodeId(wvi))) = e_ncl_Variable & /* writemask not managed => only var/value writable */
                                             conv_AccessLevel_CurrentWrite(a_AccessLevel(a_NodeId~(WriteValue_NodeId(wvi)))) = TRUE))
                           }(bool(WriteValue_NodeId(wvi) : ran(a_NodeId)))
                }(bool(WriteValue_AttributeId(wvi) : t_AttributeId))
            )
        VARIANT
            card(wreqs_to_iterate)
        END
    END
    ;

    dealloc_write_request_responses =
    BEGIN
        ResponseWrite_allocated := FALSE;
        reset_ResponseWrite
    END
    ;

    serviceStatusCode, prev_dataValue <-- treat_write_1(isvalid, status, p_user, nid, aid, dataValue, index_range) =
    VAR
        l_isvalid,
        l_node,
        l_ncl,
        l_access_lvl,
        l_access_write,
        l_authorized_write,
        l_local_treatment
    IN
        prev_dataValue := c_DataValue_indet;
        IF isvalid = TRUE THEN
            l_isvalid, l_node <-- readall_AddressSpace_Node(nid);
            IF l_isvalid = TRUE THEN
                l_ncl <-- get_NodeClass(l_node);
                IF aid = e_aid_Value & l_ncl = e_ncl_Variable THEN
                    l_local_treatment <-- is_local_service_treatment;
                    IF l_local_treatment = TRUE THEN
                        /* No access authorization check for local treatment */
                        serviceStatusCode, prev_dataValue <-- set_Value(p_user, l_node, dataValue, index_range)
                    ELSE
                        l_access_lvl <-- get_AccessLevel(l_node);
                        l_access_write <-- is_t_acces_level_currentWrite(l_access_lvl);
                        IF l_access_write = TRUE THEN
                            /* Write authorization is for set_Value, and read authorization is for get_Value_StatusCode */
                            l_authorized_write <-- get_user_authorization(e_operation_type_write, nid, aid, p_user);
                            IF l_authorized_write = TRUE THEN
                                serviceStatusCode, prev_dataValue <-- set_Value(p_user, l_node, dataValue, index_range)
                            ELSE
                                serviceStatusCode := e_sc_bad_user_access_denied
                            END
                        ELSE
                            serviceStatusCode := e_sc_bad_not_writable
                        END
                    END
                ELSE
                    serviceStatusCode := e_sc_bad_not_writable
                END
            ELSE
                serviceStatusCode := e_sc_bad_node_id_unknown
            END
        ELSE
            serviceStatusCode := status
        END
    END

END
