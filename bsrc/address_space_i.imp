/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    address_space_i

REFINES
    address_space_r

SEES
    constants,
    constants_statuscodes_bs,
    service_write_decode_bs,
    service_mgr_1,
    service_response_cb_bs,
    write_value_pointer_bs,
    data_value_pointer_bs

IMPORTS
    address_space_bs,
    address_space_typing,
    response_write_bs,
    address_space_it,
    gen_subscription_event_bs,
    user_authorization_bs

PROMOTES
    readall_AddressSpace_Node,
    get_NodeClass,
    get_BrowseName,
    get_DisplayName,
    is_transitive_subtype,
    is_NodeId_equal,
    get_TypeDefinition,
    get_Reference_ReferenceType,
    get_Reference_TargetNode,
    get_Reference_IsForward,
    get_Node_RefIndexEnd,
    get_RefIndex_Reference,
    get_Value_StatusCode,
    read_AddressSpace_clear_value,
    read_AddressSpace_free_variant,
    write_WriteResponse_msg_out,
    get_user_authorization

CONCRETE_VARIABLES
    ResponseWrite_allocated

DEFINITIONS
    "definitions.def";

    /* Relation associating to a node a value which is requested to be written
    in the address space */
    d_a_DataValue_requested ==
        (a_NodeClass~[{e_ncl_Variable}]           <| a_NodeId ;
                                                     WriteValue_NodeId~ ;
         (cast_t_WriteValue[1..nb_WriteValue] /\
             WriteValue_AttributeId~[{e_aid_Value}]) <| WriteValue_DataValue);

    d_Type_IsVariableSubtype_NeedConv(dvNodeId, dvConcValueRank, varNodeId, varValueRank) ==
    /* A scalar ByteString is compatible with a 1 dimension Byte array */
    (dvNodeId = c_ByteString_Type_NodeId & dvConcValueRank = -1 &
     varNodeId = c_Byte_Type_NodeId & 1 |-> varValueRank : Type_IsIncludedValueRank)
    or /* A 1 dimension Byte array is compatible with a scalar ByteString */
    (dvNodeId = c_Byte_Type_NodeId & dvConcValueRank = 1 &
     varNodeId = c_ByteString_Type_NodeId & -1 |-> varValueRank : Type_IsIncludedValueRank);

    d_Type_IsVariableSubtype(dvNodeId, dvConcValueRank, varNodeId, varValueRank) ==
    ((dvNodeId = c_Null_Type_NodeId or dvNodeId = varNodeId or dvNodeId |-> varNodeId : Type_IsTransitiveSubtype) &
        dvConcValueRank |-> varValueRank : Type_IsIncludedValueRank)
    /* + Management of exceptional cases when typing a variable */
    or d_Type_IsVariableSubtype_NeedConv(dvNodeId, dvConcValueRank, varNodeId, varValueRank);

    d_Mandatory_Attribute(dvNcl, dvAid) ==
    /* COMMON MANDATORY ATTRIBUTES: all node classes have it */
    (dvAid = e_aid_BrowseName or dvAid = e_aid_DisplayName or
        dvAid = e_aid_NodeClass or dvAid = e_aid_NodeId) or

    (dvNcl = e_ncl_Variable & /* VARIABLE */
        (dvAid = e_aid_AccessLevel or dvAid = e_aid_DataType or
            dvAid = e_aid_Historizing or dvAid = e_aid_UserAccessLevel or
            dvAid = e_aid_Value or dvAid = e_aid_ValueRank)
    ) or
    (dvNcl = e_ncl_VariableType & /* VARIABLE TYPE */
        (dvAid = e_aid_DataType or dvAid = e_aid_IsAbstract or dvAid = e_aid_ValueRank)
    ) or
    (dvNcl = e_ncl_Object & /* OBJECT */
        dvAid = e_aid_EventNotifier
    ) or
    (dvNcl = e_ncl_ObjectType & /* OBJECT TYPE */
        dvAid = e_aid_IsAbstract
    ) or
    (dvNcl = e_ncl_ReferenceType & /* REFERENCE TYPE */
        (dvAid = e_aid_IsAbstract or dvAid = e_aid_Symmetric)
    ) or
    (dvNcl = e_ncl_DataType & /* DATA TYPE */
        dvAid = e_aid_IsAbstract
    ) or
    (dvNcl = e_ncl_Method & /* METHOD */
        dvAid = e_aid_UserExecutable
    ) or
    (dvNcl = e_ncl_View & /* VIEW */
        (dvAid = e_aid_EventNotifier or dvAid = e_aid_ContainsNoLoops))


INITIALISATION
    ResponseWrite_allocated := FALSE

LOCAL_OPERATIONS
    bres <-- is_mandatory_attribute(p_ncl, p_aid) =
    PRE
        p_ncl : t_NodeClass_i &
        p_ncl : t_NodeClass &
        p_aid : t_AttributeId_i &
        p_aid : t_AttributeId
    THEN
        bres := bool(d_Mandatory_Attribute(p_ncl, p_aid))
    END
    ;

    /* Outer treat operation. Validates isvalid, validates user, records the write. */
    serviceStatusCode, prev_dataValue, node <-- treat_write_1(isvalid, status, p_user, nid, aid, dataValue, index_range) =
    PRE
        isvalid : BOOL &
        status : t_StatusCode_i &
        p_user : t_user_i &
        p_user : t_user   &
        nid : t_NodeId_i &
        aid : t_AttributeId_i &
        dataValue : t_DataValue_i &
        (isvalid = TRUE
            =>
         status = e_sc_ok & /* TODO: this is redundant with isvalid = TRUE */
         nid : t_NodeId &
         aid : t_AttributeId &
         dataValue : t_DataValue) &
        (isvalid = FALSE
            =>
         status : {e_sc_bad_attribute_id_invalid, e_sc_bad_index_range_invalid}) &
        a_NodeId : t_Node >-> t_NodeId &
        a_Value : t_Node +-> t_Variant &
        index_range : t_IndexRange_i
    THEN
        serviceStatusCode,
        prev_dataValue,
        node,
        a_Value,
        a_Value_StatusCode,
        a_Value_SourceTimestamp,
        a_Value_ServerTimestamp
        :(
            serviceStatusCode : t_StatusCode_i &
            serviceStatusCode : t_StatusCode &
            prev_dataValue : t_DataValue_i &
            node : t_Node_i &
            a_Value : t_Node +-> t_Variant &
            a_Value_StatusCode : t_Node +-> t_RawStatusCode &
            a_Value_SourceTimestamp : t_Node +-> t_Timestamp &
            a_Value_ServerTimestamp : t_Node +-> t_Timestamp &
             /* TODO: out of memory case */
            (isvalid = TRUE &
             nid : ran(a_NodeId) &
             aid = e_aid_Value &
             a_NodeClass(a_NodeId~(nid)) = e_ncl_Variable &
             d_Type_IsVariableSubtype(DataValue_LocalDataType(dataValue), DataValue_ValueRank(dataValue), a_DataType(a_NodeId~(nid)), a_ValueRank(a_NodeId~(nid))) &
             (local_service_treatment = TRUE
              or
              (conv_AccessLevel_CurrentWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE &
               e_operation_type_write |-> nid |-> aid |-> p_user : s_AuthorizedOperations)
              ) &
              HasRange_VariantIndex(DataValue_Variant(dataValue) |-> index_range) = TRUE &
              IsValid_VariantIndex(DataValue_Variant(dataValue) |-> index_range) = TRUE
             =>
             serviceStatusCode = e_sc_ok &
             prev_dataValue : t_DataValue &
             node = a_NodeId~(nid) &
             DataValue_Variant(prev_dataValue) = a_Value$0(a_NodeId~(nid)) &
             DataValue_StatusCode(prev_dataValue) = a_Value_StatusCode$0(a_NodeId~(nid)) &
             DataValue_SourceTimestamp(prev_dataValue) = a_Value_SourceTimestamp$0(a_NodeId~(nid)) &
             DataValue_ServerTimestamp(prev_dataValue) = a_Value_ServerTimestamp$0(a_NodeId~(nid)) &

             a_Value = a_Value$0 <+ {a_NodeId~(nid) |-> DataValue_Variant(dataValue)} &
             {a_NodeId~(nid)} <<|  a_Value_ServerTimestamp = {a_NodeId~(nid)} <<| a_Value_ServerTimestamp$0 &
             {a_NodeId~(nid)} <|  a_Value_ServerTimestamp : t_Node +-> t_Timestamp & /* New up to date timestamp as server timestamp */

             (conv_AccessLevel_StatusWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE =>
                    a_Value_StatusCode = a_Value_StatusCode$0 <+ {a_NodeId~(nid) |-> DataValue_StatusCode(dataValue)}) &
             (conv_AccessLevel_StatusWrite(a_AccessLevel(a_NodeId~(nid))) = FALSE => a_Value_StatusCode = a_Value_StatusCode$0) &

             (conv_AccessLevel_TimestampWrite (a_AccessLevel(a_NodeId~(nid))) = TRUE =>
                    a_Value_SourceTimestamp = a_Value_SourceTimestamp$0 <+ {a_NodeId~(nid) |-> DataValue_SourceTimestamp(dataValue)}) &
             (conv_AccessLevel_TimestampWrite (a_AccessLevel(a_NodeId~(nid))) = FALSE => a_Value_SourceTimestamp = a_Value_SourceTimestamp$0)) &

            (not(isvalid = TRUE &
                 status : t_StatusCode_i &
                 status : t_StatusCode &
                 nid : ran(a_NodeId) &
                 aid = e_aid_Value &
                 a_NodeClass(a_NodeId~(nid)) = e_ncl_Variable &
                 d_Type_IsVariableSubtype(DataValue_LocalDataType(dataValue), DataValue_ValueRank(dataValue), a_DataType(a_NodeId~(nid)), a_ValueRank(a_NodeId~(nid))) &
                    (local_service_treatment = TRUE
                     or
                     (conv_AccessLevel_CurrentWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE &
                      e_operation_type_write |-> nid |-> aid |-> p_user : s_AuthorizedOperations)
                    )
                )
             =>
             a_Value = a_Value$0 &
             a_Value_StatusCode = a_Value_StatusCode$0 &
             a_Value_SourceTimestamp = a_Value_SourceTimestamp$0 &
             a_Value_ServerTimestamp = a_Value_ServerTimestamp$0 &
             serviceStatusCode :
             {e_sc_bad_out_of_memory, e_sc_bad_attribute_id_invalid, e_sc_bad_index_range_invalid,
                 e_sc_bad_node_id_unknown, e_sc_bad_not_writable, e_sc_bad_type_mismatch,
                 e_sc_bad_user_access_denied, e_sc_bad_index_range_no_data} &
             /* TODO: out of memory case */
             serviceStatusCode =
              {FALSE |-> status,
               TRUE  |-> {FALSE |-> e_sc_bad_node_id_unknown,
                          TRUE  |-> {FALSE |-> e_sc_bad_not_writable,
                                     TRUE  |-> {FALSE |-> e_sc_bad_type_mismatch,
                                                TRUE |-> {TRUE |-> {FALSE |-> e_sc_bad_index_range_invalid,
                                                                    TRUE |-> {FALSE |-> e_sc_bad_index_range_no_data,
                                                                              TRUE |-> e_sc_ok
                                                                             }(HasRange_VariantIndex(DataValue_Variant(dataValue) |-> index_range))
                                                                   }(IsValid_VariantIndex(DataValue_Variant(dataValue) |-> index_range)),
                                                          FALSE |-> {FALSE |-> e_sc_bad_not_writable,
                                                                     TRUE |-> {FALSE |-> e_sc_bad_user_access_denied,
                                                                               TRUE |-> {FALSE |-> e_sc_bad_index_range_invalid,
                                                                                         TRUE |-> {FALSE |-> e_sc_bad_index_range_no_data,
                                                                                                   TRUE |-> e_sc_ok
                                                                                                  }(HasRange_VariantIndex(DataValue_Variant(dataValue) |-> index_range))
                                                                                        }(IsValid_VariantIndex(DataValue_Variant(dataValue) |-> index_range))
                                                                              }(bool(e_operation_type_write |-> nid |-> aid |-> p_user : s_AuthorizedOperations))
                                                                    }(conv_AccessLevel_CurrentWrite(a_AccessLevel(a_NodeId~(nid))))
                                                         }(local_service_treatment)
                                               }(bool(d_Type_IsVariableSubtype
                                                        (DataValue_LocalDataType(dataValue), DataValue_ValueRank(dataValue),
                                                         a_DataType(a_NodeId~(nid)), a_ValueRank(a_NodeId~(nid)))))
                                    }(bool(aid = e_aid_Value & a_NodeClass(a_NodeId~(nid)) = e_ncl_Variable))
                         }(bool(nid : ran(a_NodeId)))
              }(bool(isvalid = TRUE))
            )
        )
    END
    ;

    /* Computes if DataValue has a compatible type or compatible subtype */
    btyp_ok, btyp_need_conv <-- is_variable_compat_type(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr) =
    PRE
        p_dv_typ_nid : t_NodeId_i &
        p_dv_vr : t_ConcreteValueRank &
        p_var_typ_nid : t_NodeId_i &
        p_var_typ_nid : t_NodeId &
        p_var_vr : t_ValueRank
    THEN
        btyp_ok := bool(d_Type_IsVariableSubtype(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr)) ||
        btyp_need_conv := bool(d_Type_IsVariableSubtype_NeedConv(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr))
    END
    ;

    sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Attribute_value(p_user, p_node, p_nid, p_aid, p_index_range) =
    PRE
        p_user : t_user_i &
        p_user : t_user   &
        p_node : t_Node_i &
        p_node : t_Node &
        p_nid : t_NodeId_i &
        p_nid : t_NodeId &
        p_nid = a_NodeId(p_node) &
        p_aid : t_AttributeId_i &
        p_aid : t_AttributeId &
        p_index_range : t_IndexRange_i &
        p_node : dom(AttributeID_Node_Variant(p_aid)) &
        (a_NodeClass(p_node) = e_ncl_Variable & p_aid = e_aid_Value =>
        (local_service_treatment = TRUE or
         (conv_AccessLevel_CurrentRead(a_AccessLevel(p_node)) = TRUE &
          e_operation_type_read |-> a_NodeId(p_node) |-> p_aid |-> p_user : s_AuthorizedOperations)))
    THEN
        sc,
        val,
        val_sc,
        val_ts_src,
        val_ts_srv
        :(sc : t_StatusCode_i &
          sc : t_StatusCode &
          val : t_Variant_i &
          val_sc : t_RawStatusCode &
          val_ts_src : t_Timestamp &
          val_ts_srv : t_Timestamp &
          /* Attribute is Value and IndexRange of Value is invalid */
          (p_aid = e_aid_Value &
           IsValid_VariantIndex(AttributeID_Node_Variant(e_aid_Value)(p_node) |-> p_index_range) = FALSE
           =>
           val = c_Variant_indet &
           sc = e_sc_bad_index_range_invalid
          ) &
          /* Attribute is Value and IndexRange of Value does not contains data */
          (p_aid = e_aid_Value &
           IsValid_VariantIndex(AttributeID_Node_Variant(e_aid_Value)(p_node) |-> p_index_range) = TRUE &
           HasRange_VariantIndex(AttributeID_Node_Variant(e_aid_Value)(p_node) |-> p_index_range) = FALSE
           =>
           val = c_Variant_indet &
           sc = e_sc_bad_index_range_no_data
          ) &
          /* Attribute is not Value or IndexRange of Value is valid and contains data*/
          ((p_aid /= e_aid_Value or
            p_aid = e_aid_Value &
            IsValid_VariantIndex(AttributeID_Node_Variant(e_aid_Value)(p_node) |-> p_index_range) = TRUE &
            HasRange_VariantIndex(AttributeID_Node_Variant(e_aid_Value)(p_node) |-> p_index_range) = TRUE) =>
           sc = e_sc_ok or
           (val = c_Variant_indet &
            sc = e_sc_bad_out_of_memory)
          ) &

          /* In case of success set other output paramaters */
          (sc = e_sc_ok =>
            /* Set Variant value */
            val = AttributeID_Node_Variant(p_aid)(p_node) &
            /* Fill status code and timestamp: Variable Value / NOT Variable Value */
            (a_NodeClass(p_node) = e_ncl_Variable & p_aid = e_aid_Value =>
             val_sc = a_Value_StatusCode(p_node) &
             val_ts_src = a_Value_SourceTimestamp(p_node) &
             val_ts_srv = a_Value_ServerTimestamp(p_node)) &
            (not (a_NodeClass(p_node) = e_ncl_Variable  & p_aid = e_aid_Value)  =>
             val_sc = c_RawStatusCode_Good &
             val_ts_src = c_Timestamp_null &
             val_ts_srv = c_Timestamp_null)
          ) &
          /* In case of failure set other output parameters */
          (not (sc = e_sc_ok) =>
             val = c_Variant_indet &
             val_sc = c_RawStatusCode_BadInvalidState &
             val_ts_src = c_Timestamp_null &
             val_ts_srv = c_Timestamp_null)
        )
    END

OPERATIONS
    /* LOCAL_OPERATIONS */

    /* We only manage mandatory attributes */
    bres <-- is_mandatory_attribute(p_ncl, p_aid) =
    BEGIN
        /* Check attributes present in all node clasess */
        bres := bool(p_aid = e_aid_BrowseName or p_aid = e_aid_DisplayName or
                     p_aid = e_aid_NodeClass or p_aid = e_aid_NodeId);
        IF bres = FALSE THEN
            CASE p_ncl OF
                EITHER e_ncl_Variable THEN /* VARIABLE */
                    bres := bool(p_aid = e_aid_AccessLevel or p_aid = e_aid_DataType or
                        p_aid = e_aid_Historizing or p_aid = e_aid_UserAccessLevel or
                        p_aid = e_aid_Value or p_aid = e_aid_ValueRank)
                OR e_ncl_VariableType THEN /* VARIABLE TYPE */
                    bres := bool(p_aid = e_aid_DataType or p_aid = e_aid_IsAbstract or p_aid = e_aid_ValueRank)
                OR e_ncl_Object THEN /* OBJECT */
                    bres := bool(p_aid = e_aid_EventNotifier)
                OR e_ncl_ObjectType THEN /* OBJECT TYPE */
                    bres := bool(p_aid = e_aid_IsAbstract)
                OR e_ncl_ReferenceType THEN /* REFERENCE TYPE */
                    bres := bool(p_aid = e_aid_IsAbstract or p_aid = e_aid_Symmetric)
                OR e_ncl_DataType THEN /* DATA TYPE */
                    bres := bool(p_aid = e_aid_IsAbstract)
                OR e_ncl_Method THEN /* METHOD */
                    bres := bool(p_aid = e_aid_Executable or p_aid = e_aid_UserExecutable)
                OR e_ncl_View THEN /* VIEW */
                    bres := bool(p_aid = e_aid_EventNotifier or p_aid = e_aid_ContainsNoLoops)
                END
           END
        END
    END
    ;

    serviceStatusCode, prev_dataValue, node <-- treat_write_1(isvalid, status, p_user, nid, aid, dataValue, index_range) =
    VAR
        l_isvalid,
        l_ncl,
        l_access_lvl,
        l_access_write,
        l_access_write_status,
        l_access_write_timestamp,
        l_authorized_write,
        l_compatible_type,
        l_compat_with_conv,
        l_var_datatype_nid,
        l_var_vr,
        l_dv_datatype_nid,
        l_dv_datatype_vr,
        l_local_treatment,
        l_variant,
        l_source_ts,
        l_raw_sc
    IN
        node := c_Node_indet;
        prev_dataValue := c_DataValue_indet;
        IF isvalid = TRUE THEN
            l_isvalid, node <-- readall_AddressSpace_Node(nid);
            IF l_isvalid = TRUE THEN
                l_ncl <-- get_NodeClass(node);
                IF aid = e_aid_Value & l_ncl = e_ncl_Variable THEN
                    l_var_datatype_nid <-- get_DataType(node);
                    l_var_vr <-- get_ValueRank(node);
                    l_dv_datatype_nid <-- get_conv_DataValue_LocalDataType(dataValue);
                    l_dv_datatype_vr <-- get_conv_DataValue_ValueRank(dataValue);
                    l_compatible_type, l_compat_with_conv <-- is_variable_compat_type(l_dv_datatype_nid, l_dv_datatype_vr, l_var_datatype_nid, l_var_vr);
                    IF l_compatible_type = TRUE THEN
                        l_local_treatment <-- is_local_service_treatment;
                        l_variant <-- get_conv_DataValue_Variant(dataValue);
                        l_source_ts <-- get_conv_DataValue_SourceTimestamp(dataValue);
                        l_raw_sc <-- get_conv_DataValue_Status(dataValue);
                        IF l_local_treatment = TRUE THEN
                            /* No access authorization check for local treatment */
                            serviceStatusCode, prev_dataValue <-- set_Value(p_user, node, l_variant, index_range);
                            IF serviceStatusCode = e_sc_ok THEN
                                set_Value_StatusCode(p_user, node, l_raw_sc);
                                set_Value_SourceTimestamp(p_user, node, l_source_ts)
                            END
                        ELSE
                            l_access_lvl <-- get_AccessLevel(node);
                            l_access_write <-- is_t_access_level_currentWrite(l_access_lvl);
                            l_access_write_status <-- is_t_access_level_statusWrite(l_access_lvl);
                            l_access_write_timestamp <-- is_t_access_level_timestampWrite(l_access_lvl);
                            IF l_access_write = TRUE THEN
                                /* Write authorization is for set_Value, and read authorization is for get_Value_StatusCode */
                                l_authorized_write <-- get_user_authorization(e_operation_type_write, nid, aid, p_user);
                                IF l_authorized_write = TRUE THEN
                                    serviceStatusCode, prev_dataValue <-- set_Value(p_user, node, l_variant, index_range);
                                    IF serviceStatusCode = e_sc_ok THEN
                                        IF l_access_write_status = TRUE THEN
                                            set_Value_StatusCode(p_user, node, l_raw_sc)
                                        END;
                                        IF l_access_write_timestamp = TRUE THEN
                                            set_Value_SourceTimestamp(p_user, node, l_source_ts)
                                        END
                                    END
                                ELSE
                                    serviceStatusCode := e_sc_bad_user_access_denied
                                END
                            ELSE
                                serviceStatusCode := e_sc_bad_not_writable
                            END
                        END
                    ELSE
                        serviceStatusCode := e_sc_bad_type_mismatch
                    END
                ELSE
                    serviceStatusCode := e_sc_bad_not_writable
                END
            ELSE
                serviceStatusCode := e_sc_bad_node_id_unknown
            END
        ELSE
            serviceStatusCode := status
        END
    END
    ;

    btyp_ok, btyp_need_conv <-- is_variable_compat_type(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr) =
    VAR
        l_node_ids_eq,
        l_dv_is_null_type,
        l_dv_is_sub_typ,
        l_dv_is_byte_type,
        l_dv_is_bytestring_type,
        l_var_is_byte_type,
        l_var_is_bytestring_type,
        l_var_is_scalar_vr,
        l_var_is_one_dim_vr,
        l_typ_is_ok,
        l_typ_need_conv,
        l_value_rank_is_ok
    IN
        l_typ_is_ok := FALSE;
        l_typ_need_conv := FALSE;
        l_value_rank_is_ok := FALSE;
        IF p_dv_typ_nid /= c_NodeId_indet THEN
            l_node_ids_eq <-- is_NodeId_equal(p_dv_typ_nid, p_var_typ_nid);
            l_dv_is_null_type <-- is_NodeId_equal(p_dv_typ_nid, c_Null_Type_NodeId);
            l_value_rank_is_ok <-- is_included_ValueRank(p_dv_vr, p_var_vr);
            IF l_node_ids_eq = TRUE THEN
                l_typ_is_ok := TRUE
            ELSIF l_dv_is_null_type = TRUE THEN
                l_typ_is_ok := TRUE
            ELSE
                l_dv_is_sub_typ <-- is_transitive_subtype(p_dv_typ_nid, p_var_typ_nid);
                IF l_dv_is_sub_typ = TRUE THEN
                    l_typ_is_ok := TRUE
                ELSE
                    l_dv_is_bytestring_type <-- is_NodeId_equal(p_dv_typ_nid, c_ByteString_Type_NodeId);
                    l_dv_is_byte_type <-- is_NodeId_equal(p_dv_typ_nid, c_Byte_Type_NodeId);
                    l_var_is_bytestring_type <-- is_NodeId_equal(p_var_typ_nid, c_ByteString_Type_NodeId);
                    l_var_is_byte_type <-- is_NodeId_equal(p_var_typ_nid, c_Byte_Type_NodeId);
                    l_var_is_scalar_vr <-- is_included_ValueRank(-1, p_var_vr);
                    l_var_is_one_dim_vr <-- is_included_ValueRank(1, p_var_vr);
                    IF l_dv_is_bytestring_type = TRUE & p_dv_vr = -1 &
                        l_var_is_byte_type = TRUE & l_var_is_one_dim_vr = TRUE
                    THEN
                        /* New DataValue is ByteString and Variable accepts Byte[]: compatiblity with conversion */
                        l_typ_is_ok := TRUE;
                        l_typ_need_conv := TRUE;
                        l_value_rank_is_ok := TRUE
                    ELSIF l_dv_is_byte_type = TRUE & p_dv_vr = 1 &
                        l_var_is_bytestring_type = TRUE & l_var_is_scalar_vr = TRUE
                    THEN
                        /* New DataValue is Byte[] and Variable accepts ByteString: compatiblity with conversion */
                        l_typ_is_ok := TRUE;
                        l_typ_need_conv := TRUE;
                        l_value_rank_is_ok := TRUE
                    END
                END
            END
        END;
        btyp_ok := bool(l_typ_is_ok = TRUE & l_value_rank_is_ok = TRUE);
        btyp_need_conv := l_typ_need_conv
    END
    ;

    sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Attribute_value(p_user, p_node, p_nid, p_aid, p_index_range) =
    VAR
        l_user_read_auth,
        l_user_write_auth
    IN
        sc := e_sc_ok;
        val_sc <-- const_RawStatusCode_Good;
        val := c_Variant_indet;
        val_ts_src := c_Timestamp_null;
        val_ts_srv := c_Timestamp_null;
        CASE p_aid OF
            EITHER e_aid_AccessLevel THEN
                sc, val <-- read_AddressSpace_AccessLevel_value(p_node)
            OR e_aid_BrowseName THEN
                sc, val <-- read_AddressSpace_BrowseName_value(p_node)
            OR e_aid_ContainsNoLoops THEN
                sc, val <-- read_AddressSpace_ContainsNoLoops_value(p_node)
            OR e_aid_DataType THEN
                sc, val <-- read_AddressSpace_DataType_value(p_node)
            OR e_aid_DisplayName THEN
                sc, val <-- read_AddressSpace_DisplayName_value(p_node)
            OR e_aid_EventNotifier THEN
                sc, val <-- read_AddressSpace_EventNotifier_value(p_node)
            OR e_aid_Executable THEN
                sc, val <-- read_AddressSpace_Executable_value(p_node)
            OR e_aid_Historizing THEN
                sc, val <-- read_AddressSpace_Historizing_value(p_node)
            OR e_aid_IsAbstract THEN
                sc, val <-- read_AddressSpace_IsAbstract_value(p_node)
            OR e_aid_NodeClass THEN
                sc, val <-- read_AddressSpace_NodeClass_value(p_node)
            OR e_aid_NodeId THEN
                sc, val <-- read_AddressSpace_NodeId_value(p_node)
            OR e_aid_Symmetric THEN
                sc, val <-- read_AddressSpace_Symmetric_value(p_node)
            OR e_aid_UserAccessLevel THEN
                l_user_read_auth <-- get_user_authorization(e_operation_type_read, p_nid, e_aid_Value, p_user);
                l_user_write_auth <-- get_user_authorization(e_operation_type_write, p_nid, e_aid_Value, p_user);
                sc, val <-- read_AddressSpace_UserAccessLevel_value(p_node, l_user_read_auth, l_user_write_auth)
            OR e_aid_UserExecutable THEN
                sc, val <-- read_AddressSpace_UserExecutable_value(p_node)
            OR e_aid_Value THEN
                sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Value_value(p_node, p_index_range)
            OR e_aid_ValueRank THEN
                sc, val <-- read_AddressSpace_ValueRank_value(p_node)
            END
        END
    END
    ;


    /* END LOCAL_OPERATIONS */

    sc, val, val_sc, val_ts_src, val_ts_srv <-- read_Node_Attribute(p_user, p_node, p_nid, p_aid, p_index_range) =
    VAR
        l_is_mandatory_attribute,
        l_ncl,
        l_is_local_read,
        l_access_lvl,
        l_access_read,
        l_user_auth
    IN
        sc := e_sc_bad_attribute_id_invalid;
        val_sc <-- const_RawStatusCode_BadInvalidState;
        val := c_Variant_indet;
        val_ts_src := c_Timestamp_null;
        val_ts_srv := c_Timestamp_null;
        l_ncl <-- get_NodeClass(p_node);
        l_is_mandatory_attribute <-- is_mandatory_attribute(l_ncl, p_aid);
        IF l_is_mandatory_attribute = TRUE THEN
            IF l_ncl = e_ncl_Variable & p_aid = e_aid_Value THEN
                l_is_local_read <-- is_local_service_treatment;
                IF l_is_local_read = TRUE THEN
                    /* local read service call always authorized */
                    sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Attribute_value(p_user, p_node, p_nid, p_aid, p_index_range)
                ELSE
                    l_access_lvl <-- get_AccessLevel(p_node);
                    l_access_read <-- is_t_access_level_currentRead(l_access_lvl);
                    IF l_access_read = TRUE THEN
                        l_user_auth <-- get_user_authorization(e_operation_type_read, p_nid, p_aid, p_user);
                        IF l_user_auth = TRUE THEN
                            sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Attribute_value(p_user, p_node, p_nid, p_aid, p_index_range)
                        ELSE
                            sc := e_sc_bad_user_access_denied
                        END
                    ELSE
                       sc := e_sc_bad_not_readable
                    END
                END
            ELSE
                /* If not a Variable Value, read is always authorized (no access rights) */
                sc, val, val_sc, val_ts_src, val_ts_srv <-- read_AddressSpace_Attribute_value(p_user, p_node, p_nid, p_aid, p_index_range)
            END
        END
    END
    ;

    /* --------------------------------------------------------------------- */
    /* Service Write */

    bret <-- alloc_write_request_responses(nb_req) =
    BEGIN
        IF nb_req <= k_n_WriteResponse_max THEN
            ResponseWrite_allocated <-- alloc_write_request_responses_malloc(nb_req)
        ELSE
            ResponseWrite_allocated := FALSE
        END;
        bret := ResponseWrite_allocated
    END
    ;

    StatusCode_service <-- treat_write_request_WriteValues (p_user) =
    VAR
        l_nb_req,
        l_continue,
        l_aid,
        l_nid,
        l_dataValue,
        l_index_range,
        l_wvi,
        l_status1,
        l_status2,
        l_prev_dataValue,
        l_node,
        l_access_lvl,
        l_access_read,
        l_isvalid,
        l_local_treatment,
        l_wv,
        l_bres_wv_copy,
        l_wv_copy
    IN
        StatusCode_service := e_sc_ok;
        l_nb_req <-- get_nb_WriteValue;
        l_continue <-- init_iter_write_request(l_nb_req);
        WHILE l_continue = TRUE DO
            l_continue, l_wvi <-- continue_iter_write_request;
            l_isvalid, l_status1, l_nid, l_aid, l_dataValue, l_index_range <-- getall_WriteValue(l_wvi);
            /* Avoids the IFs with a local operation. */
            l_status2, l_prev_dataValue, l_node <-- treat_write_1(l_isvalid, l_status1, p_user, l_nid, l_aid, l_dataValue, l_index_range);
            set_ResponseWrite_StatusCode(l_wvi, l_status2);
            l_wv <-- getall_WriteValuePointer(l_wvi);
            IF l_status2 = e_sc_ok
            THEN
                /* Check access level: read access right <=> data change event for subscription */
                /*
                   Justif: we do not generate data change event since we cannot return notification on non readable value.
                           Moreover the access level is static and then the subscriber has already been notified on M.I. creation.
                */
                l_access_lvl <-- get_AccessLevel(l_node);
                l_access_read <-- is_t_access_level_currentRead(l_access_lvl);
                IF l_access_read = TRUE THEN
                    l_bres_wv_copy, l_wv_copy <-- copy_write_value_pointer_content (l_wv);
                    IF l_bres_wv_copy = TRUE THEN
                        gen_data_changed_event (l_prev_dataValue, l_wv_copy)
                    ELSE
                        gen_data_changed_event_failed (l_prev_dataValue)
                    END
                END
            ELSE
                write_AddressSpace_free_dataValue (l_prev_dataValue)
            END;
            l_local_treatment <-- is_local_service_treatment;
            IF l_local_treatment = FALSE
            THEN
                l_bres_wv_copy, l_wv_copy <-- copy_write_value_pointer_content (l_wv);
                IF l_bres_wv_copy = TRUE THEN
                    srv_write_notification (l_wv_copy, l_status2)
                ELSE
                    /* TODO: Generates an out of memory service result or error trace ? */
                    skip
                END
            END
        INVARIANT
            wreqs_to_iterate <: t_WriteValue &
            wreqs_iterated <: t_WriteValue &
            wreqs_to_iterate /\ wreqs_iterated = {} &
            wreqs_to_iterate \/ wreqs_iterated = cast_t_WriteValue[1..nb_WriteValue] &
            l_continue = bool(wreqs_to_iterate /= {}) &

            a_Value : t_Node +-> t_Variant &

            a_Value <: a_Value$0 <+ (d_a_DataValue_requested;DataValue_Variant) &
            a_Value_StatusCode <: a_Value_StatusCode$0 <+ (d_a_DataValue_requested;DataValue_StatusCode) &
            a_Value_SourceTimestamp <: a_Value_SourceTimestamp$0 <+ (d_a_DataValue_requested;DataValue_SourceTimestamp) &
            a_Value_ServerTimestamp <: a_Value_ServerTimestamp$0 <+ (d_a_DataValue_requested;DataValue_ServerTimestamp) &

            !wvi.(wvi : t_WriteValue & wvi : wreqs_iterated
                => ResponseWrite_StatusCode(wvi) : {e_sc_bad_out_of_memory, e_sc_bad_attribute_id_invalid, e_sc_bad_index_range_invalid,
                    e_sc_bad_node_id_unknown, e_sc_bad_not_writable, e_sc_bad_type_mismatch,
                    e_sc_bad_user_access_denied, e_sc_bad_index_range_no_data})
        VARIANT
            card(wreqs_to_iterate)
        END
    END
    ;

    dealloc_write_request_responses =
    BEGIN
        ResponseWrite_allocated := FALSE;
        reset_ResponseWrite
    END

END
