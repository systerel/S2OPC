/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    address_space_i

REFINES
    address_space_r

SEES
    constants,
    constants_statuscodes_bs,
    service_write_decode_bs,
    service_mgr_1,
    service_response_cb_bs,
    write_value_pointer_bs,
    data_value_pointer_bs

IMPORTS
    address_space_bs,
    address_space_typing,
    response_write_bs,
    address_space_it,
    gen_subscription_event_bs,
    user_authorization_bs

PROMOTES
    readall_AddressSpace_Node,
    get_NodeClass,
    get_BrowseName,
    get_DisplayName,
    is_transitive_subtype,
    is_NodeId_equal,
    get_TypeDefinition,
    get_Reference_ReferenceType,
    get_Reference_TargetNode,
    get_Reference_IsForward,
    get_Node_RefIndexEnd,
    get_RefIndex_Reference,
    get_Value_StatusCode,
    read_AddressSpace_clear_value,
    read_AddressSpace_free_variant,
    write_WriteResponse_msg_out,
    get_user_authorization

CONCRETE_VARIABLES
    ResponseWrite_allocated

DEFINITIONS
    /* Relation associating to a node a value which is requested to be written
    in the address space */
    d_a_DataValue_requested ==
        (a_NodeClass~[{e_ncl_Variable}]           <| a_NodeId ;
                                                     WriteValue_NodeId~ ;
         (cast_t_WriteValue[1..nb_WriteValue] /\
             WriteValue_AttributeId~[{e_aid_Value}]) <| WriteValue_DataValue);

    d_Type_IsVariableSubtype_NeedConv(dvNodeId, dvConcValueRank, varNodeId, varValueRank) ==
    /* A scalar ByteString is compatible with a 1 dimension Byte array */
    (dvNodeId = c_ByteString_Type_NodeId & dvConcValueRank = -1 &
     varNodeId = c_Byte_Type_NodeId & 1 |-> varValueRank : Type_IsIncludedValueRank)
    or /* A 1 dimension Byte array is compatible with a scalar ByteString */
    (dvNodeId = c_Byte_Type_NodeId & dvConcValueRank = 1 &
     varNodeId = c_ByteString_Type_NodeId & -1 |-> varValueRank : Type_IsIncludedValueRank);

    d_Type_IsVariableSubtype(dvNodeId, dvConcValueRank, varNodeId, varValueRank) ==
    ((dvNodeId = c_Null_Type_NodeId or dvNodeId = varNodeId or dvNodeId |-> varNodeId : Type_IsTransitiveSubtype) &
        dvConcValueRank |-> varValueRank : Type_IsIncludedValueRank)
    /* + Management of exceptional cases when typing a variable */
    or d_Type_IsVariableSubtype_NeedConv(dvNodeId, dvConcValueRank, varNodeId, varValueRank)


INITIALISATION
    ResponseWrite_allocated := FALSE

LOCAL_OPERATIONS
    /* Outer treat operation. Validates isvalid, validates user, records the write. */
    serviceStatusCode, prev_dataValue <-- treat_write_1(isvalid, status, p_user, nid, aid, dataValue, index_range) =
    PRE
        isvalid : BOOL &
        status : t_StatusCode_i &
        p_user : t_user_i &
        p_user : t_user   &
        nid : t_NodeId_i &
        aid : t_AttributeId_i &
        dataValue : t_DataValue_i &
        (isvalid = TRUE
            =>
         status = e_sc_ok & /* TODO: this is redundant with isvalid = TRUE */
         nid : t_NodeId &
         aid : t_AttributeId &
         dataValue : t_DataValue) &
        (isvalid = FALSE
            =>
         status : {e_sc_bad_attribute_id_invalid, e_sc_bad_index_range_invalid}) &
        a_NodeId : t_Node >-> t_NodeId &
        a_Value : t_Node +-> t_Variant &
        index_range : t_IndexRange_i
    THEN
        serviceStatusCode,
        prev_dataValue,
        a_Value,
        a_Value_StatusCode,
        a_Value_SourceTimestamp,
        a_Value_ServerTimestamp
        :(
            serviceStatusCode : t_StatusCode_i &
            serviceStatusCode : t_StatusCode &
            prev_dataValue : t_DataValue_i &
            a_Value : t_Node +-> t_Variant &
            a_Value_StatusCode : t_Node +-> t_RawStatusCode &
            a_Value_SourceTimestamp : t_Node +-> t_Timestamp &
            a_Value_ServerTimestamp : t_Node +-> t_Timestamp &

            (isvalid = TRUE &
             nid : ran(a_NodeId) &
             aid = e_aid_Value &
             a_NodeClass(a_NodeId~(nid)) = e_ncl_Variable &
             d_Type_IsVariableSubtype(DataValue_LocalDataType(dataValue), DataValue_ValueRank(dataValue), a_DataType(a_NodeId~(nid)), a_ValueRank(a_NodeId~(nid))) &
             (local_service_treatment = TRUE
              or
              (conv_AccessLevel_CurrentWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE &
               e_operation_type_write |-> nid |-> aid |-> p_user : s_AuthorizedOperations)
             )
             =>
             serviceStatusCode = e_sc_ok &
             prev_dataValue : t_DataValue &
             DataValue_Variant(prev_dataValue) = a_Value$0(a_NodeId~(nid)) &
             a_Value = a_Value$0 <+ {a_NodeId~(nid) |-> DataValue_Variant(dataValue)} &

             (conv_AccessLevel_StatusWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE =>
                    DataValue_StatusCode(prev_dataValue) = a_Value_StatusCode$0(a_NodeId~(nid)) &
                    a_Value_StatusCode = a_Value_StatusCode$0 <+ {a_NodeId~(nid) |-> DataValue_StatusCode(dataValue)}) &
             (conv_AccessLevel_StatusWrite(a_AccessLevel(a_NodeId~(nid))) = FALSE => a_Value_StatusCode = a_Value_StatusCode$0) &

             (conv_AccessLevel_TimestampWrite (a_AccessLevel(a_NodeId~(nid))) = TRUE =>
                    DataValue_SourceTimestamp(prev_dataValue) = a_Value_SourceTimestamp$0(a_NodeId~(nid)) &
                    a_Value_SourceTimestamp = a_Value_SourceTimestamp$0 <+ {a_NodeId~(nid) |-> DataValue_SourceTimestamp(dataValue)}) &
             (conv_AccessLevel_TimestampWrite (a_AccessLevel(a_NodeId~(nid))) = FALSE => a_Value_SourceTimestamp = a_Value_SourceTimestamp$0) &

             DataValue_ServerTimestamp(prev_dataValue) = a_Value_ServerTimestamp$0(a_NodeId~(nid)) &
             a_Value_ServerTimestamp = a_Value_ServerTimestamp$0 <+ {a_NodeId~(nid) |-> DataValue_ServerTimestamp(dataValue)}) &

            /* TODO: detail all status code values regarding error case !*/
            (not(isvalid = TRUE &
                 status : t_StatusCode_i &
                 status : t_StatusCode &
                 nid : ran(a_NodeId) &
                 aid = e_aid_Value &
                 a_NodeClass(a_NodeId~(nid)) = e_ncl_Variable &
                 d_Type_IsVariableSubtype(DataValue_LocalDataType(dataValue), DataValue_ValueRank(dataValue), a_DataType(a_NodeId~(nid)), a_ValueRank(a_NodeId~(nid))) &
                    (local_service_treatment = TRUE
                     or
                     (conv_AccessLevel_CurrentWrite(a_AccessLevel(a_NodeId~(nid))) = TRUE &
                      e_operation_type_write |-> nid |-> aid |-> p_user : s_AuthorizedOperations)
                    )
                )
             =>
             serviceStatusCode :
               {e_sc_bad_internal_error, e_sc_bad_attribute_id_invalid, e_sc_bad_node_id_unknown, e_sc_bad_not_writable, e_sc_bad_user_access_denied, e_sc_bad_index_range_no_data, e_sc_bad_index_range_invalid} &
             a_Value = a_Value$0 &
             a_Value_StatusCode = a_Value_StatusCode$0 &
             a_Value_SourceTimestamp = a_Value_SourceTimestamp$0 &
             a_Value_ServerTimestamp = a_Value_ServerTimestamp$0
            )
        )
    END
    ;

    /* Computes if DataValue has a compatible type or compatible subtype */
    btyp_ok, btyp_need_conv <-- is_variable_compat_type(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr) =
    PRE
        p_dv_typ_nid : t_NodeId_i &
        p_dv_vr : t_ConcreteValueRank &
        p_var_typ_nid : t_NodeId_i &
        p_var_typ_nid : t_NodeId &
        p_var_vr : t_ValueRank
    THEN
        btyp_ok := bool(d_Type_IsVariableSubtype(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr)) ||
        btyp_need_conv := bool(d_Type_IsVariableSubtype_NeedConv(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr))
    END

OPERATIONS
    /* LOCAL_OPERATIONS */

    /* TODO: move treat_write_1 here in a separated commit */

    btyp_ok, btyp_need_conv <-- is_variable_compat_type(p_dv_typ_nid, p_dv_vr, p_var_typ_nid, p_var_vr) =
    VAR
        l_node_ids_eq,
        l_dv_is_null_type,
        l_dv_is_sub_typ,
        l_dv_is_byte_type,
        l_dv_is_bytestring_type,
        l_var_is_byte_type,
        l_var_is_bytestring_type,
        l_var_is_scalar_vr,
        l_var_is_one_dim_vr,
        l_typ_is_ok,
        l_typ_need_conv,
        l_value_rank_is_ok
    IN
        l_typ_is_ok := FALSE;
        l_typ_need_conv := FALSE;
        l_value_rank_is_ok := FALSE;
        IF p_dv_typ_nid /= c_NodeId_indet THEN
            l_node_ids_eq <-- is_NodeId_equal(p_dv_typ_nid, p_var_typ_nid);
            l_dv_is_null_type <-- is_NodeId_equal(p_dv_typ_nid, c_Null_Type_NodeId);
            l_value_rank_is_ok <-- is_included_ValueRank(p_dv_vr, p_var_vr);
            IF l_node_ids_eq = TRUE THEN
                l_typ_is_ok := TRUE
            ELSIF l_dv_is_null_type = TRUE THEN
                l_typ_is_ok := TRUE
            ELSE
                l_dv_is_sub_typ <-- is_transitive_subtype(p_dv_typ_nid, p_var_typ_nid);
                IF l_dv_is_sub_typ = TRUE THEN
                    l_typ_is_ok := TRUE
                ELSE
                    l_dv_is_bytestring_type <-- is_NodeId_equal(p_dv_typ_nid, c_ByteString_Type_NodeId);
                    l_dv_is_byte_type <-- is_NodeId_equal(p_dv_typ_nid, c_Byte_Type_NodeId);
                    l_var_is_bytestring_type <-- is_NodeId_equal(p_var_typ_nid, c_ByteString_Type_NodeId);
                    l_var_is_byte_type <-- is_NodeId_equal(p_var_typ_nid, c_Byte_Type_NodeId);
                    l_var_is_scalar_vr <-- is_included_ValueRank(-1, p_var_vr);
                    l_var_is_one_dim_vr <-- is_included_ValueRank(1, p_var_vr);
                    IF l_dv_is_bytestring_type = TRUE & p_dv_vr = -1 &
                        l_var_is_byte_type = TRUE & l_var_is_one_dim_vr = TRUE
                    THEN
                        /* New DataValue is ByteString and Variable accepts Byte[]: compatiblity with conversion */
                        l_typ_is_ok := TRUE;
                        l_typ_need_conv := TRUE;
                        l_value_rank_is_ok := TRUE
                    ELSIF l_dv_is_byte_type = TRUE & p_dv_vr = 1 &
                        l_var_is_bytestring_type = TRUE & l_var_is_scalar_vr = TRUE
                    THEN
                        /* New DataValue is Byte[] and Variable accepts ByteString: compatiblity with conversion */
                        l_typ_is_ok := TRUE;
                        l_typ_need_conv := TRUE;
                        l_value_rank_is_ok := TRUE
                    END
                END
            END
        END;
        btyp_ok := bool(l_typ_is_ok = TRUE & l_value_rank_is_ok = TRUE);
        btyp_need_conv := l_typ_need_conv
    END
    ;

    /* END LOCAL_OPERATIONS */

    sc, ncl, val <-- read_NodeClass_Attribute(p_user, node, aid, index_range) =
    BEGIN
        ncl <-- get_NodeClass(node);
        sc, val <-- read_AddressSpace_Attribute_value(p_user, node, ncl, aid, index_range)
    END
    ;

    /* --------------------------------------------------------------------- */
    /* Service Write */

    bret <-- alloc_write_request_responses(nb_req) =
    BEGIN
        IF nb_req <= k_n_WriteResponse_max THEN
            ResponseWrite_allocated <-- alloc_write_request_responses_malloc(nb_req)
        ELSE
            ResponseWrite_allocated := FALSE
        END;
        bret := ResponseWrite_allocated
    END
    ;

    StatusCode_service <-- treat_write_request_WriteValues (p_user) =
    VAR
        l_nb_req,
        l_continue,
        l_aid,
        l_nid,
        l_dataValue,
        l_index_range,
        l_wvi,
        l_status1,
        l_status2,
        l_prev_dataValue,
        l_isvalid,
        l_local_treatment,
        l_wv,
        l_bres_wv_copy,
        l_wv_copy
    IN
        StatusCode_service := e_sc_ok;
        l_nb_req <-- get_nb_WriteValue;
        l_continue <-- init_iter_write_request(l_nb_req);
        WHILE l_continue = TRUE DO
            l_continue, l_wvi <-- continue_iter_write_request;
            l_isvalid, l_status1, l_nid, l_aid, l_dataValue, l_index_range <-- getall_WriteValue(l_wvi);
            /* Avoids the IFs with a local operation. */
            l_status2, l_prev_dataValue <-- treat_write_1(l_isvalid, l_status1, p_user, l_nid, l_aid, l_dataValue, l_index_range);
            set_ResponseWrite_StatusCode(l_wvi, l_status2);
            l_wv <-- getall_WriteValuePointer(l_wvi);
            IF l_status2 = e_sc_ok
            THEN
                l_bres_wv_copy, l_wv_copy <-- copy_write_value_pointer_content (l_wv);
                IF l_bres_wv_copy = TRUE THEN
                    gen_data_changed_event (l_prev_dataValue, l_wv_copy)
                ELSE
                    gen_data_changed_event_failed (l_prev_dataValue)
                END
            ELSE
                write_AddressSpace_free_dataValue (l_prev_dataValue)
            END;
            l_local_treatment <-- is_local_service_treatment;
            IF l_local_treatment = FALSE
            THEN
                l_bres_wv_copy, l_wv_copy <-- copy_write_value_pointer_content (l_wv);
                IF l_bres_wv_copy = TRUE THEN
                    srv_write_notification (l_wv_copy, l_status2)
                ELSE
                    /* TODO: Generates an out of memory service result or error trace ? */
                    skip
                END
            END
        INVARIANT
            wreqs_to_iterate <: t_WriteValue &
            wreqs_iterated <: t_WriteValue &
            wreqs_to_iterate /\ wreqs_iterated = {} &
            wreqs_to_iterate \/ wreqs_iterated = cast_t_WriteValue[1..nb_WriteValue] &
            l_continue = bool(wreqs_to_iterate /= {}) &

            a_Value : t_Node +-> t_Variant &

            a_Value <: a_Value$0 <+ (d_a_DataValue_requested;DataValue_Variant) &
            a_Value_StatusCode <: a_Value_StatusCode$0 <+ (d_a_DataValue_requested;DataValue_StatusCode) &
            a_Value_SourceTimestamp <: a_Value_SourceTimestamp$0 <+ (d_a_DataValue_requested;DataValue_SourceTimestamp) &
            a_Value_ServerTimestamp <: a_Value_ServerTimestamp$0 <+ (d_a_DataValue_requested;DataValue_ServerTimestamp) &

            ResponseWrite_StatusCode = %wvi.(
                wvi : t_WriteValue &
                wvi : wreqs_iterated
                |
                {FALSE |-> e_sc_bad_attribute_id_invalid,
                 TRUE  |-> {FALSE |-> e_sc_bad_node_id_unknown,
                            TRUE  |-> {FALSE |-> e_sc_bad_not_writable, /* when attribute is invalid for given node class, should return attribute invalid*/
                                       TRUE  |-> {FALSE |-> e_sc_bad_user_access_denied,
                                                  TRUE |-> {FALSE |-> e_sc_bad_index_range_invalid,
                                                            TRUE |-> {FALSE |-> e_sc_bad_index_range_no_data,
                                                                      TRUE |-> e_sc_ok
                                                                      }(HasRange_VariantIndex(
                                                                         DataValue_Variant(
                                                                          WriteValue_DataValue(wvi)) |-> WriteValue_IndexRange(wvi)))
                                                           }(IsValid_VariantIndex(
                                                              DataValue_Variant(
                                                               WriteValue_DataValue(wvi)) |-> WriteValue_IndexRange(wvi)))
                                                 }(bool(e_operation_type_write |-> WriteValue_NodeId(wvi) |-> WriteValue_AttributeId(wvi) |-> p_user : s_AuthorizedOperations))
                                      }(bool(WriteValue_AttributeId(wvi) = e_aid_Value &
                                             a_NodeClass(a_NodeId~(WriteValue_NodeId(wvi))) = e_ncl_Variable & /* writemask not managed => only var/value writable */
                                             conv_AccessLevel_CurrentWrite(a_AccessLevel(a_NodeId~(WriteValue_NodeId(wvi)))) = TRUE))
                           }(bool(WriteValue_NodeId(wvi) : ran(a_NodeId)))
                }(bool(WriteValue_AttributeId(wvi) : t_AttributeId))
            )
        VARIANT
            card(wreqs_to_iterate)
        END
    END
    ;

    dealloc_write_request_responses =
    BEGIN
        ResponseWrite_allocated := FALSE;
        reset_ResponseWrite
    END
    ;

    serviceStatusCode, prev_dataValue <-- treat_write_1(isvalid, status, p_user, nid, aid, dataValue, index_range) =
    VAR
        l_isvalid,
        l_node,
        l_ncl,
        l_access_lvl,
        l_access_write,
        l_access_write_status,
        l_access_write_timestamp,
        l_authorized_write,
        l_compatible_type,
        l_compat_with_conv,
        l_var_datatype_nid,
        l_var_vr,
        l_dv_datatype_nid,
        l_dv_datatype_vr,
        l_local_treatment,
        l_variant,
        l_source_ts
    IN
        prev_dataValue := c_DataValue_indet;
        IF isvalid = TRUE THEN
            l_isvalid, l_node <-- readall_AddressSpace_Node(nid);
            IF l_isvalid = TRUE THEN
                l_ncl <-- get_NodeClass(l_node);
                IF aid = e_aid_Value & l_ncl = e_ncl_Variable THEN
                    l_var_datatype_nid <-- get_DataType(l_node);
                    l_var_vr <-- get_ValueRank(l_node);
                    l_dv_datatype_nid <-- get_conv_DataValue_LocalDataType(dataValue);
                    l_dv_datatype_vr <-- get_conv_DataValue_ValueRank(dataValue);
                    l_compatible_type, l_compat_with_conv <-- is_variable_compat_type(l_dv_datatype_nid, l_dv_datatype_vr, l_var_datatype_nid, l_var_vr);
                    IF l_compatible_type = TRUE THEN
                        l_local_treatment <-- is_local_service_treatment;
                        l_variant <-- get_conv_DataValue_Variant(dataValue);
                        l_source_ts <-- get_conv_DataValue_SourceTimestamp(dataValue);
                        IF l_local_treatment = TRUE THEN
                            /* No access authorization check for local treatment */
                            serviceStatusCode, prev_dataValue <-- set_Value(p_user, l_node, l_variant, index_range);
                            IF serviceStatusCode = e_sc_ok THEN
                                set_Value_StatusCode(p_user, l_node, dataValue);
                                set_Value_SourceTimestamp(p_user, l_node, l_source_ts)
                            END
                        ELSE
                            l_access_lvl <-- get_AccessLevel(l_node);
                            l_access_write <-- is_t_access_level_currentWrite(l_access_lvl);
                            l_access_write_status <-- is_t_access_level_statusWrite(l_access_lvl);
                            l_access_write_timestamp <-- is_t_access_level_timestampWrite(l_access_lvl);
                            IF l_access_write = TRUE THEN
                                /* Write authorization is for set_Value, and read authorization is for get_Value_StatusCode */
                                l_authorized_write <-- get_user_authorization(e_operation_type_write, nid, aid, p_user);
                                IF l_authorized_write = TRUE THEN
                                    serviceStatusCode, prev_dataValue <-- set_Value(p_user, l_node, l_variant, index_range);
                                    IF serviceStatusCode = e_sc_ok THEN
                                        IF l_access_write_status = TRUE THEN
                                            set_Value_StatusCode(p_user, l_node, dataValue)
                                        END;
                                        IF l_access_write_timestamp = TRUE THEN
                                            set_Value_SourceTimestamp(p_user, l_node, l_source_ts)
                                        END
                                    END
                                ELSE
                                    serviceStatusCode := e_sc_bad_user_access_denied
                                END
                            ELSE
                                serviceStatusCode := e_sc_bad_not_writable
                            END
                        END
                    ELSE
                        serviceStatusCode := e_sc_bad_type_mismatch
                    END
                ELSE
                    serviceStatusCode := e_sc_bad_not_writable
                END
            ELSE
                serviceStatusCode := e_sc_bad_node_id_unknown
            END
        ELSE
            serviceStatusCode := status
        END
    END

END
