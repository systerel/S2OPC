/*
 *  Copyright (C) 2017 Systerel and others.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

IMPLEMENTATION
    service_mgr_i
REFINES
    service_mgr

SEES
    channel_mgr,
    constants

IMPORTS
    message_in_bs,
    message_out_bs,
    session_mgr,
    service_read,
    request_handle_bs,
    service_response_cli_cb_bs,
    address_space,
    service_write_decode_bs,
    service_get_endpoints_bs,
    service_browse_seq

PROMOTES
    /* message_in_bs */
    decode_msg_type,
    is_valid_msg_in_type,
    is_valid_request_context,

    /* message_out_bs */
    is_valid_buffer_out,

    /* session_mgr */
    client_secure_channel_lost_session_sm,
    server_secure_channel_lost_session_sm,
    client_async_activate_new_session_without_channel,
    client_async_activate_new_session_with_channel,
    client_channel_connected_event_session,
    client_close_session

LOCAL_OPERATIONS

    resp_msg_typ <-- get_response_type (req_msg_typ) =
    PRE
        req_msg_typ : t_msg_type_i &
        req_msg_typ : t_msg_type &
        req_msg_typ : s_service_reqs
    THEN
        resp_msg_typ :(resp_msg_typ : t_msg_type_i &
                       resp_msg_typ : t_msg_type &
                       resp_msg_typ : s_service_resps)
    END
    ;

    bres <-- treat_read_request(p_request_msg, p_response_msg) =
    PRE
        p_request_msg  : t_msg_i   &
        p_request_msg  = c_msg_in  &
        p_response_msg : t_msg_i   &
        p_response_msg = c_msg_out
    THEN
        nb_ReadValue,
        ReadValue_NodeId,
        ReadValue_AttributeId,
        data_Value_Value,
        data_Value_StatusCode,
        bres
        :(
          nb_ReadValue          : NAT                           &
          nb_ReadValue         <= k_n_read_resp_max             &
          ReadValue_NodeId      : t_ReadValue +-> t_NodeId      &
          ReadValue_AttributeId : t_ReadValue +-> t_AttributeId &
          data_Value_Value      : t_ReadValue +-> t_Variant     &
          data_Value_StatusCode : t_ReadValue +-> t_StatusCode  &
          bres                  : BOOL
         )
    END
    ;

    /* TODO: call the treat write on an encoded WriteRequest */
    /* TODO: add constraints on userid? */
    StatusCode_service <-- treat_write_request(write_msg) =
    PRE
        write_msg : t_msg_i &
        write_msg = c_msg_in &
        c_msg_in : t_msg &
        a_msg_in_type = e_msg_attribute_write_req
    THEN
        StatusCode_service
        :(  StatusCode_service : t_StatusCode_i &
            StatusCode_service : t_StatusCode
        )
    END

OPERATIONS

    resp_msg_typ <-- get_response_type (req_msg_typ) =
    BEGIN
        resp_msg_typ := c_msg_type_indet;
        CASE req_msg_typ OF
            EITHER e_msg_discovery_find_servers_req THEN
                resp_msg_typ := e_msg_discovery_find_servers_resp
            OR e_msg_discovery_find_servers_on_network_req THEN
                resp_msg_typ := e_msg_discovery_find_servers_on_network_resp
            OR e_msg_discovery_get_endpoints_req THEN
                resp_msg_typ := e_msg_discovery_get_endpoints_resp
            OR e_msg_discovery_register_server_req THEN
                resp_msg_typ := e_msg_discovery_register_server_resp
            OR e_msg_discovery_register_server2_req THEN
                resp_msg_typ := e_msg_discovery_register_server2_resp
            OR e_msg_session_create_req THEN
                resp_msg_typ := e_msg_session_create_resp
            OR e_msg_session_activate_req THEN
                resp_msg_typ := e_msg_session_activate_resp
            OR e_msg_session_close_req THEN
                resp_msg_typ := e_msg_session_close_resp
            OR e_msg_session_cancel_req THEN
                resp_msg_typ := e_msg_session_cancel_resp
            OR e_msg_node_add_nodes_req THEN
                resp_msg_typ := e_msg_node_add_nodes_resp
            OR e_msg_node_add_references_req THEN
                resp_msg_typ := e_msg_node_add_references_resp
            OR e_msg_node_delete_nodes_req THEN
                resp_msg_typ := e_msg_node_delete_nodes_resp
            OR e_msg_node_delete_references_req THEN
                resp_msg_typ := e_msg_node_delete_references_resp
            OR e_msg_view_browse_req THEN
                resp_msg_typ := e_msg_view_browse_resp
            OR e_msg_view_browse_next_req THEN
                resp_msg_typ := e_msg_view_browse_next_resp
            OR e_msg_view_translate_browse_paths_to_node_ids_req THEN
                resp_msg_typ := e_msg_view_translate_browse_paths_to_node_ids_resp
            OR e_msg_view_register_nodes_req THEN
                resp_msg_typ := e_msg_view_register_nodes_resp
            OR e_msg_view_unregister_nodes_req THEN
                resp_msg_typ := e_msg_view_unregister_nodes_resp
            OR e_msg_query_first_req THEN
                resp_msg_typ := e_msg_query_first_resp
            OR e_msg_query_next_req THEN
                resp_msg_typ := e_msg_query_next_resp
            OR e_msg_attribute_read_req THEN
                resp_msg_typ := e_msg_attribute_read_resp
            OR e_msg_attribute_history_read_req THEN
                resp_msg_typ := e_msg_attribute_history_read_resp
            OR e_msg_attribute_write_req THEN
                resp_msg_typ := e_msg_attribute_write_resp
            OR e_msg_attribute_history_update_req THEN
                resp_msg_typ := e_msg_attribute_history_update_resp
            OR e_msg_method_call_req THEN
                resp_msg_typ := e_msg_method_call_resp
            OR e_msg_monitored_items_create_req THEN
                resp_msg_typ := e_msg_monitored_items_create_resp
            OR e_msg_monitored_items_modify_req THEN
                resp_msg_typ := e_msg_monitored_items_modify_resp
            OR e_msg_monitored_items_set_monitoring_mode_req THEN
                resp_msg_typ := e_msg_monitored_items_set_monitoring_mode_resp
            OR e_msg_monitored_items_set_triggering_req THEN
                resp_msg_typ := e_msg_monitored_items_set_triggering_resp
            OR e_msg_monitored_items_delete_req THEN
                resp_msg_typ := e_msg_monitored_items_delete_resp
            OR e_msg_subscription_create_req THEN
                resp_msg_typ := e_msg_subscription_create_resp
            OR e_msg_subscription_modify_req THEN
                resp_msg_typ := e_msg_subscription_modify_resp
            OR e_msg_subscription_set_publishing_mode_req THEN
                resp_msg_typ := e_msg_subscription_set_publishing_mode_resp
            OR e_msg_subscription_publish_req THEN
                resp_msg_typ := e_msg_subscription_publish_resp
            OR e_msg_subscription_republish_req THEN
                resp_msg_typ := e_msg_subscription_republish_resp
            OR e_msg_subscription_transfer_subscriptions_req THEN
                resp_msg_typ := e_msg_subscription_transfer_subscriptions_resp
            OR e_msg_subscription_delete_subscriptions_req THEN
                resp_msg_typ := e_msg_subscription_delete_subscriptions_resp
            END
        END
    END
    ;

    bres <-- treat_read_request(p_request_msg, p_response_msg) =
    VAR
        l_nb_ReadValue,
        l_is_valid
    IN
        l_is_valid, l_nb_ReadValue <-- check_ReadRequest(p_request_msg);
        IF  l_is_valid = TRUE THEN
            l_is_valid <-- alloc_read_response(l_nb_ReadValue, p_response_msg);
            IF  l_is_valid = TRUE THEN
                fill_read_response(p_request_msg, p_response_msg)
            END
        END;
        bres := l_is_valid
    END
    ;

    StatusCode_service <-- treat_write_request(write_msg) =
    VAR
        l_nb_req
    IN
        StatusCode_service <-- decode_write_request(write_msg);
        IF StatusCode_service = e_sc_ok
        THEN
            l_nb_req <-- get_nb_WriteValue;
            StatusCode_service <-- alloc_write_request_responses(l_nb_req);
            IF StatusCode_service = e_sc_ok
            THEN
                StatusCode_service <-- treat_write_request_WriteValues
            END
        END;
        free_write_request
    END
    ;
    /* END OF LOCAL OPERATIONS */

    buffer_out <-- server_receive_session_treatment_req (channel, req_typ, msg_buffer) =
    VAR
        l_req_msg_header,
        l_valid_req_header,
        l_checked_req_header,
        l_req_msg,
        l_valid_req,
        l_request_handle,
        l_valid_req_handle,
        l_session_token,
        l_resp_msg_typ,
        l_resp_msg,
        l_valid_msg,
        l_resp_msg_header,
        l_valid_resp_header,
        l_session,
        l_ret,
        l_buffer_out,
        l_valid_buffer
    IN
        l_buffer_out := c_byte_buffer_indet;
        l_req_msg_header <-- decode_msg_header (TRUE, msg_buffer);
        l_valid_req_header <-- is_valid_msg_in_header (l_req_msg_header);
        IF l_valid_req_header = TRUE
        THEN
            l_request_handle <-- read_msg_header_req_handle (l_req_msg_header);
            l_valid_req_handle <-- is_valid_req_handle (l_request_handle);
            l_session_token <-- read_msg_req_header_session_token (l_req_msg_header);
            /* TODO: check request session token before decoding message */
            IF l_valid_req_handle = TRUE
            THEN
                l_req_msg <-- decode_msg (req_typ, msg_buffer);
                l_valid_req <-- is_valid_msg_in (l_req_msg);
                IF l_valid_req = TRUE
                THEN
                    l_resp_msg_typ <-- get_response_type (req_typ);
                    l_resp_msg_header, l_resp_msg <-- alloc_resp_msg (l_resp_msg_typ);
                    l_valid_msg <-- is_valid_msg_out (l_resp_msg);
                    l_valid_resp_header <-- is_valid_msg_out_header (l_resp_msg_header);
                    IF l_valid_msg = TRUE &
                        l_valid_resp_header = TRUE
                    THEN
                        l_session, l_ret <-- server_receive_session_req (channel, l_session_token, l_req_msg, req_typ, l_resp_msg);
                        IF l_ret /= e_sc_ok
                        THEN
                            /* Part 4 ยง5.3: if the Service itself failed [...] a ServiceFault is returned. */
                            l_resp_msg_typ := e_msg_service_fault_resp
                        END;
                        write_msg_resp_header_service_status (l_resp_msg_header, l_ret);
                        write_msg_out_header_req_handle (l_resp_msg_header, l_request_handle);
                        l_buffer_out <-- encode_msg (l_resp_msg_typ, l_resp_msg_header, l_resp_msg);
                        l_valid_buffer <-- is_valid_buffer_out (l_buffer_out);
                        IF l_valid_buffer = FALSE
                        THEN
                            /* invalid encoding => close session */
                            server_close_session_sm (l_session)
                        END;

                        /* response message structures not necessary anymore */
                        dealloc_msg_header_out (l_resp_msg_header);
                        dealloc_msg_out (l_resp_msg)
                    END;
                    /* request message not necessary anymore */
                    dealloc_msg_in (l_req_msg)
                END /* DECODE REQ CHECK */
            END /* VALID REQ HEADER CHECK */
        END; /* DECODE REQ HEADER CHECK */
        IF l_valid_req_header = TRUE
        THEN
            dealloc_msg_in_header (l_req_msg_header)
        END;
        /* In any case buffer will not be used anymore after this operation */
        dealloc_msg_in_buffer (msg_buffer);
        buffer_out := l_buffer_out
    END
    ;

    client_receive_session_treatment_resp (channel, resp_typ, msg_buffer) =
    VAR
        l_resp_msg_header,
        l_valid_resp_header,
        l_resp_msg,
        l_valid_resp,
        l_request_handle,
        l_validated_req_handle,
        l_session
    IN
        l_resp_msg_header <-- decode_msg_header (FALSE, msg_buffer);
        l_valid_resp_header <-- is_valid_msg_in_header (l_resp_msg_header);
        IF l_valid_resp_header = TRUE
        THEN
            l_request_handle <-- read_msg_header_req_handle (l_resp_msg_header);
            l_validated_req_handle <-- client_validate_response_request_handle (l_request_handle, resp_typ);
            IF l_validated_req_handle = TRUE
            THEN
                l_resp_msg <-- decode_msg (resp_typ, msg_buffer);
                l_valid_resp <-- is_valid_msg_in (l_resp_msg);
                IF l_valid_resp = TRUE
                THEN
                    l_session <-- client_receive_session_resp (channel, l_request_handle, resp_typ, l_resp_msg_header, l_resp_msg);
                    client_remove_req_handle (l_request_handle);
                    /* resp message not used anymore => deallocate */
                    dealloc_msg_in (l_resp_msg)
                END; /* DECODE RESP CHECK */
                client_remove_req_handle (l_request_handle)
            END /* VALID RESP HEADER CHECK */
        END; /* DECODE RESP HEADER CHECK */

        IF l_valid_resp_header = TRUE
        THEN
            /* resp header message not used anymore => deallocate */
            dealloc_msg_in_header (l_resp_msg_header)
        END;

        /* In any case buffer will not be used anymore after this operation */
        dealloc_msg_in_buffer (msg_buffer)
    END
    ;

    buffer_out <-- server_receive_session_service_req (channel, req_typ, msg_buffer) =
    VAR
        l_req_msg_header,
        l_valid_req_header,
        l_request_handle,
        l_valid_req_handle,
        l_session_token,
        l_is_valid_req,
        l_session,
        l_snd_session_err,
        l_req_msg,
        l_valid_req,
        l_resp_msg_typ,
        l_resp_msg,
        l_valid_msg,
        l_resp_msg_header,
        l_valid_resp_header,
        l_ret,
        l_bret,
        l_is_valid_resp,
        l_buffer_out,
        l_valid_buffer,
        l_isvalid_write
    IN
        l_buffer_out := c_byte_buffer_indet;
        l_req_msg_header <-- decode_msg_header (TRUE, msg_buffer);
        l_valid_req_header <-- is_valid_msg_in_header (l_req_msg_header);
        IF l_valid_req_header = TRUE
        THEN
            /* Check request handle */
            l_request_handle <-- read_msg_header_req_handle (l_req_msg_header);
            l_valid_req_handle <-- is_valid_req_handle (l_request_handle);
            IF l_valid_req_handle = TRUE
            THEN
                /* Check valid session token used */
                l_session_token <-- read_msg_req_header_session_token (l_req_msg_header);
                l_is_valid_req, l_session, l_snd_session_err <-- server_validate_session_service_req (channel, l_request_handle, l_session_token);
                IF l_is_valid_req = TRUE
                THEN
                    /* Decode message */
                    l_req_msg <-- decode_msg (req_typ, msg_buffer);
                    l_valid_req <-- is_valid_msg_in (l_req_msg);
                    IF l_valid_req = TRUE
                    THEN
                        /* Allocate response message */
                        l_resp_msg_typ <-- get_response_type (req_typ);
                        l_resp_msg_header, l_resp_msg <-- alloc_resp_msg (l_resp_msg_typ);
                        l_valid_msg <-- is_valid_msg_out (l_resp_msg);
                        l_valid_resp_header <-- is_valid_msg_out_header (l_resp_msg_header);
                        IF l_valid_msg = TRUE &
                            l_valid_resp_header = TRUE
                        THEN
                            CASE req_typ OF
                                EITHER e_msg_attribute_read_req THEN
                                    l_bret <-- treat_read_request (l_req_msg, l_resp_msg);
                                    IF l_bret = TRUE
                                    THEN
                                        l_ret := e_sc_ok
                                    ELSE
                                        l_ret := e_sc_bad_unexpected_error
                                    END
                                OR e_msg_attribute_write_req THEN
                                    // Write request case
                                    l_ret <-- treat_write_request (l_req_msg);
                                    /* TODO: the following may fail (malloc) */
                                    write_WriteResponse_msg_out(l_resp_msg);
                                    dealloc_write_request_responses
                                OR e_msg_view_browse_req THEN
                                    /* TODO: l_req_msg is the decoded struct */
                                    l_ret <-- decode_browse_request(l_req_msg);
                                    IF l_ret = e_sc_ok THEN
                                        l_ret <-- treat_browse_request_BrowseValues;
                                        IF l_ret = e_sc_ok THEN
                                            l_isvalid_write <-- write_BrowseResponse_msg_out(l_resp_msg);
                                            IF l_isvalid_write /= TRUE THEN
                                                l_ret := e_sc_bad_out_of_memory
                                            END
                                        END
                                    END;
                                    free_browse_result
                                ELSE
                                    /* service is not supported */
                                    l_ret := e_sc_bad_service_unsupported
                                END
                            END;
                            write_msg_resp_header_service_status (l_resp_msg_header, l_ret);
                            l_is_valid_resp, l_snd_session_err <-- server_validate_session_service_resp (channel, l_session, l_request_handle);
                            IF l_is_valid_resp = TRUE THEN
                                IF l_ret /= e_sc_ok
                                THEN
                                    /* Part 4 ยง5.3: if the Service itself failed [...] a ServiceFault is returned. */
                                    l_resp_msg_typ := e_msg_service_fault_resp
                                END;
                                write_msg_out_header_req_handle (l_resp_msg_header, l_request_handle);
                                /* Response message encoded */
                                l_buffer_out <-- encode_msg (l_resp_msg_typ, l_resp_msg_header, l_resp_msg)
                            END;
                            /* response message structures not necessary anymore */
                            dealloc_msg_header_out (l_resp_msg_header);
                            dealloc_msg_out (l_resp_msg)
                        END;
                        /* request message not necessary anymore */
                        dealloc_msg_in (l_req_msg)
                    END /* DECODE REQ CHECK */
                END /* VALID SESSION REQ CHECK */
            END /* VALID REQ HEADER CHECK */
        END; /* DECODE REQ HEADER CHECK */
        IF l_valid_req_header = TRUE
        THEN
            dealloc_msg_in_header (l_req_msg_header)
        END;
        /* In any case buffer will not be used anymore after this operation */
        dealloc_msg_in_buffer (msg_buffer);
        buffer_out := l_buffer_out
    END
    ;

    client_receive_session_service_resp (channel, resp_typ, msg_buffer) =
    VAR
        l_resp_msg_header,
        l_valid_resp_header,
        l_request_handle,
        l_validated_req_handle,
        l_is_valid_session_resp,
        l_session,
        l_resp_msg,
        l_valid_resp_msg,
        l_status
    IN
        l_resp_msg_header <-- decode_msg_header (FALSE, msg_buffer);
        l_valid_resp_header <-- is_valid_msg_in_header (l_resp_msg_header);
        IF l_valid_resp_header = TRUE
        THEN
            l_request_handle <-- read_msg_header_req_handle (l_resp_msg_header);
            l_validated_req_handle <-- client_validate_response_request_handle (l_request_handle, resp_typ);
            IF l_validated_req_handle = TRUE
            THEN
                l_is_valid_session_resp, l_session <-- client_validate_session_service_resp (channel, l_request_handle);
                IF l_is_valid_session_resp = TRUE
                THEN
                    l_resp_msg <-- decode_msg (resp_typ, msg_buffer);
                    l_valid_resp_msg <-- is_valid_msg_in (l_resp_msg);
                    IF l_valid_resp_msg = TRUE
                    THEN
                        l_status <-- read_msg_resp_header_service_status (l_resp_msg_header);
                        cli_service_response (l_session, l_resp_msg, l_status)
                    END /* DECODE RESP CHECK */
                END; /* VALID REQ HANDLE ASSOCIATED TO A VALID SESSION */
                client_remove_req_handle (l_request_handle)
            END; /* VALID REQ HANDLE */
            dealloc_msg_in_header (l_resp_msg_header)
        END; /* DECODE RESP HEADER CHECK */
        /* For services on session IN response messages will be provided to applicative

        TODOnow: unreference header/msg as current header/msg IN */
        /* In any case buffer will not be used anymore after this operation */
        dealloc_msg_in_buffer (msg_buffer)
    END
    ;

    buffer_out <-- server_receive_discovery_service_req (channel, req_typ, msg_buffer) =
    VAR
        l_req_msg_header,
        l_valid_req_header,
        l_request_handle,
        l_valid_req_handle,
        l_session_token,
        l_is_valid_req,
        l_session,
        l_snd_session_err,
        l_req_msg,
        l_valid_req,
        l_resp_msg_typ,
        l_resp_msg,
        l_valid_msg,
        l_resp_msg_header,
        l_valid_resp_header,
        l_session_user,
        l_ret,
        l_is_valid_resp,
        l_buffer_out,
        l_valid_buffer,
        l_endpoint_config_idx
    IN
        l_buffer_out := c_byte_buffer_indet;
        l_req_msg_header <-- decode_msg_header (TRUE, msg_buffer);
        l_valid_req_header <-- is_valid_msg_in_header (l_req_msg_header);
        IF l_valid_req_header = TRUE
        THEN
            /* Check request handle */
            l_request_handle <-- read_msg_header_req_handle (l_req_msg_header);
            l_valid_req_handle <-- is_valid_req_handle (l_request_handle);
            IF l_valid_req_handle = TRUE
            THEN
                /* Decode message */
                l_req_msg <-- decode_msg (req_typ, msg_buffer);
                l_valid_req <-- is_valid_msg_in (l_req_msg);
                IF l_valid_req = TRUE
                THEN
                    /* Allocate response */
                    l_resp_msg_typ <-- get_response_type (req_typ);
                    l_resp_msg_header, l_resp_msg <-- alloc_resp_msg (l_resp_msg_typ);
                    l_valid_msg <-- is_valid_msg_out (l_resp_msg);
                    l_valid_resp_header <-- is_valid_msg_out_header (l_resp_msg_header);
                    IF l_valid_msg = TRUE &
                        l_valid_resp_header = TRUE
                    THEN
                        CASE req_typ OF
                            EITHER e_msg_discovery_get_endpoints_req THEN
                                l_endpoint_config_idx <-- server_get_endpoint_config (channel);
                                l_ret <-- treat_get_endpoints_request (l_req_msg, l_resp_msg, l_endpoint_config_idx);
                                /* TODO: set a returned status code result from read request */
                                l_ret := e_sc_ok
                            ELSE
                                /* Cases shall cover all session services req types */
                                l_ret := e_sc_bad_service_unsupported
                            END
                        END;
                        write_msg_resp_header_service_status (l_resp_msg_header, l_ret);
                        IF l_ret /= e_sc_ok
                        THEN
                            /* Part 4 ยง5.3: if the Service itself failed [...] a ServiceFault is returned. */
                            l_resp_msg_typ := e_msg_service_fault_resp
                        END;
                        write_msg_out_header_req_handle (l_resp_msg_header, l_request_handle);

                        /* Response message encoded */
                        l_buffer_out <-- encode_msg (l_resp_msg_typ, l_resp_msg_header, l_resp_msg);

                        /* response message structures not necessary anymore */
                        dealloc_msg_header_out (l_resp_msg_header);
                        dealloc_msg_out (l_resp_msg)
                    END;
                    /* request message not necessary anymore */
                    dealloc_msg_in (l_req_msg)
                END /* DECODE REQ CHECK */
            END /* VALID REQ HEADER CHECK */
        END; /* DECODE REQ HEADER CHECK */
        IF l_valid_req_header = TRUE
        THEN
            dealloc_msg_in_header (l_req_msg_header)
        END;
        /* In any case buffer will not be used anymore after this operation */
        dealloc_msg_in_buffer (msg_buffer);
        buffer_out := l_buffer_out
    END
    ;

    client_receive_discovery_service_resp (resp_typ, msg_buffer) =
    VAR
        l_resp_msg_header,
        l_valid_resp_header,
        l_request_handle,
        l_validated_req_handle,
        l_is_valid_session_resp,
        l_session,
        l_resp_msg,
        l_valid_resp_msg,
        l_status
    IN
        l_resp_msg_header <-- decode_msg_header (FALSE, msg_buffer);
        l_valid_resp_header <-- is_valid_msg_in_header (l_resp_msg_header);
        IF l_valid_resp_header = TRUE
        THEN
            l_request_handle <-- read_msg_header_req_handle (l_resp_msg_header);
            l_validated_req_handle <-- client_validate_response_request_handle (l_request_handle, resp_typ);
            IF l_validated_req_handle = TRUE
            THEN
                l_resp_msg <-- decode_msg (resp_typ, msg_buffer);
                l_valid_resp_msg <-- is_valid_msg_in (l_resp_msg);
                IF l_valid_resp_msg = TRUE
                THEN
                    l_status <-- read_msg_resp_header_service_status (l_resp_msg_header);
                    cli_service_response (c_session_indet, l_resp_msg, l_status)
                END; /* DECODE RESP CHECK */
                client_remove_req_handle (l_request_handle)
            END; /* VALID REQ HANDLE */
            dealloc_msg_in_header (l_resp_msg_header)
        END; /* DECODE RESP HEADER CHECK */
        /* For services on session IN response messages will be provided to applicative
        TODO: unreference header/msg as current header/msg IN */
        skip;
        /* In any case buffer will not be used anymore after this operation */
        dealloc_msg_in_buffer (msg_buffer)
    END
    ;

    /* CLIENT APP EVENTS (or internally generated events for async activation) */

    buffer_out <-- client_service_create_session (session, channel) =
    VAR
        l_msg_header,
        l_valid_msg_header,
        l_req_msg,
        l_req_handle,
        l_valid_req_handle,
        l_valid_msg,
        l_valid_session,
        l_buffer,
        l_valid_buffer,
        l_ret
    IN
        l_buffer := c_byte_buffer_indet;
        l_msg_header, l_req_msg <-- alloc_req_msg (e_msg_session_create_req);
        l_valid_msg <-- is_valid_msg_out (l_req_msg);
        l_valid_msg_header <-- is_valid_msg_out_header (l_msg_header);
        IF l_valid_msg_header = TRUE &
            l_valid_msg = TRUE
        THEN
            l_req_handle <-- client_fresh_req_handle (e_msg_session_create_resp);
            l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
            IF l_valid_req_handle  = TRUE
            THEN
                l_ret <-- client_create_session_req (session, channel, l_req_handle, l_req_msg);
                IF l_ret = e_sc_ok
                THEN
                    write_msg_out_header_req_handle (l_msg_header, l_req_handle);
                    l_buffer <-- encode_msg (e_msg_session_create_req, l_msg_header, l_req_msg);
                    l_valid_buffer <-- is_valid_buffer_out (l_buffer);
                    IF l_valid_buffer = FALSE
                    THEN
                        /* Close session if impossible to create session */
                        client_remove_req_handle (l_req_handle);
                        client_close_session (session)
                    END
                ELSE
                    client_remove_req_handle (l_req_handle);
                    client_close_session (session)
                END
            ELSE
                client_close_session (session)
            END;
            dealloc_msg_header_out (l_msg_header);
            dealloc_msg_out (l_req_msg)
        END;
        buffer_out := l_buffer
    END
    ;

    buffer_out <-- client_service_activate_orphaned_session (session, channel) =
    VAR
        l_msg_header,
        l_req_msg,
        l_valid_msg,
        l_valid_msg_header,
        l_req_handle,
        l_valid_req_handle,
        l_ret,
        l_session_token,
        l_buffer,
        l_valid_buffer
    IN
        l_buffer := c_byte_buffer_indet;
        l_msg_header, l_req_msg <-- alloc_req_msg (e_msg_session_activate_req);
        l_valid_msg <-- is_valid_msg_out (l_req_msg);
        l_valid_msg_header <-- is_valid_msg_out_header (l_msg_header);
        IF l_valid_msg = TRUE &
            l_valid_msg_header = TRUE
        THEN
            l_req_handle <-- client_fresh_req_handle (e_msg_session_activate_resp);
            l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
            IF l_valid_req_handle = TRUE
            THEN
                l_ret, l_session_token <-- client_sc_activate_session_req (session, l_req_handle, channel, l_req_msg);
                IF l_ret = e_sc_ok
                THEN
                    write_msg_out_header_req_handle(l_msg_header, l_req_handle);
                    write_msg_out_header_session_token(l_msg_header, l_session_token);
                    l_buffer <-- encode_msg (e_msg_session_activate_req, l_msg_header, l_req_msg);
                    l_valid_buffer <-- is_valid_buffer_out (l_buffer);
                    IF l_valid_buffer = FALSE
                    THEN
                        /* If reactivation encoding failed, close the session */
                        client_remove_req_handle (l_req_handle);
                        client_close_session (session)
                    END
                END
            END;
            dealloc_msg_header_out (l_msg_header);
            dealloc_msg_out (l_req_msg)
        END;
        buffer_out := l_buffer
    END
    ;

    ret, channel, buffer_out <-- client_service_activate_session (session, user) =
    VAR
        l_msg_header,
        l_valid_msg_header,
        l_req_msg,
        l_valid_msg,
        l_ret,
        l_channel,
        l_req_handle,
        l_valid_req_handle,
        l_session_token,
        l_buffer,
        l_valid_buffer
    IN
        l_channel := c_channel_indet;
        l_buffer := c_byte_buffer_indet;
        l_msg_header, l_req_msg <-- alloc_req_msg (e_msg_session_activate_req);
        l_valid_msg <-- is_valid_msg_out (l_req_msg);
        l_valid_msg_header <-- is_valid_msg_out_header (l_msg_header);
        IF l_valid_msg = TRUE &
            l_valid_msg_header = TRUE
        THEN
            l_req_handle <-- client_fresh_req_handle (e_msg_session_activate_resp);
            l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
            IF l_valid_req_handle = TRUE
            THEN
                l_ret, l_channel, l_session_token <-- client_user_activate_session_req (session, l_req_handle, user, l_req_msg);
                IF l_ret = e_sc_ok
                THEN
                    write_msg_out_header_req_handle(l_msg_header, l_req_handle);
                    write_msg_out_header_session_token(l_msg_header, l_session_token);
                    l_buffer <-- encode_msg (e_msg_session_activate_req, l_msg_header, l_req_msg);
                    l_valid_buffer <-- is_valid_buffer_out (l_buffer);
                    IF l_valid_buffer = FALSE
                    THEN
                        client_remove_req_handle (l_req_handle);
                        l_ret := e_sc_bad_encoding_error;
                        l_channel := c_channel_indet;
                        /* TODO: do not close session in case of failure ?
                         => in this case specific event to be trigger for activate new user failure */
                        client_close_session (session)
                    END
                END
            ELSE
                l_ret := e_sc_bad_out_of_memory
            END;
            dealloc_msg_header_out (l_msg_header);
            dealloc_msg_out (l_req_msg)
        ELSE
            l_ret := e_sc_bad_out_of_memory
        END;
        ret := l_ret;
        channel := l_channel;
        buffer_out := l_buffer
    END
    ;

    ret, channel, buffer_out <-- client_service_close_session (session) =
    VAR
        l_msg_header,
        l_valid_msg_header,
        l_req_msg,
        l_valid_msg,
        l_channel,
        l_req_handle,
        l_valid_req_handle,
        l_session_token,
        l_buffer,
        l_valid_buffer
    IN
        l_channel := c_channel_indet;
        l_buffer := c_byte_buffer_indet;
        l_msg_header, l_req_msg <-- alloc_req_msg (e_msg_session_close_req);
        l_valid_msg <-- is_valid_msg_out (l_req_msg);
        l_valid_msg_header <-- is_valid_msg_out_header (l_msg_header);
        IF l_valid_msg = TRUE &
            l_valid_msg_header = TRUE
        THEN
            l_req_handle <-- client_fresh_req_handle (e_msg_session_close_resp);
            l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
            IF l_valid_req_handle = TRUE
            THEN

                ret, l_channel, l_session_token <-- client_close_session_req (session, l_req_handle, l_req_msg);
                IF ret = e_sc_ok
                THEN
                    write_msg_out_header_req_handle(l_msg_header, l_req_handle);
                    write_msg_out_header_session_token(l_msg_header, l_session_token);
                    l_buffer <-- encode_msg (e_msg_session_close_req, l_msg_header, l_req_msg);
                    l_valid_buffer <-- is_valid_buffer_out (l_buffer);
                    IF l_valid_buffer = FALSE
                    THEN
                        l_channel := c_channel_indet;
                        ret := e_sc_bad_encoding_error;
                        client_remove_req_handle (l_req_handle);
                        client_close_session (session)
                    END
                END
            ELSE
                ret := e_sc_bad_out_of_memory
            END;
            dealloc_msg_header_out (l_msg_header);
            dealloc_msg_out (l_req_msg)
        ELSE
            ret := e_sc_bad_out_of_memory
        END;
        channel := l_channel;
        buffer_out := l_buffer
    END
    ;

    ret, channel, buffer_out <-- client_service_request (session, req_msg) =
    VAR
        l_msg_header,
        l_valid_msg_header,
        l_req_typ,
        l_resp_typ,
        l_valid_msg,
        l_channel,
        l_req_handle,
        l_valid_req_handle,
        l_session_token,
        l_buffer,
        l_valid_buffer
    IN
        l_channel := c_channel_indet;
        l_buffer := c_byte_buffer_indet;
        l_valid_msg <-- is_valid_msg_out (req_msg);
        IF l_valid_msg = TRUE
        THEN
            l_req_typ <-- get_msg_in_type (req_msg);
            CASE l_req_typ OF
                EITHER e_msg_attribute_read_req,
                       e_msg_attribute_write_req,
                       e_msg_view_browse_req
                THEN
                    l_resp_typ <-- get_response_type (l_req_typ);
                    l_msg_header <-- alloc_app_req_msg_header;
                    l_valid_msg_header <-- is_valid_msg_out_header (l_msg_header);
                    l_req_handle <-- client_fresh_req_handle (l_resp_typ);
                    l_valid_req_handle <-- is_valid_req_handle (l_req_handle);
                    IF l_valid_req_handle = TRUE &
                        l_valid_msg_header = TRUE
                    THEN
                        bless_msg_out (l_req_typ, l_msg_header, req_msg);
                        ret, l_channel, l_session_token <-- client_validate_session_service_req (session, l_req_handle);
                        IF ret = e_sc_ok
                        THEN
                            write_msg_out_header_req_handle (l_msg_header, l_req_handle);
                            write_msg_out_header_session_token (l_msg_header, l_session_token);
                            l_buffer <-- encode_msg (e_msg_session_close_req, l_msg_header, req_msg);
                            l_valid_buffer <-- is_valid_buffer_out (l_buffer);
                            IF l_valid_buffer = FALSE
                            THEN
                                ret := e_sc_bad_encoding_error;
                                l_channel := c_channel_indet
                            END
                        END
                    ELSE
                        ret := e_sc_bad_out_of_memory
                    END;
                    IF l_valid_msg_header = TRUE
                    THEN
                        dealloc_msg_header_out (l_msg_header)
                    END;
                    dealloc_msg_out (req_msg)
                ELSE
                    ret := e_sc_bad_invalid_argument
                END
            END
        ELSE
            ret := e_sc_bad_invalid_argument
        END;
        channel := l_channel;
        buffer_out := l_buffer
    END

END
