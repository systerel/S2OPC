/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    service_browse_seq_i

REFINES
    service_browse_seq

SEES
    constants,
    constants_statuscodes_bs,
    address_space,
    message_in_bs

IMPORTS
    service_browse,
    service_browse_seq_it,
    service_browse_decode_bs

PROMOTES
    decode_browse_request,
    free_browse_request,
    write_BrowseResponse_msg_out,
    free_browse_result

LOCAL_OPERATIONS

    p_continue_bri <-- fill_browse_response_ref(p_bvi, p_ref, p_dir,
                                                p_isreftype, p_ref_type, p_inc_subtype) =
    PRE
        p_bvi         : t_BrowseValue_i     &
        p_bvi         : t_BrowseValue       &
        p_ref         : t_Reference_i       &
        p_ref         : t_Reference         &
        p_dir         : t_BrowseDirection_i &
        p_dir         : t_BrowseDirection   &
        p_isreftype   : BOOL                &
        p_ref_type    : t_NodeId_i          &
        p_ref_type    : t_NodeId            &
        p_inc_subtype : BOOL
    THEN
        p_continue_bri :: BOOL
    END
    ;

    fill_browse_response(p_bvi, p_nb_bri, p_src_node, p_dir, p_isreftype, p_reftype, p_inc_subtype) =
    PRE
        p_bvi         : t_BrowseValue_i     &
        p_bvi         : t_BrowseValue       &
        p_nb_bri      : NAT                 &
        p_src_node    : t_Node_i            &
        p_src_node    : t_Node              &
        p_dir         : t_BrowseDirection_i &
        p_dir         : t_BrowseDirection   &
        p_isreftype   : BOOL                &
        p_reftype     : t_NodeId_i          &
        p_inc_subtype : BOOL
    THEN
        skip
    END
    ;

    treat_browse_request_BrowseValue_1(p_bvi, p_nb_target_max) =
    PRE
        p_bvi           : t_BrowseValue_i &
        p_bvi           : t_BrowseValue   &
        p_nb_target_max : NAT
    THEN
        skip
    END


OPERATIONS

    /* When the target node fulfills all the filtering conditions, then fill its data and iterate
       on the browse result index.
       p_bvi          : browse value index of the starting node
       p_ref          : reference
       p_dir          : direction(s) of references to filter
       p_isreftype    : indicates whether the reference type should be filtered. The following 2
                        parameters are meaningfull only when this one is true
       p_reftype      : reference type to filter
       p_inc_subtype  : indicates whether subtypes should be filtered. Else only the given reference
                        type is filtered
       p_continue_bri : indicates whether the iteration should continue (it should stop if the
                        maximum number of browse response index has just been filled)
    */
    p_continue_bri <-- fill_browse_response_ref(p_bvi, p_ref, p_dir,
                                                p_isreftype, p_ref_type, p_inc_subtype) =
    VAR
        l_RefType,
        l_TargetNode,
        l_IsForward,
        l_res,
        l_bri
    IN
        p_continue_bri := TRUE;
        l_RefType    <-- get_Reference_ReferenceType(p_ref);
        l_TargetNode <-- get_Reference_TargetNode(p_ref);
        l_IsForward  <-- get_Reference_IsForward(p_ref);
        l_res        <-- get_Is_Dir_Forward_Compatible(p_dir, l_IsForward);
        IF  l_res = TRUE THEN
            l_res <-- Is_RefTypes_Compatible(p_isreftype, p_ref_type, p_inc_subtype, l_RefType);
            IF  l_res = TRUE THEN
                p_continue_bri, l_bri <-- continue_iter_browse_result;
                l_res <-- copy_target_node_browse_result(p_bvi, l_bri, l_RefType, l_TargetNode, l_IsForward);
                IF  l_res = FALSE THEN
                    skip /* TODO report the malloc failure that occured during the copy */
                END
            END
        END
    END
    ;

    /* Fills the part of the response to a browse request message on one given source node.
       Iterates on each reference
       p_bvi         : browse value index of the starting node
       p_nb_bri      : maximum number of target nodes
       p_src_node    : source node from which refences should start
       p_dir         : direction(s) of references to filter
       p_isreftype   : indicates whether the reference type should be filtered. The following 2
                       parameters are meaningfull only when this one is true
       p_reftype     : reference type to filter
       p_inc_subtype : indicates whether subtypes should be filtered. Else only the given reference
                       type is filtered
    */
    fill_browse_response(p_bvi, p_nb_bri, p_src_node, p_dir, p_isreftype, p_reftype, p_inc_subtype) =
    VAR
        l_continue_bri,
        l_continue_ref,
        l_ref
    IN
        l_ref := c_Reference_indet;
        /* Initialization of the iteration on the browse result */
        l_continue_bri <-- init_iter_browse_result(p_nb_bri);
        IF  l_continue_bri = TRUE THEN
            l_continue_bri := TRUE;

            /* Loop on the references starting from the source node */
            l_continue_ref <-- init_iter_reference(p_src_node);
            WHILE
                l_continue_ref = TRUE &
                l_continue_bri = TRUE
            DO
                l_continue_ref, l_ref <-- continue_iter_reference;
                /* When the target node fulfills all the filtering conditions, then
                   fill its data and iterate on the browse result index */
                l_continue_bri <-- fill_browse_response_ref(p_bvi, l_ref, p_dir,
                                                            p_isreftype, p_reftype, p_inc_subtype)
            INVARIANT
                0=0
            VARIANT
                0
            END;
            IF l_ref /= c_Reference_indet THEN
                /* TODO: There may need more information */
                fill_continuation_point(p_bvi, l_continue_ref, l_ref)
            END
        END
    END
    ;

    /* Computes the part of the response to a browse request message on one given source node.
       Computes the maximum number of target nodes, allocate the memory to store them and fill
       the requested data.
       p_bvi           : browse value index of the starting node
       p_nb_target_max : limit number of target nodes in the browse response set by the client.
                         0 means no limit
    */
    treat_browse_request_BrowseValue_1(p_bvi, p_nb_target_max) =
    VAR
        l_isvalid,
        l_SrcNodeId,
        l_dir,
        l_isreftype,
        l_reftype,
        l_incsubtyp,
        l_nb_target,
        l_src_node,
        l_nb_bri
    IN
        l_SrcNodeId, l_dir, l_isreftype, l_reftype, l_incsubtyp <-- getall_BrowseValue(p_bvi);
        IF l_dir /= e_bd_indet THEN
            l_isvalid, l_nb_target, l_src_node <-- getall_SourceNode_NbRef(l_SrcNodeId);
            IF  l_isvalid = TRUE THEN
                l_isvalid, l_nb_bri <-- alloc_browse_result(p_bvi, p_nb_target_max, l_nb_target);
                IF  l_isvalid = TRUE THEN
                    set_ResponseBrowse_BrowseStatus(p_bvi, e_sc_ok);
                    fill_browse_response(p_bvi, l_nb_bri, l_src_node, l_dir, l_isreftype, l_reftype, l_incsubtyp)
                ELSE
                    set_ResponseBrowse_BrowseStatus(p_bvi, e_sc_bad_out_of_memory)
                END
            ELSE
                set_ResponseBrowse_BrowseStatus(p_bvi, e_sc_bad_node_id_unknown)
            END
        ELSE
            set_ResponseBrowse_BrowseStatus(p_bvi, e_sc_bad_browse_direction_invalid)
        END
    END
    ;

    /* Computes a browse request message by looping on each source node found in the browse request.
    */
    StatusCode_service <-- treat_browse_request_BrowseValues =
    VAR
        l_nid_view,
        l_nb_target_max,
        l_nb_bvi,
        l_continue,
        l_bvi,
        l_isallocated
    IN
        l_nid_view <-- get_BrowseView;
        /* When view is not c_NodeId_indet, we fail, because we don't support Views at all. */
        IF l_nid_view = c_NodeId_indet THEN
            l_nb_target_max <-- get_nb_BrowseTargetMax;
            l_nb_bvi <-- get_nb_BrowseValue;
            IF l_nb_bvi > 0 THEN
                l_isallocated <-- alloc_browse_response(l_nb_bvi);
                IF l_isallocated = TRUE THEN
                    StatusCode_service := e_sc_ok;
                    l_continue <-- init_iter_browse_request(l_nb_bvi);
                    WHILE l_continue = TRUE DO
                        l_continue, l_bvi <-- continue_iter_browse_request;
                        treat_browse_request_BrowseValue_1(l_bvi, l_nb_target_max)
                    INVARIANT
                        0=0
                    VARIANT
                        0
                    END
                ELSE
                    StatusCode_service := e_sc_bad_out_of_memory
                END
            ELSE
                StatusCode_service := e_sc_bad_nothing_to_do
            END
        ELSE
            StatusCode_service := e_sc_bad_view_id_unknown
        END
    END

END
