#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Licensed to Systerel under one or more contributor license
# agreements. See the NOTICE file distributed with this work
# for additional information regarding copyright ownership.
# Systerel licenses this file to you under the Apache
# License, Version 2.0 (the "License"); you may not use this
# file except in compliance with the License. You may obtain
# a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.


import argparse
import base64
import sys
import uuid
from xml.etree.ElementTree import iterparse, Element

UA_NODESET_NS = '{http://opcfoundation.org/UA/2011/03/UANodeSet.xsd}'
UA_NODESET_TAG = UA_NODESET_NS + 'UANodeSet'
UA_ALIASES_TAG = UA_NODESET_NS + 'Aliases'
UA_ALIAS_TAG = UA_NODESET_NS + 'Alias'
UA_VIEW_TAG = UA_NODESET_NS + 'UAView'
UA_OBJECT_TAG = UA_NODESET_NS + 'UAObject'
UA_VARIABLE_TAG = UA_NODESET_NS + 'UAVariable'
UA_VARIABLE_TYPE_TAG = UA_NODESET_NS + 'UAVariableType'
UA_OBJECT_TYPE_TAG = UA_NODESET_NS + 'UAObjectType'
UA_REFERENCE_TYPE_TAG = UA_NODESET_NS + 'UAReferenceType'
UA_DATA_TYPE_TAG = UA_NODESET_NS + 'UADataType'
UA_METHOD_TAG = UA_NODESET_NS + 'UAMethod'
UA_DESCRIPTION_TAG = UA_NODESET_NS + 'Description'
UA_DISPLAY_NAME_TAG = UA_NODESET_NS + 'DisplayName'
UA_REFERENCES_TAG = UA_NODESET_NS + 'References'
UA_REFERENCE_TAG = UA_NODESET_NS + 'Reference'
UA_VALUE_TAG = UA_NODESET_NS + 'Value'

ID_TYPE_NUMERIC = 0
ID_TYPE_STRING = 1
ID_TYPE_GUID = 2
ID_TYPE_BYTESTRING = 3

UA_TYPES_NS = '{http://opcfoundation.org/UA/2008/02/Types.xsd}'

UA_VALUE_TYPE_BOOL = UA_TYPES_NS + 'Boolean'
UA_VALUE_TYPE_BYTE = UA_TYPES_NS + 'Byte'
UA_VALUE_TYPE_INT16 = UA_TYPES_NS + 'Int16'
UA_VALUE_TYPE_INT32 = UA_TYPES_NS + 'Int32'
UA_VALUE_TYPE_INT64 = UA_TYPES_NS + 'Int64'
UA_VALUE_TYPE_GUID = UA_TYPES_NS + 'Guid'
UA_VALUE_TYPE_NODEID = UA_TYPES_NS + 'NodeId'
UA_VALUE_TYPE_SBYTE = UA_TYPES_NS + 'SByte'
UA_VALUE_TYPE_UINT16 = UA_TYPES_NS + 'UInt16'
UA_VALUE_TYPE_UINT32 = UA_TYPES_NS + 'UInt32'
UA_VALUE_TYPE_UINT64 = UA_TYPES_NS + 'UInt64'
UA_VALUE_TYPE_FLOAT = UA_TYPES_NS + 'Float'
UA_VALUE_TYPE_DOUBLE = UA_TYPES_NS + 'Double'
UA_VALUE_TYPE_STRING = UA_TYPES_NS + 'String'
UA_VALUE_TYPE_BYTESTRING = UA_TYPES_NS + 'ByteString'
UA_VALUE_TYPE_XMLELEMENT = UA_TYPES_NS + 'XmlElement'
UA_VALUE_TYPE_DATETIME = UA_TYPES_NS + 'DateTime'
UA_VALUE_TYPE_LISTOFBOOLEANS = UA_TYPES_NS + 'ListOfBoolean'
UA_VALUE_TYPE_LISTOFSTRINGS = UA_TYPES_NS + 'ListOfString'

VALUE_TYPE_BOOL = 0
VALUE_TYPE_BYTE = 1
VALUE_TYPE_INT16 = 2
VALUE_TYPE_INT32 = 3
VALUE_TYPE_INT64 = 4
VALUE_TYPE_GUID = 5
VALUE_TYPE_NODEID = 6
VALUE_TYPE_SBYTE = 7
VALUE_TYPE_UINT16 = 8
VALUE_TYPE_UINT32 = 9
VALUE_TYPE_UINT64 = 10
VALUE_TYPE_FLOAT = 11
VALUE_TYPE_DOUBLE = 12
VALUE_TYPE_STRING = 13
VALUE_TYPE_BYTESTRING = 14
VALUE_TYPE_XMLELEMENT = 15
VALUE_TYPE_DATETIME = 16

C_IDENTIFIER_TYPES = [
    'SOPC_IdentifierType_Numeric',
    'SOPC_IdentifierType_String',
    'SOPC_IdentifierType_Guid',
    'SOPC_IdentifierType_ByteString'
]


c_header = '''
/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include "sopc_address_space.h"

#include <stdio.h>
#include <stdbool.h>

#include "opcua_statuscodes.h"

#include "sopc_builtintypes.h"
#include "sopc_enums.h"
#include "sopc_types.h"

'''.lstrip()


class ParseError(Exception):
    """
    Errors raised during XML parsing
    """
    pass


class CodeGenerationError(Exception):
    """
    Errors raised during C code generation
    """
    pass


class NodeId(object):
    __slots__ = 'ns', 'ty', 'data'

    def __init__(self, ns, ty, data):
        self.ns = ns
        self.ty = ty
        self.data = data

    def __str__(self):
        s = ('ns=%d;' % self.ns) if self.ns else ''

        if self.ty == ID_TYPE_NUMERIC:
            s += ('i=%d' % self.data)
        elif self.ty == ID_TYPE_STRING:
            s += ('s=%s' % self.data)
        elif self.ty == ID_TYPE_GUID:
            s += ('g=%s' % str(self.data))
        elif self.ty == ID_TYPE_BYTESTRING:
            s += ('b=%s' % base64.standard_b64encode(self.data))

        return s

    @staticmethod
    def parse(nodeid):
        ty = None
        data = None
        cur = nodeid

        # Parse namespace
        if nodeid.startswith('ns='):
            ns_end_idx = nodeid.find(';')

            if ns_end_idx == -1:
                raise ParseError('Invalid NodeId: ' + nodeid)

            try:
                ns = int(nodeid[3:ns_end_idx])
            except ValueError:
                raise ParseError('Non integer namespace in NodeId: ' + nodeid)

            cur = cur[ns_end_idx+1:]
        else:
            ns = None

        if len(cur) < 3:
            raise ParseError('Truncated NodeId: ' + nodeid)

        if cur[0] == 'i':
            ty = ID_TYPE_NUMERIC

            try:
                data = int(cur[2:])
            except ValueError:
                raise ParseError('Invalid numeric NodeId: ' + nodeid)
        elif cur[0] == 's':
            ty = ID_TYPE_STRING
            data = cur[2:]
        elif cur[0] == 'g':
            ty = ID_TYPE_GUID

            try:
                data = uuid.UUID(cur[2:])
            except ValueError:
                raise ParseError('Invalid GUID NodeId: ' + nodeid)
        elif cur[0] == 'b':
            ty = ID_TYPE_BYTESTRING

            try:
                data = base64.standard_b64decode(cur[2:])
            except TypeError:
                raise ParseError('Invalid bytestring NodeId: ' + nodeid)

        return NodeId(ns, ty, data)


class QName(object):
    __slots__ = 'ns', 'name'

    def __init__(self, ns, name):
        self.ns = ns
        self.name = name

    @staticmethod
    def parse(qname):
        idx = qname.find(':')

        if idx == -1:
            return QName(None, qname)

        try:
            ns = int(qname[0:idx])
        except ValueError:
            raise ParseError('Invalid namespace in qualified name: ' + qname)

        name = qname[1+idx:]

        if not name:
            raise ParseError('Missing name in qualified name: ' + qname)

        return QName(ns, name)


class LocalizedText(object):
    __slots__ = 'locale', 'text'

    def __init__(self, locale, text):
        self.locale = locale
        self.text = text


class VariableValue(object):
    __slots__ = 'ty', 'val', 'is_array'

    def __init__(self, ty, val, is_array):
        self.ty = ty
        self.val = val
        self.is_array = is_array


class Node(object):
    __slots__ = 'tag', 'nodeid', 'browse_name', 'description', 'display_name', 'references',\
                'idonly', 'value', 'data_type', 'value_rank', 'accesslevel'

    def __init__(self, tag, nodeid, browse_name, description, display_name, references):
        self.tag = tag
        self.nodeid = nodeid
        self.browse_name = browse_name
        self.description = description
        self.display_name = display_name
        self.references = references
        self.idonly = False
        self.value = None
        self.data_type = None
        self.value_rank = None
        self.accesslevel = None


class Reference(object):
    __slots__ = 'ty', 'target', 'is_forward'

    def __init__(self, ty, target, is_forward):
        self.ty = ty
        self.target = target
        self.is_forward = is_forward


def expect_element(source, name=None):
    ev, n = next(source)

    if ev != 'start':
        n.clear()
        raise ParseError('Expected element start, got ' + ev)

    return check_element(n, name)


def check_element(n, name=None):
    if not isinstance(n, Element):
        n.clear()
        raise ParseError('Expected element, got %s' % str(n))

    if name is not None and n.tag != name:
        n.clear()
        raise ParseError('Expected element %s, got %s' % (name, str(n)))

    return n


def skip_element(source, name):
    while True:
        try:
            ev, n = next(source)
        except StopIteration:
            raise ParseError('Unexpected end of document while skipping to end of ' + name)

        finished = (ev == 'end' and isinstance(n, Element) and n.tag == name)
        n.clear()

        if finished:
            return


def parse_element(source, name):
    while True:
        try:
            ev, n = next(source)
        except StopIteration:
            raise ParseError('Unexpected end of document while parsing to end of ' + name)

        if ev == 'end' and isinstance(n, Element) and n.tag == name:
            return


def collect_aliases(node):
    aliases = {}

    for n in node.findall(UA_ALIAS_TAG):
        try:
            name = n.attrib['Alias']
        except KeyError:
            raise ParseError('Missing Alias for alias ' + n.text)

        aliases[name] = n.text

    return aliases


def localized_text_of_child(node, name):
    child = node.find(name)

    if child is None:
        return None

    return LocalizedText(child.get('Locale'), child.text)


def collect_node_references(node, aliases):
    refs = []

    refs_node = node.find(UA_REFERENCES_TAG)

    if refs_node is None:
        return refs

    for n in refs_node.findall(UA_REFERENCE_TAG):
        try:
            ref_type = n.attrib['ReferenceType']
        except KeyError:
            raise ParseError('Missing ReferenceType on Reference element for node ' + node.get('NodeId'))

        # In case there is an alias, resolve it
        ref_type = NodeId.parse(aliases.get(ref_type, ref_type))

        is_forward = (parse_boolean_value(n.get('IsForward', 'true')))

        refs.append(Reference(ref_type, NodeId.parse(n.text), is_forward))

    return refs


def parse_boolean_value(text):
    return text.strip() == 'true'


def parse_guid(text):
    try:
        return uuid.UUID(text)
    except ValueError:
        raise ParseError('Invalid GUID: %s' % text)


def boolean_to_string(val):
    return 'true' if val else 'false'


# Collects all the uax:{tag_name} items in a uax:ListOfXXX element
def collect_list_items(n, tag_name, parse_func):
    return list(map(lambda x: parse_func(x.text), n.findall(tag_name)))


# Parses the base type of a value tag name (eg. uax:Boolean, uax:ListOfString...)
# and returns the base type (eg. uax:Boolean, uax:String...) and whether the value
# is an array or not.
# Returns a (base_type_url, is_array) tuple.
def parse_value_tag(tag_name):
    LIST_PREFIX = 'ListOf'

    if not tag_name.startswith(UA_TYPES_NS):
        return tag_name, False

    base_name = tag_name[len(UA_TYPES_NS):]

    if base_name.startswith(LIST_PREFIX):
        return UA_TYPES_NS + base_name[len(LIST_PREFIX):], True
    else:
        return tag_name, False


def identity(x):
    return x

# Returns a VariableValue object
def collect_variable_value(n):

    value_node = n.find(UA_VALUE_TAG)

    if value_node is None:
        # print('No Value tag in Variable or VariableType for node %s' % n.attrib['NodeId'])
        return None

    if len(value_node) != 1:
        raise ParseError('Value tag should have exactly one children')

    value = list(value_node)[0]
    base_type, is_array = parse_value_tag(value.tag)

    if base_type == UA_VALUE_TYPE_BOOL:
        ty = VALUE_TYPE_BOOL
        parse_func = parse_boolean_value
    elif base_type == UA_VALUE_TYPE_BYTE:
        ty = VALUE_TYPE_BYTE
        parse_func = int
    elif base_type == UA_VALUE_TYPE_INT16:
        ty = VALUE_TYPE_INT16
        parse_func = int
    elif base_type == UA_VALUE_TYPE_INT32:
        ty = VALUE_TYPE_INT32
        parse_func = int
    elif base_type == UA_VALUE_TYPE_INT64:
        ty = VALUE_TYPE_INT64
        parse_func = int
    elif base_type == UA_VALUE_TYPE_GUID:
        ty = VALUE_TYPE_GUID
        parse_func = parse_guid
    elif base_type == UA_VALUE_TYPE_NODEID:
        ty = VALUE_TYPE_NODEID
        parse_func = identity
    elif base_type == UA_VALUE_TYPE_SBYTE:
        ty = VALUE_TYPE_SBYTE
        parse_func = int
    elif base_type == UA_VALUE_TYPE_UINT16:
        ty = VALUE_TYPE_UINT16
        parse_func = int
    elif base_type == UA_VALUE_TYPE_UINT32:
        ty = VALUE_TYPE_UINT32
        parse_func = int
    elif base_type == UA_VALUE_TYPE_UINT64:
        ty = VALUE_TYPE_UINT64
        parse_func = int
    elif base_type == UA_VALUE_TYPE_FLOAT:
        ty = VALUE_TYPE_FLOAT
        parse_func = float
    elif base_type == UA_VALUE_TYPE_DOUBLE:
        ty = VALUE_TYPE_DOUBLE
        parse_func = float
    elif base_type == UA_VALUE_TYPE_STRING:
        ty = VALUE_TYPE_STRING
        parse_func = identity
    elif base_type == UA_VALUE_TYPE_BYTESTRING:
        ty = VALUE_TYPE_BYTESTRING
        parse_func = identity
    elif base_type == UA_VALUE_TYPE_XMLELEMENT:
        ty = VALUE_TYPE_XMLELEMENT
        parse_func = identity
    elif base_type == UA_VALUE_TYPE_DATETIME:
        ty = VALUE_TYPE_DATETIME
        parse_func = identity
    else:
        raise ParseError('Unknown value type %s for node %s' % (value.tag, n.attrib['NodeId']))

    val = collect_list_items(value, base_type, parse_func) if is_array else parse_func(value.text)

    return VariableValue(ty, val, is_array)

def parse_datatype_attribute(datatype_attr, aliases):
    node = NodeId.parse(aliases.get(datatype_attr, datatype_attr))
    return node

def parse_value_rank_attribute(value_rank_node):
    value_rank = -1
    if 'ValueRank' in value_rank_node.attrib:
        try:
            value_rank = int(value_rank_node.attrib['ValueRank'])
        except:
            raise ParseError('Non integer ValueRank for node %s' % value_rank_node['NodeId'])
    return value_rank


def generate_string(data):
    assert data is None or isinstance(data, str), "Invalid string data: %r" % data

    if data is not None:
        return '{%d, 1, (SOPC_Byte*) "%s"}' % (len(data), data.replace('"', '\\"'))

    return '{0, 0, NULL}'


def generate_guid(data):
    assert isinstance(data, uuid.UUID)

    members = list(data.fields[0:5])

    for i in range(5, -1, -1):
        members.append((data.fields[5] >> (8*i)) & 0xFF)

    return '{0x%02x, 0x%02x, 0x%02x, {0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x}}' % tuple(members)


def generate_byte_string(data):
    return generate_string(data)


def generate_qname(qname):
    assert isinstance(qname, QName)
    return '{%d, %s}' % (qname.ns or 0, generate_string(qname.name))


def generate_nodeid(nodeid):
    id_type = C_IDENTIFIER_TYPES[nodeid.ty]
    data_struct_field = '.Data.' + id_type[len('SOPC_IdentifierType_'):]

    if nodeid.ty == ID_TYPE_NUMERIC:
        data_struct_val = str(nodeid.data)
    elif nodeid.ty == ID_TYPE_STRING:
        data_struct_val = generate_string(nodeid.data)
    elif nodeid.ty == ID_TYPE_GUID:
        data_struct_val = generate_guid(nodeid.data)
    elif nodeid.ty == ID_TYPE_BYTESTRING:
        data_struct_val = generate_byte_string(nodeid.data)
    else:
        raise CodeGenerationError('Unknown NodeId data type')

    return '{%s, %d, %s = %s}' % (id_type, nodeid.ns or 0, data_struct_field, data_struct_val)


def generate_localized_text(text):
    if text is None:
        return '{%s, %s}' % (generate_string(None), generate_string(None))

    return '{%s, %s}' % (generate_string(text.locale), generate_string(text.text))


def generate_variant(type_id, c_type, field, val, is_array, generate_func):
    if is_array:
        field += 'Arr'
        c_array = '(%s[]){%s}' % (c_type, ','.join(map(generate_func, val))) if val else 'NULL'
        return '{true, %s, SOPC_VariantArrayType_Array, {.Array = {%d, {.%s = %s}}}}' % (type_id, len(val), field, c_array)
    else:
        return '{true, %s, SOPC_VariantArrayType_SingleValue, {.%s = %s}}' % (type_id, field, generate_func(val))


POINTER_VARIANT_TYPES = {VALUE_TYPE_GUID, VALUE_TYPE_NODEID, VALUE_TYPE_DATETIME}


def generate_value_variant(val):
    if val is None:
        return '{true, SOPC_Null_Id, SOPC_VariantArrayType_SingleValue, {0}}'

    if val.ty == VALUE_TYPE_BOOL:
        return generate_variant('SOPC_Boolean_Id', 'SOPC_Boolean', 'Boolean', val.val, val.is_array, boolean_to_string)
    elif val.ty == VALUE_TYPE_BYTE:
        return generate_variant('SOPC_Byte_Id', 'SOPC_Byte', 'Byte', val.val, val.is_array, str)
    elif val.ty == VALUE_TYPE_INT16:
        return generate_variant('SOPC_Int16_Id', 'int16_t', 'Int16', val.val, val.is_array, str)
    elif val.ty == VALUE_TYPE_INT32:
        return generate_variant('SOPC_Int32_Id', 'int32_t', 'Int32', val.val, val.is_array, str)
    elif val.ty == VALUE_TYPE_INT64:
        return generate_variant('SOPC_Int64_Id', 'int64_t', 'Int64', val.val, val.is_array, lambda x: str(x) + 'L')
    elif val.ty == VALUE_TYPE_SBYTE:
        return generate_variant('SOPC_SByte_Id', 'SOPC_SByte', 'Sbyte', val.val, val.is_array, str)
    elif val.ty == VALUE_TYPE_UINT16:
        return generate_variant('SOPC_UInt16_Id', 'uint16_t', 'Uint16', val.val, val.is_array, str)
    elif val.ty == VALUE_TYPE_UINT32:
        return generate_variant('SOPC_UInt32_Id', 'uint32_t', 'Uint32', val.val, val.is_array, str)
    elif val.ty == VALUE_TYPE_UINT64:
        return generate_variant('SOPC_UInt64_Id', 'uint64_t', 'Uint64', val.val, val.is_array, lambda x: str(x) + 'UL')
    elif val.ty == VALUE_TYPE_FLOAT:
        return generate_variant('SOPC_Float_Id', 'float', 'Floatv', val.val, val.is_array, str)
    elif val.ty == VALUE_TYPE_DOUBLE:
        return generate_variant('SOPC_Double_Id', 'double', 'Doublev', val.val, val.is_array, str)
    elif val.ty == VALUE_TYPE_STRING:
        return generate_variant('SOPC_String_Id', 'SOPC_String', 'String', val.val, val.is_array, generate_string)
    elif val.ty == VALUE_TYPE_BYTESTRING:
        return generate_variant('SOPC_ByteString_Id', 'SOPC_ByteString', 'Bstring', val.val, val.is_array, generate_string)
    elif val.ty == VALUE_TYPE_XMLELEMENT:
        return generate_variant('SOPC_XmlElement_Id', 'SOPC_XmlElement', 'XmlElt', val.val, val.is_array, generate_string)
    elif val.ty in POINTER_VARIANT_TYPES:
        # FIXME: The variant requires a pointer here, we need to wrap the value inside a 1-sized
        # array to trick the compiler.
        raise CodeGenerationError('This value type is not supported yet')
    else:
        raise CodeGenerationError('Unknown value type: %d' % val.ty)

def parse_uanode(xml_node, source, aliases):
    parse_element(source, xml_node.tag)
    nodeid = NodeId.parse(xml_node.attrib['NodeId'])
    browse_name = QName.parse(xml_node.attrib['BrowseName'])
    description = localized_text_of_child(xml_node, UA_DESCRIPTION_TAG)
    display_name = localized_text_of_child(xml_node, UA_DISPLAY_NAME_TAG)
    references = collect_node_references(xml_node, aliases)

    node = Node(
        xml_node.tag,
        nodeid,
        browse_name,
        description,
        display_name,
        references
    )

    if (xml_node.tag == UA_VARIABLE_TAG) or (xml_node.tag == UA_VARIABLE_TYPE_TAG):
        node.value = collect_variable_value(xml_node)

        if 'DataType' in xml_node.attrib:
            node.data_type = parse_datatype_attribute(xml_node.attrib['DataType'], aliases)
        else:
            # TODO: VariableType DataType ?
            node.data_type = NodeId(0,0,0)

        node.value_rank = parse_value_rank_attribute(xml_node)
        
        accesslevel = xml_node.get('AccessLevel', None)

        if accesslevel is not None:
            try:
                node.accesslevel = int(accesslevel)
            except ValueError:
                raise ParseError('Non integer AccessLevel for node %s' % xml_node['NodeId'])

    return node


def generate_reference(ref):
    return '''                {
                    &OpcUa_ReferenceNode_EncodeableType,
                    %s,
                    %s,
                    {%s, %s, 0},
                }''' % (
        generate_nodeid(ref.ty),
        'false' if ref.is_forward else 'true',
        generate_nodeid(ref.target),
        generate_string(None)
    )


def generate_item(ua_node, ty, variant_field, value_status='OpcUa_BadDataUnavailable', **kwargs):
    extra = ''

    for k, v in kwargs.items():
        extra += ('\n            .%s = %s,' % (k, v))

    references = list(map(generate_reference, ua_node.references))
    references_str = ('(OpcUa_ReferenceNode[]) {\n' +
                      ',\n'.join(references) +
                      '\n            }') if references else 'NULL'

    return '''    {
        OpcUa_NodeClass_%s,
        %s,
        {0, 0},
        {.%s={
            .encodeableType = &OpcUa_%sNode_EncodeableType,
            .NodeId = %s,
            .NodeClass = OpcUa_NodeClass_%s,
            .BrowseName = %s,
            .DisplayName = %s,
            .Description = %s,
            .NoOfReferences = %d,
            .References = %s,%s
        }}
    },\n''' % (
        ty,
        value_status,
        variant_field,
        ty,
        generate_nodeid(ua_node.nodeid),
        ty,
        generate_qname(ua_node.browse_name),
        generate_localized_text(ua_node.display_name),
        generate_localized_text(ua_node.description),
        len(ua_node.references),
        references_str,
        extra
    )


def generate_item_object(ua_node):
    return generate_item(ua_node, 'Object', 'object')


def number_coalesce(n, default):
    return n if n is not None else default

def default_variable_status(ua_node):
    value_status = '0x00' # Good status
    if ua_node.value is None and ua_node.nodeid.ns != None and ua_node.nodeid.ns != 0:
        # Keep OPC UA default namespace nodes with a Good status, necessary to pass UACTT
        # othewise keep Good status only if a value is defined
        value_status='OpcUa_BadDataUnavailable'
    return value_status

def generate_item_variable(ua_node):
    value_status = default_variable_status(ua_node)
    return generate_item(ua_node, 'Variable', 'variable', value_status,
                         Value=generate_value_variant(ua_node.value),
                         DataType=generate_nodeid(ua_node.data_type),
                         ValueRank="(%d)" % ua_node.value_rank,
                         AccessLevel=str(number_coalesce(ua_node.accesslevel, 1)))


def generate_item_variable_type(ua_node):
    value_status = default_variable_status(ua_node)
    return generate_item(ua_node, 'VariableType', 'variable_type', value_status,
                         Value=generate_value_variant(ua_node.value),
                         DataType=generate_nodeid(ua_node.data_type),
                         ValueRank="(%d)" % ua_node.value_rank)

def generate_item_object_type(ua_node):
    return generate_item(ua_node, 'ObjectType', 'object_type')


def generate_item_reference_type(ua_node):
    return generate_item(ua_node, 'ReferenceType', 'reference_type')


def generate_item_data_type(ua_node):
    return generate_item(ua_node, 'DataType', 'data_type')


def generate_item_method(ua_node):
    return generate_item(ua_node, 'Method', 'method')


GEN_ITEM_FUNCS = {
    UA_OBJECT_TAG: generate_item_object,
    UA_VARIABLE_TAG: generate_item_variable,
    UA_VARIABLE_TYPE_TAG: generate_item_variable_type,
    UA_OBJECT_TYPE_TAG: generate_item_object_type,
    UA_REFERENCE_TYPE_TAG: generate_item_reference_type,
    UA_DATA_TYPE_TAG: generate_item_data_type,
    UA_METHOD_TAG: generate_item_method,
}


# Returns an array of Node objects
def generate_address_space(source, out):
    aliases = {}
    n_items = 0

    out.write(c_header)
    out.write('SOPC_AddressSpace_Item SOPC_Embedded_AddressSpace_Items[] = {\n')

    expect_element(source, UA_NODESET_TAG).clear()

    while True:
        try:
            ev, n = next(source)
        except StopIteration:
            raise ParseError('Unexpected end of document while parsing UANodeSet')

        if ev == 'end' and n.tag == UA_NODESET_TAG:
            out.write('};\n')
            out.write('uint32_t SOPC_Embedded_AddressSpace_nItems = %d;\n' % n_items)
            return

        check_element(n)

        gen_func = GEN_ITEM_FUNCS.get(n.tag, None)

        if gen_func:
            out.write(gen_func(parse_uanode(n, source, aliases)))
            n_items += 1
        elif n.tag == UA_ALIASES_TAG:
            parse_element(source, n.tag)
            aliases.update(collect_aliases(n))
        else:
            skip_element(source, n.tag)

        n.clear()


def main():
    argparser = argparse.ArgumentParser(description='Generate the S2OPC address space from an OPC UA NodeSet')
    argparser.add_argument('xml_file', metavar='XML_FILE',
                           help='Path to the address space XML file')
    argparser.add_argument('c_file', metavar='C_FILE',
                           help='Path to the generated C file')
    args = argparser.parse_args()

    print('Generating C model...')
    with open(args.xml_file, 'rb') as xml_fd, open(args.c_file, 'w', encoding='utf8') as out_fd:
        try:
            generate_address_space(iterparse(xml_fd, events=('start', 'end')), out_fd)
        except ParseError as e:
            sys.stderr.write('Woops, an error occurred: %s\n' % str(e))
            sys.exit(1)

    print('Done.')


if __name__ == '__main__':
    main()
