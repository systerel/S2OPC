/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/** \file
 *
 * \brief File Transfer API
 *
 * \note The file is saved locally as a ByteString
 * \note The MAX_SIZE_FILE value defines the maximum size of a file
 * \note Two callbacks are provided to the user (in opening and closing method).
 *       Its allows the user to save the file on their own.
 *       The user can also limit the opening mode.
 * \note Limitations :
 *        - Allows only one simultaneous opening per file.
 *        - A file handle remains valid on close session (standard OPC UA deviation).
 *        - UserWritable variable are not supported (initialize to `true` at the first open method call, when Writable
 *          variable is not defined)
 */

#include "libs2opc_server.h"
#include "sopc_builtintypes.h"

/**
 * \brief File handle type. Generated by the server (in Open Method)
 *        and used by the client to call other methods on the file.
 */
typedef uint32_t SOPC_FileHandle;

/**
 * \brief Open mode type (receive from the client, bit mask)
 */
typedef SOPC_Byte SOPC_OpenMode;

/**
 * \brief The abstract structure type for an OpcUa FileType.
 */
typedef struct _SOPC_FileType SOPC_FileType;

/**
 * \brief The abstract structure type for an OpcUa FileType Configuration.
 */
typedef struct _SOPC_FileType_Config SOPC_FileType_Config;

/**
 * \brief User callback for the file opening processing.
 *        Allows the user to limit the opening mode.
 *        Allows the user to synchronize the contents of a file
 *        (for example : in the event of modification without using read/write methods of FileTransfer).
 *
 * \param      openMode             A Byte representing the opening mode requested by the client on the Open method.
 * \param[out] authorized           A Boolean pointer returned by the user to allow him to limit
 *                                  authorization of the \p openMode received by the Open method.
 * \param[out] fileByteString       A Bytestring pointer representing the file contents.
 *                                  if NULL, takes the contents of the locally saved file.
 *                                  otherwise, takes \p fileByteString as the new file contents.
 *
 * \note S2OPC File Transfer module provides a valid pointer to a SOPC_ByteString for \p fileByteString.
 *       If needed, the user must allocate the contents of \p fileByteString. It will be released by S2OPC.
 *       The size of \p fileByteString must be less than MAX_SIZE_FILE.
 *
 * \warning No blocking or long treatment in this callback.
 */
typedef void SOPC_FileTransfer_UserOpen_Callback(const SOPC_OpenMode openMode,
                                                 bool* authorized,
                                                 SOPC_ByteString* fileByteString);

/**
 * \brief User callback for the file closing processing.
 *        Allows the user to save the file on their own.
 *
 * \param      fileByteString       A Bytestring pointer representing the fileType contents.
 * \param[out] localSave            A Boolean pointer returned by the user to indicate if the \p fileByteString
 *                                  need to be store locally. 0 save, 1 erase.
 *
 * \note the \p fileByteString memory management is handled by the S2OPC.
 *       If the user wants to keep the \p fileByteString, he must copy it.
 *
 * \warning No blocking or long treatment in this callback.
 */
typedef void SOPC_FileTransfer_UserClose_Callback(SOPC_ByteString* fileByteString, bool* localSave);

/**
 * \brief Initializes the File Transfer module. Create Dictionary. Register FileType type methods.
 * \note Memory allocation, need to call ::SOPC_FileTransfer_Clear() after use.
 * \warning The function shall be called after SOPC_ServerConfigHelper_Initialize.
 * \return SOPC_STATUS_OK on success, error code otherwise
 */
SOPC_ReturnStatus SOPC_FileTransfer_Initialize(SOPC_MethodCallManager* methodCallManager);

/**
 * \brief Removes a FileType object from the File Transfer module.
 * \note  FileType object methods are still registered in the method call manager.
 *        If one of these methods is called after the remove, an error code will be returned.
 */
void SOPC_FileType_Remove(SOPC_FileType* pFile);

/**
 * \brief Clears the File Transfer module.
 * \note Delete all file inside.
 */
void SOPC_FileTransfer_Clear(void);

/**
 * \brief Creates a File configuration from methods, variables and file NodeIds.
 *
 * \param fileNodeId        The NodeId of the file object.
 * \param metOpenId         The NodeId of the Open method.
 * \param metCloseId        The NodeId of the Close method.
 * \param metReadId         The NodeId of the Read method.
 * \param metWriteId        The NodeId of the Write method.
 * \param metGetPosId       The NodeId of the GetPosition method.
 * \param metSetPosId       The NodeId of the SetPosition method.
 * \param varSizeId         The NodeId of the Size variable.
 * \param varOpenCountId    The NodeId of the OpenCount variable.
 * \param varUserWritableId The NodeId of the UserWritable variable.
 * \param varWritableId     The NodeId of the Writable variable.
 *
 * \return A pointer to the created FileType configuration.
 */
SOPC_FileType_Config* SOPC_FileType_Config_CreateFromNodeId(const SOPC_NodeId* fileNodeId,
                                                            const SOPC_NodeId* metOpenId,
                                                            const SOPC_NodeId* metCloseId,
                                                            const SOPC_NodeId* metReadId,
                                                            const SOPC_NodeId* metWriteId,
                                                            const SOPC_NodeId* metGetPosId,
                                                            const SOPC_NodeId* metSetPosId,
                                                            const SOPC_NodeId* varSizeId,
                                                            const SOPC_NodeId* varOpenCountId,
                                                            const SOPC_NodeId* varUserWritableId,
                                                            const SOPC_NodeId* varWritableId);
/**
 * \brief Creates a File configuration from methods, variables and file StringNodeIds.
 *
 * \param fileStrNodeId     The string representing the nodeId of the file object.
 * \param metOpenId         The string representing the nodeId of the Open method.
 * \param metCloseId        The string representing the nodeId of the Close method.
 * \param metReadId         The string representing the nodeId of the Read method.
 * \param metWriteId        The string representing the nodeId of the Write method.
 * \param metGetPosId       The string representing the nodeId of the GetPosition method.
 * \param metSetPosId       The string representing the nodeId of the SetPosition method.
 * \param varSizeId         The string representing the nodeId of the Size variable.
 * \param varOpenCountId    The string representing the nodeId of the OpenCount variable.
 * \param varUserWritableId The string representing the nodeId of the UserWritable variable.
 * \param varWritableId     The string representing the nodeId of the Writable variable.
 *
 * \return A pointer to the created FileType configuration.
 */
SOPC_FileType_Config* SOPC_FileType_Config_CreateFromStringNodeId(const char* fileStrNodeId,
                                                                  const char* metOpenId,
                                                                  const char* metCloseId,
                                                                  const char* metReadId,
                                                                  const char* metWriteId,
                                                                  const char* metGetPosId,
                                                                  const char* metSetPosId,
                                                                  const char* varSizeId,
                                                                  const char* varOpenCountId,
                                                                  const char* varUserWritableId,
                                                                  const char* varWritableId);

/**
 * \brief Creates a FileType object. Add File object to FileTransfer module.
 *        Add associated methods to methodCallManager.
 *
 * \param fileConfig  The configuration of the FileType object.
 *
 * \warning The \p fileConfig memory is managed by the FileTransfer module.
 *          The user must no longer use it.
 *
 * \return A pointer to the created FileType object.
 */
SOPC_FileType* SOPC_FileType_Create(SOPC_FileType_Config* fileConfig);

/**
 * \brief Gets the file NodeId from the \p file pointer.
 * \return File nodeId or NULL on failure
 */
SOPC_NodeId* SOPC_FileType_GetFileNodeId(SOPC_FileType* file);

/**
 * \brief Gets the file pointer from the \p fileNodeId.
 * \return FileType pointer or NULL on failure
 */
SOPC_FileType* SOPC_FileType_GetFileFromNodeId(const SOPC_NodeId* fileNodeId);

/**
 * \brief Gets the file mode from the \p file pointer.
 * \return File OpenMode or invalid OpenMode (0) on failure
 */
SOPC_OpenMode SOPC_FileType_GetMode(const SOPC_FileType* file);

/**
 * \brief Gets the file handle from the \p file pointer.
 * \return File handle or invalid handle (0) on failure
 */
SOPC_FileHandle SOPC_FileType_GetHandle(const SOPC_FileType* file);

/**
 * \brief Gets the permanent file content from the \p file pointer.
 * \return An SOPC_ByteString or NULL on failure
 */
SOPC_ByteString* SOPC_FileType_GetCopyPermFileContent(const SOPC_FileType* file);

/**
 * \brief Gets the temporary file content from the \p file pointer.
 * \return An SOPC_Buffer or NULL on failure
 */
SOPC_Buffer* SOPC_FileType_GetCopyTmpFileContent(SOPC_FileType* file);

/**
 * \brief Sets the user open callback function for \p file.
 * \param file          The FileType object.
 * \param userOpenCb    The user open callback function.
 * \return SOPC_STATUS_OK on success, otherwise SOPC_STATUS_INVALID_PARAMETERS.
 */
SOPC_ReturnStatus SOPC_FileType_SetUserOpenCb(SOPC_FileType* file, SOPC_FileTransfer_UserOpen_Callback* userOpenCb);

/**
 * \brief Sets the user close callback function for \p file.
 * \param file          The FileType object.
 * \param userCloseCb   The user close callback function.
 * \return SOPC_STATUS_OK on success, otherwise SOPC_STATUS_INVALID_PARAMETERS.
 */
SOPC_ReturnStatus SOPC_FileType_SetUserCloseCb(SOPC_FileType* file, SOPC_FileTransfer_UserClose_Callback* userCloseCb);

/* API access methods */
/**
 * \brief Close Method access.
 */
SOPC_StatusCode SOPC_FileTransfer_CloseMethodAccess(const SOPC_CallContext* callContextPtr,
                                                    const SOPC_NodeId* objectId,
                                                    uint32_t nbInputArgs,
                                                    const SOPC_Variant* inputArgs,
                                                    uint32_t* nbOutputArgs,
                                                    SOPC_Variant** outputArgs,
                                                    void* param);
